<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="DengKing">
  <link rel="shortcut icon" href="../../../img/favicon.ico">
  <title>wikipedia Formal language - automata-and-formal-language</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  <link href="../../../css/extra.css" rel="stylesheet">
  
  <script>
    // Current page data
    var mkdocs_page_name = "wikipedia Formal language";
    var mkdocs_page_input_path = "theory-framework/Formal-language/wikipedia-Formal-language.md";
    var mkdocs_page_url = "/automata-and-formal-language/theory-framework/Formal-language/wikipedia-Formal-language/";
  </script>
  
  <script src="../../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/django.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../../.." class="icon icon-home"> automata-and-formal-language</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="../../..">Home</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Introduction</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../../Introduction/index.md">Introduction</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Theory-framework</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../../Theory-framework/index.md">Introduction</a>
                </li>
                <li class="">
                    
    <span class="caption-text">Formal-language</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../../../Theory-framework/Formal-language/index.md">Introduction</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../Theory-framework/Formal-language/Description-and-language.md">Description-and-language</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../Theory-framework/Formal-language/wikipedia-Formal-language.md">Formal-language</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../Theory-framework/Formal-language/wikipedia-Formal-system.md">Formal-system</a>
                </li>
                <li class="toctree-l3">
                    
    <span class="caption-text">Formal-grammar</span>
    <ul class="subnav">
                <li class="toctree-l4">
                    
    <a class="" href="../../../Theory-framework/Formal-language/Formal-grammar/wikipedia-Formal-grammar.md">Formal-grammar</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../../../Theory-framework/Formal-language/Formal-grammar/wikipedia-Production(computer-science).md">Production</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../../../Theory-framework/Formal-language/Formal-grammar/wikipedia-Backus-Naur-form/">BNF</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
    </ul>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../..">automata-and-formal-language</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../..">Docs</a> &raquo;</li>
    
      
    
    <li>wikipedia Formal language</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <div class="toc">
<ul>
<li><a href="#formal_language">Formal language</a><ul>
<li><a href="#words_over_an_alphabet">Words over an alphabet</a></li>
<li><a href="#definition">Definition</a><ul>
<li><a href="#constructions">Constructions</a></li>
</ul>
</li>
<li><a href="#language-specification_formalisms">Language-specification formalisms</a></li>
<li><a href="#operations_on_languages">Operations on languages</a></li>
<li><a href="#applications">Applications</a><ul>
<li><a href="#programming_languages">Programming languages</a></li>
<li><a href="#formal_theories_systems_and_proofs">Formal theories, systems, and proofs</a><ul>
<li><a href="#interpretations_and_models">Interpretations and models</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#_1">梳理</a><ul>
<li><a href="#formal_system_and_formal_language">Formal system and formal language</a></li>
<li><a href="#mathematical_logicformal_grammars">从Mathematical logic的角度来看Formal grammars</a></li>
<li><a href="#automata_theoryformal_language">Automata theory和Formal language</a></li>
<li><a href="#turing_machine_and_mathematical_logic">Turing machine and Mathematical logic</a></li>
</ul>
</li>
</ul>
</div>
<h2 id="formal_language"><a href="https://en.wikipedia.org/wiki/Formal_language">Formal language</a><a class="headerlink" href="#formal_language" title="Permanent link">#</a></h2>
<p>In <a href="https://en.wikipedia.org/wiki/Mathematics">mathematics</a>, <a href="https://en.wikipedia.org/wiki/Computer_science">computer science</a>, and <a href="https://en.wikipedia.org/wiki/Linguistics">linguistics</a>, a <strong>formal language</strong> consists of <a href="https://en.wikipedia.org/wiki/String_(computer_science)">words</a> whose <a href="https://en.wikipedia.org/wiki/Symbol_(formal)">letters</a> are taken from an <a href="https://en.wikipedia.org/wiki/Alphabet_(computer_science)">alphabet</a> and are <a href="https://en.wikipedia.org/wiki/Well-formedness">well-formed</a> according to a specific set of rules. </p>
<p>The <a href="https://en.wikipedia.org/wiki/Alphabet_(computer_science)">alphabet</a> of a formal language consist of symbols, letters, or tokens that concatenate into strings of the language. Each string concatenated from symbols of this alphabet is called a <strong>word</strong>, and the words that belong to a particular formal language are sometimes called <em>well-formed words</em> or <em><a href="https://en.wikipedia.org/wiki/Well-formed_formula">well-formed formulas</a></em>. A formal language is often defined by means of a <a href="https://en.wikipedia.org/wiki/Formal_grammar">formal grammar</a> such as a <a href="https://en.wikipedia.org/wiki/Regular_grammar">regular grammar</a> or <a href="https://en.wikipedia.org/wiki/Context-free_grammar">context-free grammar</a>, which consists of its <a href="https://en.wikipedia.org/wiki/Formation_rule">formation rules</a>. </p>
<p>The field of <strong>formal language theory</strong> studies primarily the purely <a href="https://en.wikipedia.org/wiki/Syntax">syntactical</a>（语法） aspects of such languages—that is, their <strong>internal structural patterns</strong>. <strong>Formal language theory</strong> sprang out of linguistics, as a way of understanding the syntactic regularities（规律） of <a href="https://en.wikipedia.org/wiki/Natural_language">natural languages</a>. </p>
<p>In computer science, <strong>formal languages</strong> are used among others as the basis for defining the <strong>grammar</strong> of <a href="https://en.wikipedia.org/wiki/Programming_language">programming languages</a> and formalized versions of subsets of natural languages in which the words of the language represent concepts that are associated with particular meanings or <a href="https://en.wikipedia.org/wiki/Semantics">semantics</a>（语义）. </p>
<p>In <a href="https://en.wikipedia.org/wiki/Computational_complexity_theory">computational complexity theory</a>, <a href="https://en.wikipedia.org/wiki/Decision_problem">decision problems</a> are typically defined as <strong>formal languages</strong>, and <a href="https://en.wikipedia.org/wiki/Complexity_class">complexity classes</a> are defined as the sets of the formal languages that can be <a href="https://en.wikipedia.org/wiki/Parser">parsed by machines</a> with limited computational power. </p>
<p>In <a href="https://en.wikipedia.org/wiki/Logic">logic</a> and the <a href="https://en.wikipedia.org/wiki/Foundations_of_mathematics">foundations of mathematics</a>, formal languages are used to represent the syntax of <a href="https://en.wikipedia.org/wiki/Axiomatic_system">axiomatic systems</a>, and <a href="https://en.wikipedia.org/wiki/Formalism_(mathematics)">mathematical formalism</a> is the philosophy that all of mathematics can be reduced to the syntactic manipulation of formal languages in this way. </p>
<blockquote>
<p>NOTE: 上面这段话的第一句话揭示了<strong>formal language</strong>和 <a href="https://en.wikipedia.org/wiki/Logic">logic</a> 之间的关系。</p>
<p>NOTE: 最后一段话的意思是：<a href="https://en.wikipedia.org/wiki/Formalism_(mathematics)">mathematical formalism</a>的思想是：所有的数学都可以通过这种方式简化为formal language的syntactic manipulation。浏览了一下这篇文章，发现<a href="https://en.wikipedia.org/wiki/Theory_of_computation">theory of computation</a>中的很多课题都源于这个思想，比如<a href="https://en.wikipedia.org/wiki/Turing_machine">Turing machine</a>。</p>
</blockquote>
<h3 id="words_over_an_alphabet">Words over an alphabet<a class="headerlink" href="#words_over_an_alphabet" title="Permanent link">#</a></h3>
<p>An <strong>alphabet</strong>, in the context of formal languages, can be any <a href="https://en.wikipedia.org/wiki/Set_(mathematics)">set</a>, although it often makes sense to use an <a href="https://en.wikipedia.org/wiki/Alphabet">alphabet</a> in the usual sense of the word, or more generally a <a href="https://en.wikipedia.org/wiki/Character_set">character set</a> such as <a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a> or <a href="https://en.wikipedia.org/wiki/Unicode">Unicode</a>. The elements of an alphabet are called its <strong>letters</strong>. An alphabet may contain an <a href="https://en.wikipedia.org/wiki/Countable_set">infinite</a> number of elements; however, most definitions in formal language theory specify alphabets with a finite number of elements, and most results apply only to them.</p>
<p>A <strong>word</strong> over an alphabet can be any finite sequence (i.e., <a href="https://en.wikipedia.org/wiki/String_(computer_science)">string</a>) of letters. The set of all words over an alphabet Σ is usually denoted by Σ<em> (using the <a href="https://en.wikipedia.org/wiki/Kleene_star">Kleene star</a>). The length of a word is the number of letters it is composed of. For any alphabet, there is only one word of length 0, the </em>empty word*, which is often denoted by e, ε, λ or even Λ. By <a href="https://en.wikipedia.org/wiki/Concatenation">concatenation</a> one can combine two words to form a new word, whose length is the sum of the lengths of the original words. The result of concatenating a word with the empty word is the original word.</p>
<p>In some applications, especially in <a href="https://en.wikipedia.org/wiki/Logic">logic</a>, the alphabet is also known as the <em>vocabulary</em> and words are known as <em>formulas</em> or <em>sentences</em>; this breaks the letter/word metaphor and replaces it by a word/sentence metaphor.</p>
<blockquote>
<p>NOTE: 在formal language理论中，<strong>alphabet</strong>、 <a href="https://en.wikipedia.org/wiki/Character_set">character set</a>  、vocabulary可以认为是同义词。</p>
</blockquote>
<h3 id="definition">Definition<a class="headerlink" href="#definition" title="Permanent link">#</a></h3>
<p>A <strong>formal language</strong> <em>L</em> over an alphabet Σ is a <a href="https://en.wikipedia.org/wiki/Subset">subset</a> of Σ*, that is, a set of <a href="https://en.wikipedia.org/wiki/Formal_language#Words_over_an_alphabet">words</a> over that alphabet. Sometimes the sets of words are grouped into expressions, whereas rules and constraints may be formulated for the creation of 'well-formed expressions'.</p>
<blockquote>
<p>NOTE: 所谓的rules其实就是grammar。</p>
</blockquote>
<p>In computer science and mathematics, which do not usually deal with <a href="https://en.wikipedia.org/wiki/Natural_language">natural languages</a>, the adjective "formal" is often omitted as redundant.</p>
<blockquote>
<p>NOTE: 按照这个说法，programming language的更加严谨的说法是：programming formal language。</p>
</blockquote>
<p>While formal language theory usually concerns itself with formal languages that are described by some syntactical rules, the actual definition of the concept "formal language" is only as above: a (possibly infinite) set of finite-length strings composed from a given alphabet, no more and no less. In practice, there are many languages that can be described by <strong>rules</strong>, such as <a href="https://en.wikipedia.org/wiki/Regular_language">regular languages</a> or <a href="https://en.wikipedia.org/wiki/Context-free_language">context-free languages</a>. The notion of a <a href="https://en.wikipedia.org/wiki/Formal_grammar">formal grammar</a> may be closer to the intuitive concept of a "language," one described by syntactic rules. By an abuse of the definition, a particular formal language is often thought of as being equipped with a <strong>formal grammar</strong> that describes it.</p>
<blockquote>
<p>NOTE: 上面这段话所强调的是formal language的准确定义中是不包含rules（grammar）的。但是实际中，要想准确的定义一门语言是离不开rules的。以programming language为例的话，它需要词法和语法才能够正确地描述该语言。</p>
</blockquote>
<h4 id="constructions">Constructions<a class="headerlink" href="#constructions" title="Permanent link">#</a></h4>
<p>For finite languages, one can explicitly <strong>enumerate</strong> all well-formed words. For example, we can describe a language <em>L</em> as just <em>L</em> = {a, b, ab, cba}. The <a href="https://en.wikipedia.org/wiki/Degeneracy_(mathematics)">degenerate</a> case of this construction is the <strong>empty language</strong>, which contains no words at all (<em>L</em> = <a href="https://en.wikipedia.org/wiki/∅">∅</a>).</p>
<p>However, even over a finite (non-empty) alphabet such as Σ = {a, b} there are an infinite number of finite-length words that can potentially be expressed: "a", "abb", "ababba", "aaababbbbaab", .... Therefore, formal languages are typically infinite, and describing an infinite formal language is not as simple as writing <em>L</em> = {a, b, ab, cba}. Here are some examples of formal languages:</p>
<ul>
<li><em>L</em> = Σ<em>, the set of </em>all* words over Σ;</li>
<li>$L = {a}^<em> = {a^n}$, where </em>n<em> ranges over the natural numbers and "$a^n$" means "a" repeated </em>n* times (this is the set of words consisting only of the symbol "a");</li>
<li>the set of syntactically correct programs in a given programming language (the syntax of which is usually defined by a <a href="https://en.wikipedia.org/wiki/Context-free_grammar">context-free grammar</a>);</li>
<li>the set of inputs upon which a certain <a href="https://en.wikipedia.org/wiki/Turing_machine">Turing machine</a> halts; or</li>
<li>the set of maximal strings of <a href="https://en.wikipedia.org/wiki/Alphanumeric">alphanumeric</a> <a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a> characters on this line, i.e.,
  the set {the, set, of, maximal, strings, alphanumeric, ASCII, characters, on, this, line, i, e}.</li>
</ul>
<h3 id="language-specification_formalisms">Language-specification formalisms<a class="headerlink" href="#language-specification_formalisms" title="Permanent link">#</a></h3>
<p>Formal languages are used as tools in multiple disciplines. However, <strong>formal language theory</strong> rarely concerns itself with particular languages (except as examples), but is mainly concerned with the study of various types of <strong>formalisms</strong> to describe languages. For instance, a language can be given as</p>
<ul>
<li>those strings generated by some <a href="https://en.wikipedia.org/wiki/Formal_grammar">formal grammar</a>;</li>
<li>those strings described or matched by a particular <a href="https://en.wikipedia.org/wiki/Regular_expression">regular expression</a>;</li>
<li>those strings accepted by some <a href="https://en.wikipedia.org/wiki/Automata_theory">automaton</a>, such as a <a href="https://en.wikipedia.org/wiki/Turing_machine">Turing machine</a> or <a href="https://en.wikipedia.org/wiki/Finite-state_machine">finite-state automaton</a>;</li>
<li>those strings for which some <a href="https://en.wikipedia.org/wiki/Decision_problem">decision procedure</a> (an <a href="https://en.wikipedia.org/wiki/Algorithm">algorithm</a> that asks a sequence of related YES/NO questions) produces the answer YES.</li>
</ul>
<p>Typical questions asked about such <strong>formalisms</strong> include:</p>
<ul>
<li>What is their expressive power? (Can formalism <em>X</em> describe every language that formalism <em>Y</em> can describe? Can it describe other languages?)</li>
<li>What is their recognizability? (How difficult is it to decide whether a given word belongs to a language described by formalism <em>X</em>?)</li>
<li>What is their comparability? (How difficult is it to decide whether two languages, one described in formalism <em>X</em> and one in formalism <em>Y</em>, or in <em>X</em> again, are actually the same language?).</li>
</ul>
<p>Surprisingly often, the answer to these decision problems is "it cannot be done at all", or "it is extremely expensive" (with a characterization of how expensive). Therefore, formal language theory is a major application area of <a href="https://en.wikipedia.org/wiki/Computability_theory_(computer_science)">computability theory</a> and <a href="https://en.wikipedia.org/wiki/Computational_complexity_theory">complexity theory</a>. Formal languages may be classified in the <a href="https://en.wikipedia.org/wiki/Chomsky_hierarchy">Chomsky hierarchy</a> based on the expressive power of their <strong>generative grammar</strong> as well as the complexity of their recognizing <a href="https://en.wikipedia.org/wiki/Automata_theory">automaton</a>. <a href="https://en.wikipedia.org/wiki/Context-free_grammar">Context-free grammars</a> and <a href="https://en.wikipedia.org/wiki/Regular_grammar">regular grammars</a> provide a good compromise between expressivity and ease of <a href="https://en.wikipedia.org/wiki/Parsing">parsing</a>, and are widely used in practical applications.</p>
<h3 id="operations_on_languages">Operations on languages<a class="headerlink" href="#operations_on_languages" title="Permanent link">#</a></h3>
<p>Certain operations on languages are common. This includes the standard set operations, such as union, intersection, and complement. Another class of operation is the element-wise application of string operations.</p>
<p>Examples: suppose $ L_{1} $ and $ L_{2} $ are languages over some common alphabet $ \Sigma $.</p>
<ul>
<li>The <em><a href="https://en.wikipedia.org/wiki/Concatenation">concatenation</a></em> $ L_{1}\cdot L_{2} $ consists of all strings of the form $ vw $ where $ v $ is a string from $ L_{1} $ and $ w $ is a string from $ L_{2} $.</li>
<li>The <em>intersection</em> $ L_{1}\cap L_{2} $ of $ L_{1} $ and $ L_{2} $ consists of all strings that are contained in both languages</li>
<li>The <em>complement</em> $ \neg L_{1} $ of $ L_{1} $ with respect to $ \Sigma $ consists of all strings over $ \Sigma $ that are not in $ L_{1} $.</li>
<li>The <a href="https://en.wikipedia.org/wiki/Kleene_star">Kleene star</a>: the language consisting of all words that are concatenations of zero or more words in the original language;</li>
<li>Reversal:</li>
<li>Let <em>ε</em> be the empty word, then $ \varepsilon ^{R}=\varepsilon $, and</li>
<li>for each non-empty word $ w=\sigma <em>{1}\cdots \sigma </em>{n} $ (where $ \sigma <em>{1},\ldots ,\sigma </em>{n} $are elements of some alphabet), let $ w^{R}=\sigma <em>{n}\cdots \sigma </em>{1} $,</li>
<li>then for a formal language $ L $, $ L^{R}={w^{R}\mid w\in L} $.</li>
<li><a href="https://en.wikipedia.org/wiki/String_homomorphism">String homomorphism</a></li>
</ul>
<p>Such <a href="https://en.wikipedia.org/wiki/String_operations">string operations</a> are used to investigate <a href="https://en.wikipedia.org/wiki/Closure_(mathematics)">closure properties</a> of classes of languages. A class of languages is closed under a particular operation when the operation, applied to languages in the class, always produces a language in the same class again. For instance, the <a href="https://en.wikipedia.org/wiki/Context-free_language">context-free languages</a> are known to be closed under union, concatenation, and intersection with <a href="https://en.wikipedia.org/wiki/Regular_language">regular languages</a>, but not closed under intersection or complement. The theory of <a href="https://en.wikipedia.org/wiki/Cone_(formal_languages)">trios</a> and <a href="https://en.wikipedia.org/wiki/Abstract_family_of_languages">abstract families of languages</a> studies the most common closure properties of language families in their own right.</p>
<h3 id="applications">Applications<a class="headerlink" href="#applications" title="Permanent link">#</a></h3>
<h4 id="programming_languages">Programming languages<a class="headerlink" href="#programming_languages" title="Permanent link">#</a></h4>
<p><em>Main articles:</em> <a href="https://en.wikipedia.org/wiki/Compiler_compiler">Compiler compiler</a> and <a href="https://en.wikipedia.org/wiki/Syntax_(programming_languages)">Syntax (programming languages)</a></p>
<h4 id="formal_theories_systems_and_proofs">Formal theories, systems, and proofs<a class="headerlink" href="#formal_theories_systems_and_proofs" title="Permanent link">#</a></h4>
<p><em>Main articles:</em> <a href="https://en.wikipedia.org/wiki/Theory_(mathematical_logic)">Theory (mathematical logic)</a> and <a href="https://en.wikipedia.org/wiki/Formal_system">Formal system</a></p>
<p>In <a href="https://en.wikipedia.org/wiki/Mathematical_logic">mathematical logic</a>, a <em>formal theory</em> is a set of <a href="https://en.wikipedia.org/wiki/Sentence_(mathematical_logic)">sentences</a> expressed in a <strong>formal language</strong>.</p>
<p>A <em>formal system</em> (also called a <em>logical calculus</em>, or a <em>logical system</em>) consists of a <strong>formal language</strong> together with a <a href="https://en.wikipedia.org/wiki/Deductive_apparatus">deductive apparatus</a> (also called a <em>deductive system</em>). The deductive apparatus may consist of a set of <a href="https://en.wikipedia.org/wiki/Transformation_rule">transformation rules</a>, which may be interpreted as valid rules of inference, or a set of <a href="https://en.wikipedia.org/wiki/Axiom">axioms</a>, or have both. A formal system is used to <a href="https://en.wikipedia.org/wiki/Proof_theory">derive</a> one expression from one or more other expressions. Although a formal language can be identified with its formulas, a formal system cannot be likewise identified by its theorems. Two formal systems $ {\mathcal {FS}} $ and $ {\mathcal {FS'}} $ may have all the same theorems and yet differ in some significant proof-theoretic way (a formula A may be a syntactic consequence of a formula B in one but not another for instance).</p>
<p>A <em>formal proof</em> or <em>derivation</em> is a finite sequence of well-formed formulas (which may be interpreted as sentences, or <a href="https://en.wikipedia.org/wiki/Proposition">propositions</a>) each of which is an axiom or follows from the preceding formulas in the sequence by a <a href="https://en.wikipedia.org/wiki/Rule_of_inference">rule of inference</a>. The last sentence in the sequence is a theorem of a formal system. Formal proofs are useful because their theorems can be interpreted as true propositions.</p>
<h5 id="interpretations_and_models">Interpretations and models<a class="headerlink" href="#interpretations_and_models" title="Permanent link">#</a></h5>
<p><em>Main articles:</em> <a href="https://en.wikipedia.org/wiki/Formal_semantics_(logic)">Formal semantics (logic)</a>, <a href="https://en.wikipedia.org/wiki/Interpretation_(logic)">Interpretation (logic)</a> and <a href="https://en.wikipedia.org/wiki/Model_theory">Model theory</a></p>
<p>Formal languages are entirely syntactic in nature but may be given <a href="https://en.wikipedia.org/wiki/Semantics">semantics</a> that give meaning to the elements of the language. For instance, in mathematical <a href="https://en.wikipedia.org/wiki/Logic">logic</a>, the set of possible formulas of a particular logic is a formal language, and an <a href="https://en.wikipedia.org/wiki/Interpretation_(logic)">interpretation</a> assigns a meaning to each of the formulas—usually, a <a href="https://en.wikipedia.org/wiki/Truth_value">truth value</a>.</p>
<p>The study of interpretations of formal languages is called <a href="https://en.wikipedia.org/wiki/Formal_semantics_(logic)">formal semantics</a>. In mathematical logic, this is often done in terms of <a href="https://en.wikipedia.org/wiki/Model_theory">model theory</a>. In model theory, the terms that occur in a formula are interpreted as objects within <a href="https://en.wikipedia.org/wiki/Structure_(mathematical_logic)">mathematical structures</a>, and fixed compositional interpretation rules determine how the truth value of the formula can be derived from the interpretation of its terms; a <em>model</em> for a formula is an interpretation of terms such that the formula becomes true.</p>
<blockquote>
<p><img alt="img" src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Formal_languages.svg/300px-Formal_languages.svg.png" /></p>
<p>This diagram shows the <a href="https://en.wikipedia.org/wiki/Syntax_(logic)">syntactic</a> divisions within a <a href="https://en.wikipedia.org/wiki/Formal_system">formal system</a>. <a href="https://en.wikipedia.org/wiki/String_(computer_science)">Strings of symbols</a> may be broadly divided into nonsense and <a href="https://en.wikipedia.org/wiki/Well-formed_formula">well-formed formulas</a>. The set of well-formed formulas is divided into <a href="https://en.wikipedia.org/wiki/Theorem">theorems</a> and non-theorems.</p>
</blockquote>
<h2 id="_1">梳理<a class="headerlink" href="#_1" title="Permanent link">#</a></h2>
<h3 id="formal_system_and_formal_language"><a href="https://en.wikipedia.org/wiki/Formal_system">Formal system</a> and formal language<a class="headerlink" href="#formal_system_and_formal_language" title="Permanent link">#</a></h3>
<p>下面这段摘自<a href="https://en.wikipedia.org/wiki/Formation_rule#Formal_systems">Formal systems</a></p>
<blockquote>
<p>A <em>formal system</em> (also called a <em>logical calculus</em>, or a <em>logical system</em>) consists of a formal language together with a <a href="https://en.wikipedia.org/wiki/Deductive_apparatus">deductive apparatus</a> (also called a <em>deductive system</em>). The deductive apparatus may consist of a set of <a href="https://en.wikipedia.org/wiki/Transformation_rule">transformation rules</a> (also called <em>inference rules</em>) or a set of <a href="https://en.wikipedia.org/wiki/Axiom">axioms</a>, or have both. A formal system is used to <a href="https://en.wikipedia.org/wiki/Proof_theory">derive</a> one expression from one or more other expressions. Propositional and predicate calculi are examples of formal systems.</p>
</blockquote>
<p><a href="https://en.wikipedia.org/wiki/Formal_grammar">Formal grammars</a>相当于 <a href="https://en.wikipedia.org/wiki/Deductive_apparatus">deductive apparatus</a>。</p>
<h3 id="mathematical_logicformal_grammars">从<a href="https://en.wikipedia.org/wiki/Mathematical_logic">Mathematical logic</a>的角度来看<a href="https://en.wikipedia.org/wiki/Formal_grammar">Formal grammars</a><a class="headerlink" href="#mathematical_logicformal_grammars" title="Permanent link">#</a></h3>
<p>如果从<a href="https://en.wikipedia.org/wiki/Mathematical_logic">Mathematical logic</a>的逻辑推导的角度来看待<a href="https://en.wikipedia.org/wiki/Formal_grammar">Formal grammars</a>的话，<a href="https://en.wikipedia.org/wiki/Formal_grammar">formal grammars</a>的很多内容就变得非常容易理解：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Formal_grammar">formal grammars</a>本质上就是<a href="https://en.wikipedia.org/wiki/Formation_rule">推导规则</a></li>
</ul>
<p>下面总结了formal grammar中的一些概念和mathematical logic中的一些概念之间的对应关系，如下：</p>
<table>
<thead>
<tr>
<th><a href="https://en.wikipedia.org/wiki/Formal_grammar">Formal grammar</a></th>
<th><a href="https://en.wikipedia.org/wiki/Mathematical_logic">Mathematical logic</a></th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://en.wikipedia.org/wiki/Production_(computer_science)">Production rule</a></td>
<td><a href="https://en.wikipedia.org/wiki/Formation_rule">Formation rule</a>、<a href="https://en.wikipedia.org/wiki/Rule_of_inference">Rule of inference</a>、<a href="https://en.wikipedia.org/wiki/Rewriting">Rewriting</a></td>
</tr>
</tbody>
</table>
<p>按照公式进行推导从另外一个角度来看其实是重写，不断地进行替换，感觉数理逻辑本质上就是这个东西。从这个角度来看，parsing的过程其实就是不断的推导的过程，不断的重写的过程。由于可能的推导格式是非常多的，所以需要不断地进行尝试，这个过程其实就是<a href="https://en.wikipedia.org/wiki/Search_algorithm">search</a>、<a href="https://en.wikipedia.org/wiki/Backtracking">backtracking</a>，所以从这个角度来看，<a href="https://en.wikipedia.org/wiki/Parsing">parsing</a>所做的工作其实就是推导加search。自顶向下其实所对应的是正向推导，自底向上其实所对应的就是方向推导。</p>
<blockquote>
<p>NOTE: 在龙书的4.2.3 Derivations有这样的描述：</p>
<p>The construction of a parse tree can b e made precise by taking a <strong>derivational view</strong>, in which productions are treated as <strong>rewriting rules</strong>. Beginning with the start symbol, each rewriting step replaces a nonterminal by the body of one of its productions. This derivational view corresponds to the top-down construction of a parse tree, but the precision afforded by derivations will be especially helpful when bottom-up parsing is discussed. As we shall see, bottom-up parsing is related to a class of derivations known as "rightmost" derivations, in which the rightmost nonterminal is rewritten at each step.</p>
</blockquote>
<p>上面的这些内容给我的启发是：不同的学科对同一事物的命名可能不同，但是它们本质上所描述的是同一事物。</p>
<p>其实上述所有这些讨论，本质上都是属于<a href="https://en.wikipedia.org/wiki/Logic">Logic</a>学的范轴，推导（<a href="https://en.wikipedia.org/wiki/Inference">inference</a>）就属于逻辑学的范轴。</p>
<p><a href="https://en.wikipedia.org/wiki/Set_theory">Set theory</a>是数学的基石所在，很多其他数学学科都是建立在它的基础之上。</p>
<h3 id="automata_theoryformal_language"><a href="https://en.wikipedia.org/wiki/Automata_theory">Automata theory</a>和<a href="https://en.wikipedia.org/wiki/Formal_language">Formal language</a><a class="headerlink" href="#automata_theoryformal_language" title="Permanent link">#</a></h3>
<p>在上述<a href="#Language-specification formalisms">Language-specification formalisms</a>章节就对<a href="https://en.wikipedia.org/wiki/Automata_theory">Automata theory</a>和<a href="https://en.wikipedia.org/wiki/Formal_language">Formal language</a>之间的关系进行了分析。</p>
<p><a href="https://en.wikipedia.org/wiki/Chomsky_hierarchy">Chomsky hierarchy</a>将<a href="https://en.wikipedia.org/wiki/Automata_theory">Automata theory</a>和<a href="https://en.wikipedia.org/wiki/Formal_language">formal language</a>进行了关联和对应。需要注意的是，<a href="https://en.wikipedia.org/wiki/Automata_theory">Automata theory</a>在其他领域有着非常广泛的应用。</p>
<h3 id="turing_machine_and_mathematical_logic"><a href="https://en.wikipedia.org/wiki/Turing_machine">Turing machine</a> and <a href="https://en.wikipedia.org/wiki/Mathematical_logic">Mathematical logic</a><a class="headerlink" href="#turing_machine_and_mathematical_logic" title="Permanent link">#</a></h3>
<p>在第一段的NOTE中就对两者进行了分析。</p>
<p>除此之外，下面文章也是值得阅读的：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Automated_theorem_proving">Automated theorem proving</a></li>
<li><a href="https://en.wikipedia.org/wiki/Formal_methods">Formal methods</a></li>
</ul>
              
            </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/dengking/automata-and-formal-language" class="fa fa-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
      
    </span>
</div>
    <script>var base_url = '../../..';</script>
    <script src="../../../js/theme.js" defer></script>
      <script src="../../../search/main.js" defer></script>

</body>
</html>
