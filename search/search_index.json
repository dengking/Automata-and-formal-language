{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u5173\u4e8e\u672c\u5de5\u7a0b \u51fa\u4e8e\u5982\u4e0b\u539f\u56e0\u6211\u521b\u5efa\u4e86\u8fd9\u4e2a\u9879\u76ee\uff1a \u5728\u4ece\u4e8b NLP \u76f8\u5173\u7684\u9879\u76ee\u7684\u5f00\u53d1\u8fc7\u7a0b\u4e2d\uff0c\u9047\u5230\u4e86\u5f88\u591a\u548c \u8bed\u8a00 \u76f8\u5173\u7684\u7406\u8bba \u9605\u8bfb \u300aNatural Language Processing with Python\u300b \u65f6\uff0c\u53d1\u73b0\u5176\u4e2d\u6d89\u53ca\u4e86\u4e00\u4e9b\u548c \u8bed\u8a00 \u76f8\u5173\u7684\u7406\u8bba \u9605\u8bfb \u300a Compilers: Principles, Techniques, and Tools \u300b \uff08\u9f99\u4e66\uff09\u65f6\uff0c\u53d1\u73b0\u5176\u4e2d\u6d89\u53ca\u4e86\u5f88\u591a formal language \u76f8\u5173\u7684\u7406\u8bba \u5bf9language\u7684\u601d\u8003 \u8fd9\u4e2a\u9879\u76ee\u662f\u5bf9 \u8bed\u8a00 \u76f8\u5173\u7684\u7406\u8bba\u7684\u4e00\u4e2a\u68b3\u7406\uff0c\u5b83\u4e3b\u8981\u4f5c\u4e3a\u5982\u4e0b\u9879\u76ee\u6240\u6d89\u53ca\u7684\u7406\u8bba\u7684\u603b\u7ed3\uff1a \u5de5\u7a0b compiler-principle \u5de5\u7a0b programming-language \u4f5c\u4e3asoftware engineer\uff0c\u6211\u4eec\u4e0d\u4ec5\u4ec5\u9700\u8981\u4f1a\u4f7f\u7528programming language\uff0c\u8fd8\u9700\u8981\u638c\u63e1\u5982\u4f55\u8bbe\u8ba1programming language\u3001computation of language\u3002 \u4e3b\u8981\u5185\u5bb9\u5982\u4e0b: \u7ae0\u8282 \u4e3b\u8981\u5185\u5bb9 Language \u63cf\u8ff0language\u76f8\u5173\u7684\u5185\u5bb9 Formal language \u5bf9formal language\u8fdb\u884c\u63cf\u8ff0","title":"Home"},{"location":"#_1","text":"\u51fa\u4e8e\u5982\u4e0b\u539f\u56e0\u6211\u521b\u5efa\u4e86\u8fd9\u4e2a\u9879\u76ee\uff1a \u5728\u4ece\u4e8b NLP \u76f8\u5173\u7684\u9879\u76ee\u7684\u5f00\u53d1\u8fc7\u7a0b\u4e2d\uff0c\u9047\u5230\u4e86\u5f88\u591a\u548c \u8bed\u8a00 \u76f8\u5173\u7684\u7406\u8bba \u9605\u8bfb \u300aNatural Language Processing with Python\u300b \u65f6\uff0c\u53d1\u73b0\u5176\u4e2d\u6d89\u53ca\u4e86\u4e00\u4e9b\u548c \u8bed\u8a00 \u76f8\u5173\u7684\u7406\u8bba \u9605\u8bfb \u300a Compilers: Principles, Techniques, and Tools \u300b \uff08\u9f99\u4e66\uff09\u65f6\uff0c\u53d1\u73b0\u5176\u4e2d\u6d89\u53ca\u4e86\u5f88\u591a formal language \u76f8\u5173\u7684\u7406\u8bba \u5bf9language\u7684\u601d\u8003 \u8fd9\u4e2a\u9879\u76ee\u662f\u5bf9 \u8bed\u8a00 \u76f8\u5173\u7684\u7406\u8bba\u7684\u4e00\u4e2a\u68b3\u7406\uff0c\u5b83\u4e3b\u8981\u4f5c\u4e3a\u5982\u4e0b\u9879\u76ee\u6240\u6d89\u53ca\u7684\u7406\u8bba\u7684\u603b\u7ed3\uff1a \u5de5\u7a0b compiler-principle \u5de5\u7a0b programming-language \u4f5c\u4e3asoftware engineer\uff0c\u6211\u4eec\u4e0d\u4ec5\u4ec5\u9700\u8981\u4f1a\u4f7f\u7528programming language\uff0c\u8fd8\u9700\u8981\u638c\u63e1\u5982\u4f55\u8bbe\u8ba1programming language\u3001computation of language\u3002 \u4e3b\u8981\u5185\u5bb9\u5982\u4e0b: \u7ae0\u8282 \u4e3b\u8981\u5185\u5bb9 Language \u63cf\u8ff0language\u76f8\u5173\u7684\u5185\u5bb9 Formal language \u5bf9formal language\u8fdb\u884c\u63cf\u8ff0","title":"\u5173\u4e8e\u672c\u5de5\u7a0b"},{"location":"Dyck-language/","text":"Dyck language Properties The Dyck language is closed under the operation of concatenation . By treating $ \\Sigma ^{ } $ as an algebraic monoid under concatenation we see that the monoid structure transfers onto the quotient $ \\Sigma ^{ }/R $, resulting in the syntactic monoid of the Dyck language . The class $ \\operatorname {Cl} (\\epsilon ) $ will be denoted $ 1 $. The syntactic monoid of the Dyck language is not commutative : if $ u=\\operatorname {Cl} ([) $ and $ v=\\operatorname {Cl} (]) $ then $ uv=\\operatorname {Cl} ([])=1\\neq \\operatorname {Cl} (][)=vu $. With the notation above, $ uv=1 $ but neither $ u $ nor $ v $ are invertible in $ \\Sigma ^{*}/R $. The syntactic monoid of the Dyck language is isomorphic to the bicyclic semigroup by virtue of the properties of $ \\operatorname {Cl} ([) $ and $ \\operatorname {Cl} (]) $ described above. By the Chomsky\u2013Sch\u00fctzenberger representation theorem , any context-free language is a homomorphic image of the intersection of some regular language with a Dyck language on one or more kinds of bracket pairs. NOTE: \u63d0\u8fc7Dyck language\uff0c\u5f15\u5165hierarchy\u3002 The Dyck language with two distinct types of brackets can be recognized in the complexity class $ TC^{0} $ .[ 2] The number of distinct Dyck words with exactly n pairs of parentheses is the n -th Catalan number .","title":"Introduction"},{"location":"Dyck-language/#dyck#language","text":"","title":"Dyck language"},{"location":"Dyck-language/#properties","text":"The Dyck language is closed under the operation of concatenation . By treating $ \\Sigma ^{ } $ as an algebraic monoid under concatenation we see that the monoid structure transfers onto the quotient $ \\Sigma ^{ }/R $, resulting in the syntactic monoid of the Dyck language . The class $ \\operatorname {Cl} (\\epsilon ) $ will be denoted $ 1 $. The syntactic monoid of the Dyck language is not commutative : if $ u=\\operatorname {Cl} ([) $ and $ v=\\operatorname {Cl} (]) $ then $ uv=\\operatorname {Cl} ([])=1\\neq \\operatorname {Cl} (][)=vu $. With the notation above, $ uv=1 $ but neither $ u $ nor $ v $ are invertible in $ \\Sigma ^{*}/R $. The syntactic monoid of the Dyck language is isomorphic to the bicyclic semigroup by virtue of the properties of $ \\operatorname {Cl} ([) $ and $ \\operatorname {Cl} (]) $ described above. By the Chomsky\u2013Sch\u00fctzenberger representation theorem , any context-free language is a homomorphic image of the intersection of some regular language with a Dyck language on one or more kinds of bracket pairs. NOTE: \u63d0\u8fc7Dyck language\uff0c\u5f15\u5165hierarchy\u3002 The Dyck language with two distinct types of brackets can be recognized in the complexity class $ TC^{0} $ .[ 2] The number of distinct Dyck words with exactly n pairs of parentheses is the n -th Catalan number .","title":"Properties"},{"location":"Formal-language/","text":"\u5173\u4e8e\u672c\u7ae0 \u672c\u7ae0\u8282\uff0c\u9996\u5148\u63cf\u8ff0\u4e0a\u9762\u662f\"formal\"\uff0c\u5f15\u51fa Formal language \uff0c \u7136\u540e\u5bf9\u5b83\u8fdb\u884c\u8be6\u7ec6\u7684\u5206\u6790\u3002\u7ef4\u57fa\u767e\u79d1\u7684 Formal language \u5185\u5bb9\u662f\u975e\u5e38\u597d\u7684\uff08\u5168\u9762\uff0c\u6df1\u5165\u6d45\u51fa\uff09\uff0c\u9700\u8981\u4ed4\u7ec6\u9605\u8bfb\u3002 \u9996\u5148\u8bf4\u660eformal language\uff0cformal grammar\uff0cautomata\uff0cChomsky hierarchy\u7b49\u57fa\u672c\u6982\u5ff5\uff0c\u5efa\u7acb\u7406\u8bba\u6846\u67b6\u3002 \u7136\u540e\u6309\u7167Chomsky hierarchy\u7684\u6bcf\u4e00\u5c42\u8fdb\u884c\u8bf4\u660e\uff0c\u5bf9Chomsky hierarchy\u7684\u6bcf\u4e00\u5c42\u7684\u8bf4\u660e\u91c7\u7528\u5982\u4e0b\u987a\u5e8f\uff0c\u5373\uff1a Type-3 grammars: Regular grammar Type-2 grammars: Context-free grammar Type-1 grammars: Context-sensitive grammar Type-0 grammars: Unrestricted grammar \u8fd9\u662f\u56e0\u4e3a\u4eceType-3 grammars\u5230Type-0 grammars\uff0cgrammar\u8d8a\u6765\u8d8a\u62bd\u8c61\uff0c\u8d8a\u6765\u8d8a\u96be\u7406\u89e3\uff0c\u8fd9\u6837\u7531\u6613\u5230\u96be\u4f1a\u6bd4\u8f83\u7b26\u5408\u8ba4\u77e5\u89c4\u5f8b\u3002 \u5728\u4e86\u89e3\u4e86\u8fd9\u4e9b\u4e4b\u540e\uff0c\u6211\u4eec\u4e0d\u80fd\u591f\u4ec5\u4ec5\u5c40\u9650\u4e8e\u6b64\uff0c\u800c\u662f\u5e94\u8be5\u8d70\u5411\u66f4\u52a0\u5bbd\u5e7f\u7684\u7406\u8bba\uff1a Theory of computation \uff0c\u56e0\u4e3a\u6309\u71672012 ACM Computing Classification System \uff0c\u524d\u9762\u6240\u8ba8\u8bba\u7684 formal language \uff0c automata theory \u90fd\u5c5e\u4e8e\u6b64\u8303\u8f74\u3002 \u7406\u8bba\u5f80\u5f80\u4e0d\u662f\u5b64\u7acb\u7684\uff0c\u800c\u662f\u76f8\u4e92\u5173\u8054\uff0c\u76f8\u4e92\u501f\u7528\u7684\uff0c\u76f8\u4e92\u542f\u53d1\u7684\uff0c\u5728\u9605\u8bfb Formal language \u65f6\uff0c\u4f60\u4f1a\u53d1\u73b0\u4f5c\u8005\u5bf9\u5b83\u8fdb\u884c\u4e86\u5927\u91cf\u7684\u53d1\u6563\uff0c\u6d89\u53ca\u5230\u7684\u5b66\u79d1\u6709 mathematics \uff08\u5c24\u5176\u662f Mathematical logic \uff09, computer science , and linguistics \u3002\u6240\u4ee5\uff0c\u5728\u9605\u8bfb\u7684\u65f6\u5019\uff0c\u5c31\u6709\u5fc5\u8981\u68b3\u7406\u6e05\u695a\u6982\u5ff5\u4e4b\u95f4\u7684\u5173\u7cfb\uff0c\u6293\u4f4f\u95ee\u9898\u7684\u672c\u8d28\uff0c\u800c\u4e0d\u662f\u88ab\u8868\u9762\u7684\u63cf\u8ff0\u8bc6\u6240\u6270\u4e71\u3002 \u5b66\u4e60\u8ba1\u5212--\u4ece\u5165\u95e8\u5230\u7cbe\u901a Formal language \u6240\u6d89\u53ca\u7684\u7406\u8bba\u8f83\u591a\uff0c\u5e76\u4e14\u5927\u591a\u6570\u90fd\u662f\u6bd4\u8f83\u62bd\u8c61\u7684\uff0c\u521a\u5f00\u59cb\u5b66\u4e60\uff08\u5c24\u5176\u5bf9\u4e8e\u7f3a\u4e4f\u4f7f\u7528programming language\u7684\u4eba\u6765\u8bf4\uff09\u53ef\u80fd\u4f1a\u611f\u89c9\u6bd4\u8f83\u5403\u529b\uff0c\u4ee5\u4e0b\u662f\u89c9\u5f97\u6bd4\u8f83\u597d\u7684\u5b66\u4e60\u8ba1\u5212\uff1a \u9996\u5148\u641e\u6e05\u695awhat is language\u3001what is formal language\u3001what is formal grammar\u3001what is automata\u3001What is the relationship between them\uff0c\u8fd9\u6837\u5c31\u5efa\u7acb\u8d77\u4e86\u5efa\u7acb\u8d77\u9ad8\u5c4b\u5efa\u74f4\u7684\u89c6\u91ce\uff0c\u8fd9\u5176\u5b9e\u5c31\u662f\u7b97\u5165\u95e8\u4e86\u3002\u63a8\u8350\u9605\u8bfb\u4e0b\u9762\u7684\u6587\u7ae0\uff1a Formal Languages, Grammars, and Automata \u5165\u95e8\u4e86\u4e4b\u540e\uff0c\u5c31\u9700\u8981\u5efa\u7acb\u8d77theory framework\uff0c\u6700\u7ec8\u6211\u4eec\u4f1a\u53d1\u73b0\uff0c\u4f7f\u7528 Chomsky hierarchy \u5c31\u80fd\u591f\u5c06\u6574\u4e2a\u7406\u8bba\u7ed9\u7edf\u4e00\u8d77\u6765\uff1b\u7136\u540e\u518d\u9010\u4e2a\u8fdb\u884c\u7ec6\u81f4\u5206\u6790\uff0c\u6700\u540e\u5c31\u80fd\u591f\u878d\u4f1a\u8d2f\u901a\uff0c\u8fd9\u5176\u5b9e\u5c31\u662f\u7cbe\u901a\u4e86\u3002 Formal language \u63d0\u53ca formal language \uff0c\u5c31\u5f97\u8bf7\u51fa Noam Chomsky \uff0c\u56e0\u4e3a\u4e0b\u9762\u7684\u7406\u8bba\u6846\u67b6\u662f\u7531\u4ed6\u6240\u5efa\u7acb\u7684\uff0c\u8be5theory framework\u7684\u662f\u6309\u7167 Chomsky hierarchy \u6765\u8fdb\u884c\u7ec4\u7ec7\u7684\uff1a Chomsky hierarchy Grammars Languages Abstract machines Type-0 Unrestricted Recursively enumerable Turing machine \u2014 (no common name) Decidable Decider Type-1 Context-sensitive Context-sensitive Linear-bounded \u2014 Positive range concatenation Positive range concatenation * PTIME Turing Machine \u2014 Indexed Indexed * Nested stack \u2014 \u2014 \u2014 Thread automaton \u2014 Linear context-free rewriting systems Linear context-free rewriting language restricted Tree stack automaton \u2014 Tree-adjoining Tree-adjoining Embedded pushdown Type-2 Context-free Context-free Nondeterministic pushdown \u2014 Deterministic context-free Deterministic context-free Deterministic pushdown \u2014 Visibly pushdown Visibly pushdown Visibly pushdown Type-3 Regular Regular Finite \u2014 \u2014 Star-free Counter-free (with aperiodic finite monoid) \u2014 Non-recursive Finite Acyclic finite Each category of languages, except those marked by a * , is a proper subset of the category directly above it. Any language in each category is generated by a grammar and by an automaton in the category in the same line. Expressive power Type-3->Type-2->Type-1->Type-0 Linear structure->hierarchy structure->graph->... relation\u8d8a\u6765\u8d8a\u590d\u6742\uff0cstructure\u8d8a\u6765\u8d8a\u590d\u6742\uff1b Expressive power\u9010\u6e10\u589e\u5f3a\uff1b \u5165\u95e8\u8bfb\u7269 \u5165\u95e8\u8bfb\u7269\u63a8\u8350\uff1a Formal Languages, Grammars, and Automata \u9664\u6b64\u4e4b\u5916\uff0c\u63a8\u8350\u9605\u8bfb\u5982\u4e0b\u5de8\u8457\uff1a Introduction to Automata and Language Theory(aka Cinderella Book ) Cinderella Book VS Dragon Book Introduction to Automata and Language Theory(aka Cinderella Book ) \u662f\u8be5\u9886\u57df\u7684\u7ecf\u5178\u4e66\u7c4d\u3002 Introduction to Automata and Language Theory(aka Cinderella Book ) \u548c Compilers: Principles, Techniques, and Tools (aka \" Dragon Book \") \u4e2d\u7684\u5185\u5bb9\u5176\u5b9e\u662f\u7d27\u5bc6\u5173\u8054\u7684\uff0c\u8fd9\u4e0d\u4ec5\u4ec5\u662f\u56e0\u4e3aJeffrey D.Ullman\u53c2\u4e0e\u4e86\u8fd9\u4e24\u672c\u4e66\u7684\u7f16\u5199\uff0c\u800c\u662f\u56e0\u4e3aprogramming language\u662f\u4e00\u79cdformal language\uff0c\u800cCinderella Book\u548cDragon Book\u5176\u5b9e\u90fd\u662f\u5728\u8bb2\u8ff0\u548cformal language\u76f8\u5173\u7684\u5185\u5bb9\uff0c\u5f53\u7136\uff0c\u8fd9\u4e9b\u5185\u5bb9\u4ec5\u4ec5\u4e66\u4e2d\u7684\u4e00\u90e8\u5206\u3002Cinderella Book\u4e13\u6ce8\u4e8e\u8bb2\u8ff0automata and language theory\uff0c\u800cdragon book\u7684\u5185\u5bb9\u5219\u53ef\u4ee5\u5206\u4e3a\u4e24\u4e2a\u90e8\u5206front end\u548cback end\uff0c\u663e\u7136front end\u6240\u8bb2\u8ff0\u7684\u5185\u5bb9\u5c31\u548cautomata and language theory\u7d27\u5bc6\u76f8\u5173\u4e86\u3002 \u53c2\u8003 \u672c\u9879\u76ee\u7684\u5185\u5bb9\u5927\u591a\u6570\u6765\u81ea: \u7ef4\u57fa\u767e\u79d1: Automata theory : formal languages and formal grammars Introduction to Automata and Language Theory(aka Cinderella Book )","title":"Introduction"},{"location":"Formal-language/#_1","text":"\u672c\u7ae0\u8282\uff0c\u9996\u5148\u63cf\u8ff0\u4e0a\u9762\u662f\"formal\"\uff0c\u5f15\u51fa Formal language \uff0c \u7136\u540e\u5bf9\u5b83\u8fdb\u884c\u8be6\u7ec6\u7684\u5206\u6790\u3002\u7ef4\u57fa\u767e\u79d1\u7684 Formal language \u5185\u5bb9\u662f\u975e\u5e38\u597d\u7684\uff08\u5168\u9762\uff0c\u6df1\u5165\u6d45\u51fa\uff09\uff0c\u9700\u8981\u4ed4\u7ec6\u9605\u8bfb\u3002 \u9996\u5148\u8bf4\u660eformal language\uff0cformal grammar\uff0cautomata\uff0cChomsky hierarchy\u7b49\u57fa\u672c\u6982\u5ff5\uff0c\u5efa\u7acb\u7406\u8bba\u6846\u67b6\u3002 \u7136\u540e\u6309\u7167Chomsky hierarchy\u7684\u6bcf\u4e00\u5c42\u8fdb\u884c\u8bf4\u660e\uff0c\u5bf9Chomsky hierarchy\u7684\u6bcf\u4e00\u5c42\u7684\u8bf4\u660e\u91c7\u7528\u5982\u4e0b\u987a\u5e8f\uff0c\u5373\uff1a Type-3 grammars: Regular grammar Type-2 grammars: Context-free grammar Type-1 grammars: Context-sensitive grammar Type-0 grammars: Unrestricted grammar \u8fd9\u662f\u56e0\u4e3a\u4eceType-3 grammars\u5230Type-0 grammars\uff0cgrammar\u8d8a\u6765\u8d8a\u62bd\u8c61\uff0c\u8d8a\u6765\u8d8a\u96be\u7406\u89e3\uff0c\u8fd9\u6837\u7531\u6613\u5230\u96be\u4f1a\u6bd4\u8f83\u7b26\u5408\u8ba4\u77e5\u89c4\u5f8b\u3002 \u5728\u4e86\u89e3\u4e86\u8fd9\u4e9b\u4e4b\u540e\uff0c\u6211\u4eec\u4e0d\u80fd\u591f\u4ec5\u4ec5\u5c40\u9650\u4e8e\u6b64\uff0c\u800c\u662f\u5e94\u8be5\u8d70\u5411\u66f4\u52a0\u5bbd\u5e7f\u7684\u7406\u8bba\uff1a Theory of computation \uff0c\u56e0\u4e3a\u6309\u71672012 ACM Computing Classification System \uff0c\u524d\u9762\u6240\u8ba8\u8bba\u7684 formal language \uff0c automata theory \u90fd\u5c5e\u4e8e\u6b64\u8303\u8f74\u3002 \u7406\u8bba\u5f80\u5f80\u4e0d\u662f\u5b64\u7acb\u7684\uff0c\u800c\u662f\u76f8\u4e92\u5173\u8054\uff0c\u76f8\u4e92\u501f\u7528\u7684\uff0c\u76f8\u4e92\u542f\u53d1\u7684\uff0c\u5728\u9605\u8bfb Formal language \u65f6\uff0c\u4f60\u4f1a\u53d1\u73b0\u4f5c\u8005\u5bf9\u5b83\u8fdb\u884c\u4e86\u5927\u91cf\u7684\u53d1\u6563\uff0c\u6d89\u53ca\u5230\u7684\u5b66\u79d1\u6709 mathematics \uff08\u5c24\u5176\u662f Mathematical logic \uff09, computer science , and linguistics \u3002\u6240\u4ee5\uff0c\u5728\u9605\u8bfb\u7684\u65f6\u5019\uff0c\u5c31\u6709\u5fc5\u8981\u68b3\u7406\u6e05\u695a\u6982\u5ff5\u4e4b\u95f4\u7684\u5173\u7cfb\uff0c\u6293\u4f4f\u95ee\u9898\u7684\u672c\u8d28\uff0c\u800c\u4e0d\u662f\u88ab\u8868\u9762\u7684\u63cf\u8ff0\u8bc6\u6240\u6270\u4e71\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Formal-language/#--","text":"Formal language \u6240\u6d89\u53ca\u7684\u7406\u8bba\u8f83\u591a\uff0c\u5e76\u4e14\u5927\u591a\u6570\u90fd\u662f\u6bd4\u8f83\u62bd\u8c61\u7684\uff0c\u521a\u5f00\u59cb\u5b66\u4e60\uff08\u5c24\u5176\u5bf9\u4e8e\u7f3a\u4e4f\u4f7f\u7528programming language\u7684\u4eba\u6765\u8bf4\uff09\u53ef\u80fd\u4f1a\u611f\u89c9\u6bd4\u8f83\u5403\u529b\uff0c\u4ee5\u4e0b\u662f\u89c9\u5f97\u6bd4\u8f83\u597d\u7684\u5b66\u4e60\u8ba1\u5212\uff1a \u9996\u5148\u641e\u6e05\u695awhat is language\u3001what is formal language\u3001what is formal grammar\u3001what is automata\u3001What is the relationship between them\uff0c\u8fd9\u6837\u5c31\u5efa\u7acb\u8d77\u4e86\u5efa\u7acb\u8d77\u9ad8\u5c4b\u5efa\u74f4\u7684\u89c6\u91ce\uff0c\u8fd9\u5176\u5b9e\u5c31\u662f\u7b97\u5165\u95e8\u4e86\u3002\u63a8\u8350\u9605\u8bfb\u4e0b\u9762\u7684\u6587\u7ae0\uff1a Formal Languages, Grammars, and Automata \u5165\u95e8\u4e86\u4e4b\u540e\uff0c\u5c31\u9700\u8981\u5efa\u7acb\u8d77theory framework\uff0c\u6700\u7ec8\u6211\u4eec\u4f1a\u53d1\u73b0\uff0c\u4f7f\u7528 Chomsky hierarchy \u5c31\u80fd\u591f\u5c06\u6574\u4e2a\u7406\u8bba\u7ed9\u7edf\u4e00\u8d77\u6765\uff1b\u7136\u540e\u518d\u9010\u4e2a\u8fdb\u884c\u7ec6\u81f4\u5206\u6790\uff0c\u6700\u540e\u5c31\u80fd\u591f\u878d\u4f1a\u8d2f\u901a\uff0c\u8fd9\u5176\u5b9e\u5c31\u662f\u7cbe\u901a\u4e86\u3002","title":"\u5b66\u4e60\u8ba1\u5212--\u4ece\u5165\u95e8\u5230\u7cbe\u901a"},{"location":"Formal-language/#formal#language","text":"\u63d0\u53ca formal language \uff0c\u5c31\u5f97\u8bf7\u51fa Noam Chomsky \uff0c\u56e0\u4e3a\u4e0b\u9762\u7684\u7406\u8bba\u6846\u67b6\u662f\u7531\u4ed6\u6240\u5efa\u7acb\u7684\uff0c\u8be5theory framework\u7684\u662f\u6309\u7167 Chomsky hierarchy \u6765\u8fdb\u884c\u7ec4\u7ec7\u7684\uff1a Chomsky hierarchy Grammars Languages Abstract machines Type-0 Unrestricted Recursively enumerable Turing machine \u2014 (no common name) Decidable Decider Type-1 Context-sensitive Context-sensitive Linear-bounded \u2014 Positive range concatenation Positive range concatenation * PTIME Turing Machine \u2014 Indexed Indexed * Nested stack \u2014 \u2014 \u2014 Thread automaton \u2014 Linear context-free rewriting systems Linear context-free rewriting language restricted Tree stack automaton \u2014 Tree-adjoining Tree-adjoining Embedded pushdown Type-2 Context-free Context-free Nondeterministic pushdown \u2014 Deterministic context-free Deterministic context-free Deterministic pushdown \u2014 Visibly pushdown Visibly pushdown Visibly pushdown Type-3 Regular Regular Finite \u2014 \u2014 Star-free Counter-free (with aperiodic finite monoid) \u2014 Non-recursive Finite Acyclic finite Each category of languages, except those marked by a * , is a proper subset of the category directly above it. Any language in each category is generated by a grammar and by an automaton in the category in the same line.","title":"Formal language"},{"location":"Formal-language/#expressive#power","text":"Type-3->Type-2->Type-1->Type-0 Linear structure->hierarchy structure->graph->... relation\u8d8a\u6765\u8d8a\u590d\u6742\uff0cstructure\u8d8a\u6765\u8d8a\u590d\u6742\uff1b Expressive power\u9010\u6e10\u589e\u5f3a\uff1b","title":"Expressive power"},{"location":"Formal-language/#_2","text":"\u5165\u95e8\u8bfb\u7269\u63a8\u8350\uff1a Formal Languages, Grammars, and Automata \u9664\u6b64\u4e4b\u5916\uff0c\u63a8\u8350\u9605\u8bfb\u5982\u4e0b\u5de8\u8457\uff1a Introduction to Automata and Language Theory(aka Cinderella Book )","title":"\u5165\u95e8\u8bfb\u7269"},{"location":"Formal-language/#cinderella#book#vs#dragon#book","text":"Introduction to Automata and Language Theory(aka Cinderella Book ) \u662f\u8be5\u9886\u57df\u7684\u7ecf\u5178\u4e66\u7c4d\u3002 Introduction to Automata and Language Theory(aka Cinderella Book ) \u548c Compilers: Principles, Techniques, and Tools (aka \" Dragon Book \") \u4e2d\u7684\u5185\u5bb9\u5176\u5b9e\u662f\u7d27\u5bc6\u5173\u8054\u7684\uff0c\u8fd9\u4e0d\u4ec5\u4ec5\u662f\u56e0\u4e3aJeffrey D.Ullman\u53c2\u4e0e\u4e86\u8fd9\u4e24\u672c\u4e66\u7684\u7f16\u5199\uff0c\u800c\u662f\u56e0\u4e3aprogramming language\u662f\u4e00\u79cdformal language\uff0c\u800cCinderella Book\u548cDragon Book\u5176\u5b9e\u90fd\u662f\u5728\u8bb2\u8ff0\u548cformal language\u76f8\u5173\u7684\u5185\u5bb9\uff0c\u5f53\u7136\uff0c\u8fd9\u4e9b\u5185\u5bb9\u4ec5\u4ec5\u4e66\u4e2d\u7684\u4e00\u90e8\u5206\u3002Cinderella Book\u4e13\u6ce8\u4e8e\u8bb2\u8ff0automata and language theory\uff0c\u800cdragon book\u7684\u5185\u5bb9\u5219\u53ef\u4ee5\u5206\u4e3a\u4e24\u4e2a\u90e8\u5206front end\u548cback end\uff0c\u663e\u7136front end\u6240\u8bb2\u8ff0\u7684\u5185\u5bb9\u5c31\u548cautomata and language theory\u7d27\u5bc6\u76f8\u5173\u4e86\u3002","title":"Cinderella Book VS Dragon Book"},{"location":"Formal-language/#_3","text":"\u672c\u9879\u76ee\u7684\u5185\u5bb9\u5927\u591a\u6570\u6765\u81ea: \u7ef4\u57fa\u767e\u79d1: Automata theory : formal languages and formal grammars Introduction to Automata and Language Theory(aka Cinderella Book )","title":"\u53c2\u8003"},{"location":"Formal-language/Formal-and-formal-langugae/","text":"Formal and formal language Formal\u5728computer science\u4e2d\u6709\u7740\u975e\u5e38\u91cd\u8981\u7684\u5730\u4f4d\uff0c\u8ba1\u7b97\u673a\u79d1\u5b66\u5bb6\u95e8\u56f4\u7ed5\u7740\u5b83\u521b\u5efa\u4e86\u5f88\u591a\u7406\u8bba\u3002 Formal \u6240\u4ee5\u6211\u4eec\u9700\u8981\u9996\u5148\u641e\u6e05\u695a\u5b83\u7684\u542b\u4e49\u3002\u4e0b\u9762\u6211\u4eec\u5148\u901a\u8fc7\u4e00\u4e9b\u4f8b\u5b50\u6765\u8ba4\u8bc6formal\uff0c\u7136\u540e\u518d\u6765\u8fdb\u884c\u603b\u7ed3\u3002 Examples of formal example 1 Deep Learning \u7684Chapter 1 Introduction\u7684\u5982\u4e0b\u63cf\u8ff0\uff1a In the early days of artificial intelligence, the field rapidly tackled and solved problems that are intellectually difficult for human beings but relatively straightforward for computers\u2014problems that can be described by a list of formal , mathematical rules. The true challenge to artificial intelligence proved to be solving the tasks that are easy for people to perform but hard for people to describe formally \u2014problems that we solve intuitively , that feel automatic, like recognizing spoken words or faces in images. \u53ef\u4ee5\u4f7f\u7528\u201cformal\uff0c mathematical rules\u201c\u63cf\u8ff0\u7684\u95ee\u9898\uff0c\u5177\u5907\u7740\u56fa\u5b9a\u7684rule\uff0c\u6240\u4ee5\u4f7f\u7528computer program\u662f\u975e\u5e38\u4efb\u610f\u5b9e\u73b0\u7684\u3002\u800c\u4e0e\u5b83\u76f8\u53cd\u7684\u4e00\u7c7b\u95ee\u9898\uff0c\u662f\u65e0\u6cd5\u4f7f\u7528rule\u8fdb\u884c\u63cf\u8ff0\u7684\uff0c\u8fd9\u7c7b\u95ee\u9898\uff0c\u5728\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u4f7f\u7528\u201dintuitive\u201c\u6765\u8868\u793a\uff0c\u89e3\u51b3\u8fd9\u7c7b\u95ee\u9898\u7684\u65b9\u6cd5\u662fAI\u3002 example 2 Deep Learning \u7684Chapter 5.1 Learning Algorithms\u7684\u5982\u4e0b\u63cf\u8ff0\uff1a \u201cA computer program is said to learn from experience E with respect to some class of tasks T and performance measure P , if its performance at tasks in T , as measured by P , improves with experience E .\u201d One can imagine a very wide variety of experiences E , tasks T , and performance measures P , and we do not make any attempt in this book to provide a formal definition of what may be used for each of these entities. Instead, the following sections provide intuitive descriptions and examples of the different kinds of tasks, performance measures and experiences that can be used to construct machine learning algorithms. formal language-\u300b formal definition natural language-\u300bintuitive description examples Examples of formal description https://dictionary.cambridge.org/example/english/formal-description In this section and the next, we turn our attention to providing a more formal description of the underlying type system. \u4ec0\u4e48\u662fformal\uff1f \u5173\u4e8eformal\u7684\u76f4\u89c9\u662f\uff1a \u6709\u56fa\u5b9a\u7684\u89c4\u5219 \u4ece\u8bcd\u6e90\u8bf4\u8d77 https://simple.wikipedia.org/wiki/Formal Formal is a word used to describe anything that has form or structure . So it is something which is used or done in accordance with rules or ceremonies . \u4e0a\u9762\u8fd9\u53e5\u4e2d\u7684form\u5176\u5b9e\u5c31\u53ef\u4ee5\u7406\u89e3\u4e3arule\u3002 In mathematics , formal logic is a way of thinking about mathematics questions using strict rules. https://www.yourdictionary.com/formal \u7ef4\u57fa\u767e\u79d1formal\u6c47\u603b \u6211\u4eec\u9700\u8981\u91cd\u70b9\u5173\u6ce8\u4e09\u4e2a\u79d1\u5b66\u5b66\u79d1\uff1a Linguistics \u3001 Logic and mathematics \u3001 Computer science \u8fd9\u4e09\u4e2a\u5b66\u79d1\u4e2d\u7684formal\u662f\u5bc6\u5207\u76f8\u5173\u7684\u3002 Formalism \u6587\u7ae0 Formalism (philosophy) , Formalism (philosophy of mathematics) \u5c06formal\u63cf\u8ff0\u4e3a\u4e00\u79cd\u79d1\u5b66\u7684\u601d\u60f3\uff0c\u663e\u7136\u5b83\u4ece\u66f4\u9ad8\u7684\u54f2\u5b66\u7684\u89d2\u5ea6\u6765\u6982\u62ecformal\uff0c\u6211\u89c9\u5f97\u4ee5\u5b83\u4f5c\u4e3a\u638c\u63e1formal\u7684\u5165\u53e3\u662f\u975e\u5e38\u597d\u7684\uff0c\u56e0\u4e3a\u79d1\u5b66\u603b\u6570\u9075\u5faa\u76f8\u540c\u7684\u54f2\u5b66\u601d\u60f3\uff0c\u6216\u8005\u8bf4\u54f2\u5b66\u6307\u5bfc\u7740\u79d1\u5b66\u3002 Formal language \u663e\u7136\uff0c\u8fd9\u4e2a\u8bcd\u7531formal\u6765\u8fdb\u884c\u4fee\u9970\uff0c\u6240\u4ee5\u5b83\u80af\u5b9a\u662f\u5177\u5907\u524d\u9762\u6240\u63cf\u8ff0\u7684formal\u7684\u6027\u8d28\u7684\uff1a\u5373\u6709\u56fa\u5b9a\u89c4\u5219\uff0c\u5c31 formal language \u800c\u8a00\uff0c\u5b83\u7684formal\u662f\u6e90\u4e8e\u5b83\u7684 grammar \u4e0a\uff0c\u5b83\u7684\u8bed\u6cd5\u662f formal grammar \uff0c\u8fd9\u79cd\u8bed\u6cd5\u7684\u89c4\u5219\u662f\u56fa\u5b9a\u7684\u3002\u6240\u4ee5\u5bf9\u4e8e\u8fd9\u79cd\u8bed\u8a00\uff0c\u53ea\u8981\u5411computer\u63cf\u8ff0\u6e05\u695a\u5b83\u7684grammar\uff0c\u90a3\u4e48computer\u5c31\u53ef\u4ee5\u201c\u8bfb\u61c2\u201d\u5b83\uff0c\u5373\u8fd9\u79cd\u8bed\u8a00\u662fmachine-readable\u7684\u3002 \u5173\u4e8eformal language\u7684machine readable\uff0c\u53ef\u4ee5\u53c2\u89c1\uff1a https://en.wikipedia.org/wiki/Semantic_Web Formal definition \u4f7f\u7528formal language\u6765\u63cf\u8ff0\u7684definition\u5c31\u662fformal definition\u3002 Formal language\u7684\u4f18\u52bf Formal language\u7684\u4f18\u52bf\u5728\u4e8e\u5b83\u7684formal\uff0c\u5373\u6709\u56fa\u5b9a\u7684rule\u3002\u5728\u903b\u8f91\u5b66\uff0crule\u5bf9\u4e8e\u7684\u662f\u63a8\u5bfc\u89c4\u5219\uff0c\u6240\u4ee5formal language\u662f\u53ef\u4ee5\u8fdb\u884c\u63a8\u5bfc\u3002 \u601d\u8003\uff1aFormal\u4e0e\u4eba\u5de5\u667a\u80fd deep learning book\u7684chapter one","title":"Introduction"},{"location":"Formal-language/Formal-and-formal-langugae/#formal#and#formal#language","text":"Formal\u5728computer science\u4e2d\u6709\u7740\u975e\u5e38\u91cd\u8981\u7684\u5730\u4f4d\uff0c\u8ba1\u7b97\u673a\u79d1\u5b66\u5bb6\u95e8\u56f4\u7ed5\u7740\u5b83\u521b\u5efa\u4e86\u5f88\u591a\u7406\u8bba\u3002","title":"Formal and formal language"},{"location":"Formal-language/Formal-and-formal-langugae/#formal","text":"\u6240\u4ee5\u6211\u4eec\u9700\u8981\u9996\u5148\u641e\u6e05\u695a\u5b83\u7684\u542b\u4e49\u3002\u4e0b\u9762\u6211\u4eec\u5148\u901a\u8fc7\u4e00\u4e9b\u4f8b\u5b50\u6765\u8ba4\u8bc6formal\uff0c\u7136\u540e\u518d\u6765\u8fdb\u884c\u603b\u7ed3\u3002","title":"Formal"},{"location":"Formal-language/Formal-and-formal-langugae/#examples#of#formal","text":"","title":"Examples of formal"},{"location":"Formal-language/Formal-and-formal-langugae/#example#1","text":"Deep Learning \u7684Chapter 1 Introduction\u7684\u5982\u4e0b\u63cf\u8ff0\uff1a In the early days of artificial intelligence, the field rapidly tackled and solved problems that are intellectually difficult for human beings but relatively straightforward for computers\u2014problems that can be described by a list of formal , mathematical rules. The true challenge to artificial intelligence proved to be solving the tasks that are easy for people to perform but hard for people to describe formally \u2014problems that we solve intuitively , that feel automatic, like recognizing spoken words or faces in images. \u53ef\u4ee5\u4f7f\u7528\u201cformal\uff0c mathematical rules\u201c\u63cf\u8ff0\u7684\u95ee\u9898\uff0c\u5177\u5907\u7740\u56fa\u5b9a\u7684rule\uff0c\u6240\u4ee5\u4f7f\u7528computer program\u662f\u975e\u5e38\u4efb\u610f\u5b9e\u73b0\u7684\u3002\u800c\u4e0e\u5b83\u76f8\u53cd\u7684\u4e00\u7c7b\u95ee\u9898\uff0c\u662f\u65e0\u6cd5\u4f7f\u7528rule\u8fdb\u884c\u63cf\u8ff0\u7684\uff0c\u8fd9\u7c7b\u95ee\u9898\uff0c\u5728\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u4f7f\u7528\u201dintuitive\u201c\u6765\u8868\u793a\uff0c\u89e3\u51b3\u8fd9\u7c7b\u95ee\u9898\u7684\u65b9\u6cd5\u662fAI\u3002","title":"example 1"},{"location":"Formal-language/Formal-and-formal-langugae/#example#2","text":"Deep Learning \u7684Chapter 5.1 Learning Algorithms\u7684\u5982\u4e0b\u63cf\u8ff0\uff1a \u201cA computer program is said to learn from experience E with respect to some class of tasks T and performance measure P , if its performance at tasks in T , as measured by P , improves with experience E .\u201d One can imagine a very wide variety of experiences E , tasks T , and performance measures P , and we do not make any attempt in this book to provide a formal definition of what may be used for each of these entities. Instead, the following sections provide intuitive descriptions and examples of the different kinds of tasks, performance measures and experiences that can be used to construct machine learning algorithms. formal language-\u300b formal definition natural language-\u300bintuitive description","title":"example 2"},{"location":"Formal-language/Formal-and-formal-langugae/#examples","text":"Examples of formal description https://dictionary.cambridge.org/example/english/formal-description In this section and the next, we turn our attention to providing a more formal description of the underlying type system.","title":"examples"},{"location":"Formal-language/Formal-and-formal-langugae/#formal_1","text":"\u5173\u4e8eformal\u7684\u76f4\u89c9\u662f\uff1a \u6709\u56fa\u5b9a\u7684\u89c4\u5219","title":"\u4ec0\u4e48\u662fformal\uff1f"},{"location":"Formal-language/Formal-and-formal-langugae/#_1","text":"https://simple.wikipedia.org/wiki/Formal Formal is a word used to describe anything that has form or structure . So it is something which is used or done in accordance with rules or ceremonies . \u4e0a\u9762\u8fd9\u53e5\u4e2d\u7684form\u5176\u5b9e\u5c31\u53ef\u4ee5\u7406\u89e3\u4e3arule\u3002 In mathematics , formal logic is a way of thinking about mathematics questions using strict rules. https://www.yourdictionary.com/formal","title":"\u4ece\u8bcd\u6e90\u8bf4\u8d77"},{"location":"Formal-language/Formal-and-formal-langugae/#formal_2","text":"\u6211\u4eec\u9700\u8981\u91cd\u70b9\u5173\u6ce8\u4e09\u4e2a\u79d1\u5b66\u5b66\u79d1\uff1a Linguistics \u3001 Logic and mathematics \u3001 Computer science \u8fd9\u4e09\u4e2a\u5b66\u79d1\u4e2d\u7684formal\u662f\u5bc6\u5207\u76f8\u5173\u7684\u3002","title":"\u7ef4\u57fa\u767e\u79d1formal\u6c47\u603b"},{"location":"Formal-language/Formal-and-formal-langugae/#formalism","text":"\u6587\u7ae0 Formalism (philosophy) , Formalism (philosophy of mathematics) \u5c06formal\u63cf\u8ff0\u4e3a\u4e00\u79cd\u79d1\u5b66\u7684\u601d\u60f3\uff0c\u663e\u7136\u5b83\u4ece\u66f4\u9ad8\u7684\u54f2\u5b66\u7684\u89d2\u5ea6\u6765\u6982\u62ecformal\uff0c\u6211\u89c9\u5f97\u4ee5\u5b83\u4f5c\u4e3a\u638c\u63e1formal\u7684\u5165\u53e3\u662f\u975e\u5e38\u597d\u7684\uff0c\u56e0\u4e3a\u79d1\u5b66\u603b\u6570\u9075\u5faa\u76f8\u540c\u7684\u54f2\u5b66\u601d\u60f3\uff0c\u6216\u8005\u8bf4\u54f2\u5b66\u6307\u5bfc\u7740\u79d1\u5b66\u3002","title":"Formalism"},{"location":"Formal-language/Formal-and-formal-langugae/#formal#language","text":"\u663e\u7136\uff0c\u8fd9\u4e2a\u8bcd\u7531formal\u6765\u8fdb\u884c\u4fee\u9970\uff0c\u6240\u4ee5\u5b83\u80af\u5b9a\u662f\u5177\u5907\u524d\u9762\u6240\u63cf\u8ff0\u7684formal\u7684\u6027\u8d28\u7684\uff1a\u5373\u6709\u56fa\u5b9a\u89c4\u5219\uff0c\u5c31 formal language \u800c\u8a00\uff0c\u5b83\u7684formal\u662f\u6e90\u4e8e\u5b83\u7684 grammar \u4e0a\uff0c\u5b83\u7684\u8bed\u6cd5\u662f formal grammar \uff0c\u8fd9\u79cd\u8bed\u6cd5\u7684\u89c4\u5219\u662f\u56fa\u5b9a\u7684\u3002\u6240\u4ee5\u5bf9\u4e8e\u8fd9\u79cd\u8bed\u8a00\uff0c\u53ea\u8981\u5411computer\u63cf\u8ff0\u6e05\u695a\u5b83\u7684grammar\uff0c\u90a3\u4e48computer\u5c31\u53ef\u4ee5\u201c\u8bfb\u61c2\u201d\u5b83\uff0c\u5373\u8fd9\u79cd\u8bed\u8a00\u662fmachine-readable\u7684\u3002 \u5173\u4e8eformal language\u7684machine readable\uff0c\u53ef\u4ee5\u53c2\u89c1\uff1a https://en.wikipedia.org/wiki/Semantic_Web","title":"Formal language"},{"location":"Formal-language/Formal-and-formal-langugae/#formal#definition","text":"\u4f7f\u7528formal language\u6765\u63cf\u8ff0\u7684definition\u5c31\u662fformal definition\u3002","title":"Formal definition"},{"location":"Formal-language/Formal-and-formal-langugae/#formal#language_1","text":"Formal language\u7684\u4f18\u52bf\u5728\u4e8e\u5b83\u7684formal\uff0c\u5373\u6709\u56fa\u5b9a\u7684rule\u3002\u5728\u903b\u8f91\u5b66\uff0crule\u5bf9\u4e8e\u7684\u662f\u63a8\u5bfc\u89c4\u5219\uff0c\u6240\u4ee5formal language\u662f\u53ef\u4ee5\u8fdb\u884c\u63a8\u5bfc\u3002","title":"Formal language\u7684\u4f18\u52bf"},{"location":"Formal-language/Formal-and-formal-langugae/#formal_3","text":"deep learning book\u7684chapter one","title":"\u601d\u8003\uff1aFormal\u4e0e\u4eba\u5de5\u667a\u80fd"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/wikipedia-Chomsky-hierarchy/","text":"wikipedia Chomsky hierarchy In the formal languages of computer science and linguistics , the Chomsky hierarchy (occasionally referred to as the Chomsky\u2013Sch\u00fctzenberger hierarchy ) is a containment hierarchy of classes of formal grammars . This hierarchy of grammars was described by Noam Chomsky in 1956. It is also named after Marcel-Paul Sch\u00fctzenberger , who played a crucial role in the development of the theory of formal languages . The hierarchy The following table summarizes each of Chomsky's four types of grammars, the class of language it generates, the type of automaton that recognizes it, and the form its rules must have. Grammar Languages Automaton Production rules (constraints)* Examples Type-0 Recursively enumerable Turing machine $ \\alpha A\\beta \\rightarrow \\delta $ (no constraints) $ L={w Type-1 Context-sensitive Linear-bounded non-deterministic Turing machine $ \\alpha A\\beta \\rightarrow \\alpha \\gamma \\beta $ $ L={a {n}b {n}c^{n} Type-2 Context-free Non-deterministic pushdown automaton $ A\\rightarrow \\alpha $ $ L={a {n}b {n} Type-3 Regular Finite state automaton $ A\\rightarrow {\\text{a}} $ and $ A\\rightarrow {\\text{a}}B $ $ L={a^{n} Meaning of symbols: $ {\\text{a}} $ = terminal $ A $, $ B $ = non-terminal $ \\alpha $, $ \\beta $, $ \\gamma $, $ \\delta $ = string of terminals and/or non-terminals $ \\alpha $, $ \\beta $, $ \\delta $ = maybe empty $ \\gamma $ = never empty Set inclusions described by the Chomsky hierarchy Note that the set of grammars corresponding to recursive languages is not a member of this hierarchy; these would be properly between Type-0 and Type-1. Every regular language is context-free, every context-free language is context-sensitive, every context-sensitive language is recursive and every recursive language is recursively enumerable . These are all proper inclusions , meaning that there exist recursively enumerable languages that are not context-sensitive, context-sensitive languages that are not context-free and context-free languages that are not regular. Type-0 grammars Main article: Unrestricted grammar Type-0 grammars include all formal grammars. They generate exactly all languages that can be recognized by a Turing machine . These languages are also known as the recursively enumerable or Turing-recognizable languages. Note that this is different from the recursive languages , which can be decided by an always-halting Turing machine . Type-1 grammars Main article: Context-sensitive grammar Type-1 grammars generate context-sensitive languages . These grammars have rules of the form $ \\alpha A\\beta \\rightarrow \\alpha \\gamma \\beta $ with $ A $ a nonterminal and $ \\alpha $, $ \\beta $ and $ \\gamma $ strings of terminals and/or nonterminals. The strings $ \\alpha $ and $ \\beta $ may be empty, but $ \\gamma $ must be nonempty. The rule $ S\\rightarrow \\epsilon $ is allowed if $ S $ does not appear on the right side of any rule. The languages described by these grammars are exactly all languages that can be recognized by a linear bounded automaton (a nondeterministic Turing machine whose tape is bounded by a constant times the length of the input.) Type-2 grammars Main article: Context-free grammar Type-2 grammars generate the context-free languages . These are defined by rules of the form $ A\\rightarrow \\alpha $ with $ A $ being a nonterminal and $ \\alpha $ being a string of terminals and/or nonterminals. These languages are exactly all languages that can be recognized by a non-deterministic pushdown automaton . Context-free languages\u2014or rather its subset of deterministic context-free language \u2014are the theoretical basis for the phrase structure of most programming languages , though their syntax also includes context-sensitive name resolution due to declarations and scope . Often a subset of grammars is used to make parsing easier, such as by an LL parser . Type-3 grammars Main article: Regular grammar Type-3 grammars generate the regular languages . Such a grammar restricts its rules to a single nonterminal on the left-hand side and a right-hand side consisting of a single terminal, possibly followed by a single nonterminal (right regular). Alternatively, the right-hand side of the grammar can consist of a single terminal, possibly preceded by a single nonterminal (left regular). These generate the same languages. However, if left-regular rules and right-regular rules are combined, the language need no longer be regular. The rule $ S\\rightarrow \\epsilon $ is also allowed here if $ S $ does not appear on the right side of any rule. These languages are exactly all languages that can be decided by a finite state automaton . Additionally, this family of formal languages can be obtained by regular expressions . Regular languages are commonly used to define search patterns and the lexical structure of programming languages.","title":"Chomsky-hierarchy"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/wikipedia-Chomsky-hierarchy/#wikipedia#chomsky#hierarchy","text":"In the formal languages of computer science and linguistics , the Chomsky hierarchy (occasionally referred to as the Chomsky\u2013Sch\u00fctzenberger hierarchy ) is a containment hierarchy of classes of formal grammars . This hierarchy of grammars was described by Noam Chomsky in 1956. It is also named after Marcel-Paul Sch\u00fctzenberger , who played a crucial role in the development of the theory of formal languages .","title":"wikipedia Chomsky hierarchy"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/wikipedia-Chomsky-hierarchy/#the#hierarchy","text":"The following table summarizes each of Chomsky's four types of grammars, the class of language it generates, the type of automaton that recognizes it, and the form its rules must have. Grammar Languages Automaton Production rules (constraints)* Examples Type-0 Recursively enumerable Turing machine $ \\alpha A\\beta \\rightarrow \\delta $ (no constraints) $ L={w Type-1 Context-sensitive Linear-bounded non-deterministic Turing machine $ \\alpha A\\beta \\rightarrow \\alpha \\gamma \\beta $ $ L={a {n}b {n}c^{n} Type-2 Context-free Non-deterministic pushdown automaton $ A\\rightarrow \\alpha $ $ L={a {n}b {n} Type-3 Regular Finite state automaton $ A\\rightarrow {\\text{a}} $ and $ A\\rightarrow {\\text{a}}B $ $ L={a^{n} Meaning of symbols: $ {\\text{a}} $ = terminal $ A $, $ B $ = non-terminal $ \\alpha $, $ \\beta $, $ \\gamma $, $ \\delta $ = string of terminals and/or non-terminals $ \\alpha $, $ \\beta $, $ \\delta $ = maybe empty $ \\gamma $ = never empty Set inclusions described by the Chomsky hierarchy Note that the set of grammars corresponding to recursive languages is not a member of this hierarchy; these would be properly between Type-0 and Type-1. Every regular language is context-free, every context-free language is context-sensitive, every context-sensitive language is recursive and every recursive language is recursively enumerable . These are all proper inclusions , meaning that there exist recursively enumerable languages that are not context-sensitive, context-sensitive languages that are not context-free and context-free languages that are not regular.","title":"The hierarchy"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/wikipedia-Chomsky-hierarchy/#type-0#grammars","text":"Main article: Unrestricted grammar Type-0 grammars include all formal grammars. They generate exactly all languages that can be recognized by a Turing machine . These languages are also known as the recursively enumerable or Turing-recognizable languages. Note that this is different from the recursive languages , which can be decided by an always-halting Turing machine .","title":"Type-0 grammars"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/wikipedia-Chomsky-hierarchy/#type-1#grammars","text":"Main article: Context-sensitive grammar Type-1 grammars generate context-sensitive languages . These grammars have rules of the form $ \\alpha A\\beta \\rightarrow \\alpha \\gamma \\beta $ with $ A $ a nonterminal and $ \\alpha $, $ \\beta $ and $ \\gamma $ strings of terminals and/or nonterminals. The strings $ \\alpha $ and $ \\beta $ may be empty, but $ \\gamma $ must be nonempty. The rule $ S\\rightarrow \\epsilon $ is allowed if $ S $ does not appear on the right side of any rule. The languages described by these grammars are exactly all languages that can be recognized by a linear bounded automaton (a nondeterministic Turing machine whose tape is bounded by a constant times the length of the input.)","title":"Type-1 grammars"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/wikipedia-Chomsky-hierarchy/#type-2#grammars","text":"Main article: Context-free grammar Type-2 grammars generate the context-free languages . These are defined by rules of the form $ A\\rightarrow \\alpha $ with $ A $ being a nonterminal and $ \\alpha $ being a string of terminals and/or nonterminals. These languages are exactly all languages that can be recognized by a non-deterministic pushdown automaton . Context-free languages\u2014or rather its subset of deterministic context-free language \u2014are the theoretical basis for the phrase structure of most programming languages , though their syntax also includes context-sensitive name resolution due to declarations and scope . Often a subset of grammars is used to make parsing easier, such as by an LL parser .","title":"Type-2 grammars"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/wikipedia-Chomsky-hierarchy/#type-3#grammars","text":"Main article: Regular grammar Type-3 grammars generate the regular languages . Such a grammar restricts its rules to a single nonterminal on the left-hand side and a right-hand side consisting of a single terminal, possibly followed by a single nonterminal (right regular). Alternatively, the right-hand side of the grammar can consist of a single terminal, possibly preceded by a single nonterminal (left regular). These generate the same languages. However, if left-regular rules and right-regular rules are combined, the language need no longer be regular. The rule $ S\\rightarrow \\epsilon $ is also allowed here if $ S $ does not appear on the right side of any rule. These languages are exactly all languages that can be decided by a finite state automaton . Additionally, this family of formal languages can be obtained by regular expressions . Regular languages are commonly used to define search patterns and the lexical structure of programming languages.","title":"Type-3 grammars"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/","text":"\u5bf9\u6bd4\u5206\u6790 Type-0 grammars\u53c8\u53eb\u505a unrestricted grammar \uff0c\u4ece\u5b83\u7684\u540d\u5b57\u53ef\u4ee5\u770b\u51fa\uff0c\u5b83\u662funrestricted\u7684\uff0c\u5373 No restrictions are made on the productions of an unrestricted grammar \u90a3\u5176\u5b83grammar\uff08Type-1 grammars Context-sensitive grammar \u3001Type-2 grammars Context-free grammar \u3001Type-3 grammars Regular grammar \uff09\uff0c\u5bf9\u5404\u81ea\u7684production\u7684restriction\u662f\u4ec0\u4e48\u5462\uff1f\u4e0b\u9762\u4ece\u8fd9\u4e2a\u89d2\u5ea6\u5bf9\u8fd9\u51e0\u79cdgrammar\u8fdb\u884c\u5bf9\u6bd4\u5206\u6790\uff0c \u7531\u4e0a\u8ff0Chomsky hierarchy\u6240\u63cf\u8ff0\u7684\u5c42\u7ea7\u53ef\u4ee5\u770b\u51fa\uff0c\u4eceType 0 grammars\u5230Type 3 grammars\u9010\u7ea7\u589e\u52a0restriction\uff0c\u6240\u4ee5\u5728\u8fdb\u884c\u5bf9\u6bd4\u5206\u6790\u7684\u65f6\u5019\uff0c\u6bcf\u4e2agrammar\u53ea\u9700\u8981\u548c\u5b83\u7684\u5347\u4e00\u7ea7grammar\u8fdb\u884c\u5bf9\u6bd4\u5373\u53ef\u3002 Type-0 grammars: Unrestricted grammar formal definition An unrestricted grammar is a formal grammar $ G=(N,\\Sigma ,P,S) $, where $ N $ is a set of nonterminal symbols, $ \\Sigma $ is a set of terminal symbols , $ N $ and $ \\Sigma $ are disjoint, $ P $ is a set of production rules of the form $ \\alpha \\to \\beta $ where $ \\alpha $ and $ \\beta $ are strings of symbols in $ N\\cup \\Sigma $ and $ \\alpha $ is not the empty string , and $ S\\in N $ is a specially designated start symbol. As the name implies, there are no real restrictions on the types of production rules that unrestricted grammars can have. \u5bf9\u6bd4\u5206\u6790 \u548c\u5176\u4ed6\u7684grammar production\u76f8\u6bd4\uff0c\u5b83\u7684unrestriction\u4f53\u73b0\u5728\uff1a \\alpha \\alpha \u53ef\u4ee5\u4e3aterminal\u3001non-terminal \\beta \\beta \u53ef\u4ee5\u4e3aempty string Type-1 grammars: Context-sensitive grammar formal definition A formal grammar G = ( N , \u03a3, P , S ), where N is a set of nonterminal symbols, \u03a3 is a set of terminal symbols, P is a set of production rules, and S is the start symbol , is context-sensitive if all rules in P are of the form \u03b1*A*\u03b2 \u2192 \u03b1\u03b3\u03b2 where A \u2208 N , \u03b1,\u03b2 \u2208 ( N \u222a\u03a3)* and \u03b3 \u2208 ( N \u222a\u03a3)+. \u4e0a\u8ff0 * \u548c + \u90fd\u662f\u4f7f\u7528\u7684\u6b63\u5219\u8868\u8fbe\u5f0f\u7684\u6982\u5ff5\u3002 \u5bf9\u6bd4\u5206\u6790 \u548c unrestricted grammar production\u76f8\u6bd4\uff0c\u5b83\u7684restriction\u5728\u4e8e\uff1a \u03b3\u4e0d\u53ef\u4e3aempty string A\uff08\u5728\u4ea7\u751f\u5f0f\u7684\u5de6\u90e8\uff09\u5fc5\u987b\u662fnon-terminal \u4e0a\u8ff0\u4e24\u4e2arestriction\u5728Type-0 grammar\u4e2d\u90fd\u4e0d\u5b58\u5728\u3002 Type-2 grammars: Context-free grammar formal definitions A context-free grammar G is defined by the 4- tuple : $ G=(V,\\Sigma ,R,S) $ where V is a finite set; each element $ v\\in V $ is called a nonterminal character or a variable . Each variable represents a different type of phrase or clause in the sentence. Variables are also sometimes called syntactic categories. Each variable defines a sub-language of the language defined by G . \u03a3 is a finite set of terminal*s, disjoint from *V , which make up the actual content of the sentence. The set of terminals is the alphabet of the language defined by the grammar G . R is a finite relation from V to $ (V\\cup \\Sigma )^{ } $, where the asterisk represents the Kleene star operation. The members of *R are called the (rewrite) rule*s or *production*s of the grammar. (also commonly symbolized by a *P ) NOTE: See also production rule rewriting S is the start variable (or start symbol), used to represent the whole sentence (or program). It must be an element of V . Production rule notation A production rule in R is formalized mathematically as a pair $ (\\alpha ,\\beta )\\in R $, where $ \\alpha \\in V $ is a nonterminal and $ \\beta \\in (V\\cup \\Sigma )^{ } $ is a string of variables and/or terminals; rather than using ordered pair notation, production rules are usually written using an arrow operator with *\u03b1 as its left hand side and \u03b2 as its right hand side: $ \\alpha \\rightarrow \\beta $. It is allowed for \u03b2 to be the empty string , and in this case it is customary to denote it by \u03b5. The form $ \\alpha \\rightarrow \\varepsilon $ is called an \u03b5 -production. It is common to list all right-hand sides for the same left-hand side on the same line, using | (the pipe symbol ) to separate them. Rules $ \\alpha \\rightarrow \\beta _{1} $ and $ \\alpha \\rightarrow \\beta _{2} $ can hence be written as $ \\alpha \\rightarrow \\beta _{1}\\mid \\beta _{2} $. In this case, $ \\beta _{1} $ and $ \\beta _{2} $ is called the first and second alternative, respectively. Rule application For any strings $ u,v\\in (V\\cup \\Sigma )^{ } $, we say *u directly yields v , written as $ u\\Rightarrow v\\, $, if $ \\exists (\\alpha ,\\beta )\\in R $ with $ \\alpha \\in V $ and $ u_{1},u_{2}\\in (V\\cup \\Sigma )^{ } $ such that $ u\\,=u_{1}\\alpha u_{2} $ and $ v\\,=u_{1}\\beta u_{2} $. Thus, *v is a result of applying the rule $ (\\alpha ,\\beta ) $ to u . Repetitive rule application For any strings $ u,v\\in (V\\cup \\Sigma )^{ }, $ we say *u yields v , written as $ u{\\stackrel { }{\\Rightarrow }}v $ (or $ u\\Rightarrow \\Rightarrow v\\, $ in some textbooks), if $ \\exists k\\geq 1\\,\\exists \\,u_{1},\\cdots ,u_{k}\\in (V\\cup \\Sigma )^{ } $ such that $ u=\\,u_{1}\\Rightarrow u_{2}\\Rightarrow \\cdots \\Rightarrow u_{k}\\,=v $. In this case, if $ k\\geq 2 $ (i.e., $ u\\neq v $), the relation $ u{\\stackrel {+}{\\Rightarrow }}v $ holds. In other words, $ ({\\stackrel {*}{\\Rightarrow }}) $ and $ ({\\stackrel {+}{\\Rightarrow }}) $ are the reflexive transitive closure (allowing a word to yield itself) and the transitive closure (requiring at least one step) of $ (\\Rightarrow ) $, respectively. Context-free language The language of a grammar $ G=(V,\\Sigma ,R,S) $ is the set $ L(G)={w\\in \\Sigma ^{ }:S{\\stackrel { }{\\Rightarrow }}w} $ A language L is said to be a context-free language (CFL), if there exists a CFG G , such that $ L\\,=\\,L(G) $. Non-deterministic pushdown automata recognize exactly the context-free languages. \u5bf9\u6bd4\u5206\u6790 Context-free grammar \u7684restriction\u5728\u4e8e The left-hand side of the production rule is always a nonterminal symbol. This means that the symbol does not appear in the resulting formal language. \u5728type 1 grammar\u4e2d\uff0c\u5bf9\u4ea7\u751f\u5f0f\u7684\u5de6\u90e8\u4e2d nonterminal symbol\u7684\u4e2a\u6570\u5e76\u6ca1\u6709\u9650\u5236\u3002 Type-3 grammars: Regular grammar formal definition A right regular grammar (also called right linear grammar ) is a formal grammar ( N , \u03a3, P , S ) such that all the production rules in P are of one of the following forms: A \u2192 a , where A is a non-terminal in N and a is a terminal in \u03a3 A \u2192 aB , where A and B are non-terminals in N and a is in \u03a3 A \u2192 \u03b5, where A is in N and \u03b5 denotes the empty string , i.e. the string of length 0. In a left regular grammar (also called left linear grammar ), all rules obey the forms A \u2192 a , where A is a non-terminal in N and a is a terminal in \u03a3 A \u2192 Ba , where A and B are in N and a is in \u03a3 A \u2192 \u03b5, where A is in N and \u03b5 is the empty string. A regular grammar is a left or right regular grammar. Some textbooks and articles disallow empty production rules, and assume that the empty string is not present in languages. \u5bf9\u6bd4\u5206\u6790 \u4e0eType-2 grammars\u76f8\u6bd4\uff0cType-3 grammars\u7684\u9650\u5236\u5728\u4e8e\u4ea7\u751f\u5f0f\u53f3\u4fa7\u7684non-terminal\uff1a \u4ea7\u751f\u5f0f\u7684\u53f3\u4fa7\u6700\u591a\u53ea\u80fd\u591f\u6709\u4e00\u4e2anon-terminal \u4ea7\u751f\u5f0f\u53f3\u4fa7\u7684non-terminal\u53ea\u80fd\u591f\u5728\u6700\u5de6\u4fa7\u6216\u6700\u53f3\u4fa7 \u663e\u7136\uff0c\u4e0eType-2 grammars\u76f8\u6bd4\uff0c\u7531\u4e8eType-3 grammar\u7684production\u7684\u53f3\u4fa7\u53ea\u80fd\u591f\u6709\u4e00\u4e2anon-terminal\uff0c\u6240\u4ee5\u5728\u6309\u7167\u5b83\u7684production\u8fdb\u884crewrite\uff08\u6269\u5c55\uff09\u7684\u65f6\u5019\uff0c\u53ea\u80fd\u591f\u5411\u4e00\u4e2a\u65b9\u5411\u8fdb\u884c\u6269\u5c55\uff0c\u6240\u4ee5\u6700\u7ec8\u7684\u6269\u5c55\u7ed3\u679c\u53ea\u80fd\u591f\u662f\u4e00\u4e2a\u7ebf\u6027\u7684\u7ed3\u6784\uff0c\u6240\u4ee5\u5b83\u662f linear grammar \u3002\u800cType-2 grammar\u7684production\u7684\u53f3\u4fa7\u53ef\u4ee5\u6709\u591a\u4e2anon-terminal\uff0c\u6240\u4ee5\u5728\u6309\u7167\u5b83\u7684production\u8fdb\u884crewrite\uff08\u6269\u5c55\uff09\u7684\u65f6\u5019\uff0c\u80fd\u591f\u5411\u591a\u4e2a\u65b9\u5411\u8fdb\u884c\u6269\u5c55\uff0c\u6240\u4ee5\u6700\u7ec8\u7684\u6269\u5c55\u7ed3\u679c\u662f\u4e00\u4e2a\u6811\u5f62\u7684\u7ed3\u6784\uff0c\u6240\u4ee5\u5b83\u4e0d\u662f linear grammar \u3002 NOTE: \u63cf\u8ff0\u7684\u7ed3\u6784 \u603b\u7ed3 \u4e0a\u8ff0\u6240\u6709grammar\u7684production\u90fd\u53ef\u4ee5\u652f\u6301\u9012\u5f52\uff0c\u5373\u90fd\u53ef\u4ee5\u662f recursive grammar \u3002 NOTE: \u63cf\u8ff0\u7684\u9012\u5f52\u6027 \u5728 Recursively enumerable language \u4e2d\u6709\u8fd9\u6837\u7684\u63cf\u8ff0\uff1a All regular , context-free , context-sensitive and recursive languages are recursively enumerable. \u5bf9\u6bd4\u5206\u6790By automaton CFG\u7684 automaton\u662fpushdown automaton\uff0c\u6211\u4eec\u77e5\u9053pushdown automaton\u672c\u8d28\u4e0a\u6765\u8bf4\u5c31\u662fstack\uff0cCFG\u672c\u8d28\u4e0a\u6765\u8bf4\u8868\u793a\u7684\u662fhierarchy\u7ed3\u6784/\u6811\u5f62\u7ed3\u6784\u3002","title":"\u5bf9\u6bd4\u5206\u6790"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/#_1","text":"Type-0 grammars\u53c8\u53eb\u505a unrestricted grammar \uff0c\u4ece\u5b83\u7684\u540d\u5b57\u53ef\u4ee5\u770b\u51fa\uff0c\u5b83\u662funrestricted\u7684\uff0c\u5373 No restrictions are made on the productions of an unrestricted grammar \u90a3\u5176\u5b83grammar\uff08Type-1 grammars Context-sensitive grammar \u3001Type-2 grammars Context-free grammar \u3001Type-3 grammars Regular grammar \uff09\uff0c\u5bf9\u5404\u81ea\u7684production\u7684restriction\u662f\u4ec0\u4e48\u5462\uff1f\u4e0b\u9762\u4ece\u8fd9\u4e2a\u89d2\u5ea6\u5bf9\u8fd9\u51e0\u79cdgrammar\u8fdb\u884c\u5bf9\u6bd4\u5206\u6790\uff0c \u7531\u4e0a\u8ff0Chomsky hierarchy\u6240\u63cf\u8ff0\u7684\u5c42\u7ea7\u53ef\u4ee5\u770b\u51fa\uff0c\u4eceType 0 grammars\u5230Type 3 grammars\u9010\u7ea7\u589e\u52a0restriction\uff0c\u6240\u4ee5\u5728\u8fdb\u884c\u5bf9\u6bd4\u5206\u6790\u7684\u65f6\u5019\uff0c\u6bcf\u4e2agrammar\u53ea\u9700\u8981\u548c\u5b83\u7684\u5347\u4e00\u7ea7grammar\u8fdb\u884c\u5bf9\u6bd4\u5373\u53ef\u3002","title":"\u5bf9\u6bd4\u5206\u6790"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/#type-0#grammarsunrestricted#grammar#formal#definition","text":"An unrestricted grammar is a formal grammar $ G=(N,\\Sigma ,P,S) $, where $ N $ is a set of nonterminal symbols, $ \\Sigma $ is a set of terminal symbols , $ N $ and $ \\Sigma $ are disjoint, $ P $ is a set of production rules of the form $ \\alpha \\to \\beta $ where $ \\alpha $ and $ \\beta $ are strings of symbols in $ N\\cup \\Sigma $ and $ \\alpha $ is not the empty string , and $ S\\in N $ is a specially designated start symbol. As the name implies, there are no real restrictions on the types of production rules that unrestricted grammars can have.","title":"Type-0 grammars:Unrestricted grammar formal definition"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/#_2","text":"\u548c\u5176\u4ed6\u7684grammar production\u76f8\u6bd4\uff0c\u5b83\u7684unrestriction\u4f53\u73b0\u5728\uff1a \\alpha \\alpha \u53ef\u4ee5\u4e3aterminal\u3001non-terminal \\beta \\beta \u53ef\u4ee5\u4e3aempty string","title":"\u5bf9\u6bd4\u5206\u6790"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/#type-1#grammarscontext-sensitive#grammar#formal#definition","text":"A formal grammar G = ( N , \u03a3, P , S ), where N is a set of nonterminal symbols, \u03a3 is a set of terminal symbols, P is a set of production rules, and S is the start symbol , is context-sensitive if all rules in P are of the form \u03b1*A*\u03b2 \u2192 \u03b1\u03b3\u03b2 where A \u2208 N , \u03b1,\u03b2 \u2208 ( N \u222a\u03a3)* and \u03b3 \u2208 ( N \u222a\u03a3)+. \u4e0a\u8ff0 * \u548c + \u90fd\u662f\u4f7f\u7528\u7684\u6b63\u5219\u8868\u8fbe\u5f0f\u7684\u6982\u5ff5\u3002","title":"Type-1 grammars:Context-sensitive grammar formal definition"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/#_3","text":"\u548c unrestricted grammar production\u76f8\u6bd4\uff0c\u5b83\u7684restriction\u5728\u4e8e\uff1a \u03b3\u4e0d\u53ef\u4e3aempty string A\uff08\u5728\u4ea7\u751f\u5f0f\u7684\u5de6\u90e8\uff09\u5fc5\u987b\u662fnon-terminal \u4e0a\u8ff0\u4e24\u4e2arestriction\u5728Type-0 grammar\u4e2d\u90fd\u4e0d\u5b58\u5728\u3002","title":"\u5bf9\u6bd4\u5206\u6790"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/#type-2#grammarscontext-free#grammar#formal#definitions","text":"A context-free grammar G is defined by the 4- tuple : $ G=(V,\\Sigma ,R,S) $ where V is a finite set; each element $ v\\in V $ is called a nonterminal character or a variable . Each variable represents a different type of phrase or clause in the sentence. Variables are also sometimes called syntactic categories. Each variable defines a sub-language of the language defined by G . \u03a3 is a finite set of terminal*s, disjoint from *V , which make up the actual content of the sentence. The set of terminals is the alphabet of the language defined by the grammar G . R is a finite relation from V to $ (V\\cup \\Sigma )^{ } $, where the asterisk represents the Kleene star operation. The members of *R are called the (rewrite) rule*s or *production*s of the grammar. (also commonly symbolized by a *P ) NOTE: See also production rule rewriting S is the start variable (or start symbol), used to represent the whole sentence (or program). It must be an element of V .","title":"Type-2 grammars:Context-free grammar formal definitions"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/#production#rule#notation","text":"A production rule in R is formalized mathematically as a pair $ (\\alpha ,\\beta )\\in R $, where $ \\alpha \\in V $ is a nonterminal and $ \\beta \\in (V\\cup \\Sigma )^{ } $ is a string of variables and/or terminals; rather than using ordered pair notation, production rules are usually written using an arrow operator with *\u03b1 as its left hand side and \u03b2 as its right hand side: $ \\alpha \\rightarrow \\beta $. It is allowed for \u03b2 to be the empty string , and in this case it is customary to denote it by \u03b5. The form $ \\alpha \\rightarrow \\varepsilon $ is called an \u03b5 -production. It is common to list all right-hand sides for the same left-hand side on the same line, using | (the pipe symbol ) to separate them. Rules $ \\alpha \\rightarrow \\beta _{1} $ and $ \\alpha \\rightarrow \\beta _{2} $ can hence be written as $ \\alpha \\rightarrow \\beta _{1}\\mid \\beta _{2} $. In this case, $ \\beta _{1} $ and $ \\beta _{2} $ is called the first and second alternative, respectively.","title":"Production rule notation"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/#rule#application","text":"For any strings $ u,v\\in (V\\cup \\Sigma )^{ } $, we say *u directly yields v , written as $ u\\Rightarrow v\\, $, if $ \\exists (\\alpha ,\\beta )\\in R $ with $ \\alpha \\in V $ and $ u_{1},u_{2}\\in (V\\cup \\Sigma )^{ } $ such that $ u\\,=u_{1}\\alpha u_{2} $ and $ v\\,=u_{1}\\beta u_{2} $. Thus, *v is a result of applying the rule $ (\\alpha ,\\beta ) $ to u .","title":"Rule application"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/#repetitive#rule#application","text":"For any strings $ u,v\\in (V\\cup \\Sigma )^{ }, $ we say *u yields v , written as $ u{\\stackrel { }{\\Rightarrow }}v $ (or $ u\\Rightarrow \\Rightarrow v\\, $ in some textbooks), if $ \\exists k\\geq 1\\,\\exists \\,u_{1},\\cdots ,u_{k}\\in (V\\cup \\Sigma )^{ } $ such that $ u=\\,u_{1}\\Rightarrow u_{2}\\Rightarrow \\cdots \\Rightarrow u_{k}\\,=v $. In this case, if $ k\\geq 2 $ (i.e., $ u\\neq v $), the relation $ u{\\stackrel {+}{\\Rightarrow }}v $ holds. In other words, $ ({\\stackrel {*}{\\Rightarrow }}) $ and $ ({\\stackrel {+}{\\Rightarrow }}) $ are the reflexive transitive closure (allowing a word to yield itself) and the transitive closure (requiring at least one step) of $ (\\Rightarrow ) $, respectively.","title":"Repetitive rule application"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/#context-free#language","text":"The language of a grammar $ G=(V,\\Sigma ,R,S) $ is the set $ L(G)={w\\in \\Sigma ^{ }:S{\\stackrel { }{\\Rightarrow }}w} $ A language L is said to be a context-free language (CFL), if there exists a CFG G , such that $ L\\,=\\,L(G) $. Non-deterministic pushdown automata recognize exactly the context-free languages.","title":"Context-free language"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/#_4","text":"Context-free grammar \u7684restriction\u5728\u4e8e The left-hand side of the production rule is always a nonterminal symbol. This means that the symbol does not appear in the resulting formal language. \u5728type 1 grammar\u4e2d\uff0c\u5bf9\u4ea7\u751f\u5f0f\u7684\u5de6\u90e8\u4e2d nonterminal symbol\u7684\u4e2a\u6570\u5e76\u6ca1\u6709\u9650\u5236\u3002","title":"\u5bf9\u6bd4\u5206\u6790"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/#type-3#grammarsregular#grammar#formal#definition","text":"A right regular grammar (also called right linear grammar ) is a formal grammar ( N , \u03a3, P , S ) such that all the production rules in P are of one of the following forms: A \u2192 a , where A is a non-terminal in N and a is a terminal in \u03a3 A \u2192 aB , where A and B are non-terminals in N and a is in \u03a3 A \u2192 \u03b5, where A is in N and \u03b5 denotes the empty string , i.e. the string of length 0. In a left regular grammar (also called left linear grammar ), all rules obey the forms A \u2192 a , where A is a non-terminal in N and a is a terminal in \u03a3 A \u2192 Ba , where A and B are in N and a is in \u03a3 A \u2192 \u03b5, where A is in N and \u03b5 is the empty string. A regular grammar is a left or right regular grammar. Some textbooks and articles disallow empty production rules, and assume that the empty string is not present in languages.","title":"Type-3 grammars:Regular grammar formal definition"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/#_5","text":"\u4e0eType-2 grammars\u76f8\u6bd4\uff0cType-3 grammars\u7684\u9650\u5236\u5728\u4e8e\u4ea7\u751f\u5f0f\u53f3\u4fa7\u7684non-terminal\uff1a \u4ea7\u751f\u5f0f\u7684\u53f3\u4fa7\u6700\u591a\u53ea\u80fd\u591f\u6709\u4e00\u4e2anon-terminal \u4ea7\u751f\u5f0f\u53f3\u4fa7\u7684non-terminal\u53ea\u80fd\u591f\u5728\u6700\u5de6\u4fa7\u6216\u6700\u53f3\u4fa7 \u663e\u7136\uff0c\u4e0eType-2 grammars\u76f8\u6bd4\uff0c\u7531\u4e8eType-3 grammar\u7684production\u7684\u53f3\u4fa7\u53ea\u80fd\u591f\u6709\u4e00\u4e2anon-terminal\uff0c\u6240\u4ee5\u5728\u6309\u7167\u5b83\u7684production\u8fdb\u884crewrite\uff08\u6269\u5c55\uff09\u7684\u65f6\u5019\uff0c\u53ea\u80fd\u591f\u5411\u4e00\u4e2a\u65b9\u5411\u8fdb\u884c\u6269\u5c55\uff0c\u6240\u4ee5\u6700\u7ec8\u7684\u6269\u5c55\u7ed3\u679c\u53ea\u80fd\u591f\u662f\u4e00\u4e2a\u7ebf\u6027\u7684\u7ed3\u6784\uff0c\u6240\u4ee5\u5b83\u662f linear grammar \u3002\u800cType-2 grammar\u7684production\u7684\u53f3\u4fa7\u53ef\u4ee5\u6709\u591a\u4e2anon-terminal\uff0c\u6240\u4ee5\u5728\u6309\u7167\u5b83\u7684production\u8fdb\u884crewrite\uff08\u6269\u5c55\uff09\u7684\u65f6\u5019\uff0c\u80fd\u591f\u5411\u591a\u4e2a\u65b9\u5411\u8fdb\u884c\u6269\u5c55\uff0c\u6240\u4ee5\u6700\u7ec8\u7684\u6269\u5c55\u7ed3\u679c\u662f\u4e00\u4e2a\u6811\u5f62\u7684\u7ed3\u6784\uff0c\u6240\u4ee5\u5b83\u4e0d\u662f linear grammar \u3002 NOTE: \u63cf\u8ff0\u7684\u7ed3\u6784","title":"\u5bf9\u6bd4\u5206\u6790"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/#_6","text":"\u4e0a\u8ff0\u6240\u6709grammar\u7684production\u90fd\u53ef\u4ee5\u652f\u6301\u9012\u5f52\uff0c\u5373\u90fd\u53ef\u4ee5\u662f recursive grammar \u3002 NOTE: \u63cf\u8ff0\u7684\u9012\u5f52\u6027 \u5728 Recursively enumerable language \u4e2d\u6709\u8fd9\u6837\u7684\u63cf\u8ff0\uff1a All regular , context-free , context-sensitive and recursive languages are recursively enumerable.","title":"\u603b\u7ed3"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/#by#automaton","text":"CFG\u7684 automaton\u662fpushdown automaton\uff0c\u6211\u4eec\u77e5\u9053pushdown automaton\u672c\u8d28\u4e0a\u6765\u8bf4\u5c31\u662fstack\uff0cCFG\u672c\u8d28\u4e0a\u6765\u8bf4\u8868\u793a\u7684\u662fhierarchy\u7ed3\u6784/\u6811\u5f62\u7ed3\u6784\u3002","title":"\u5bf9\u6bd4\u5206\u6790By automaton"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/Type-0/wikipedia-Recursively-enumerable-language/","text":"Recursively enumerable language Unrestricted grammar Formal definition Semi-Thue system Recursively enumerable language Unrestricted grammar In automata theory , the class of unrestricted grammars (also called semi-Thue , type-0 or phrase structure grammars ) is the most general class of grammars in the Chomsky hierarchy . No restrictions are made on the productions of an unrestricted grammar, other than each of their left-hand sides being non-empty. This grammar class can generate arbitrary recursively enumerable languages . Formal definition An unrestricted grammar is a formal grammar $ G=(N,\\Sigma ,P,S) $, where $ N $ is a set of nonterminal symbols, $ \\Sigma $ is a set of terminal symbols , $ N $ and $ \\Sigma $ are disjoint, $ P $ is a set of production rules of the form $ \\alpha \\to \\beta $ where $ \\alpha $ and $ \\beta $ are strings of symbols in $ N\\cup \\Sigma $ and $ \\alpha $ is not the empty string, and $ S\\in N $ is a specially designated start symbol. As the name implies, there are no real restrictions on the types of production rules that unrestricted grammars can have. Semi-Thue system In theoretical computer science and mathematical logic a string rewriting system ( SRS ), historically called a semi- Thue system , is a rewriting system over strings from a (usually finite ) alphabet . Given a binary relation $ R $ between fixed strings over the alphabet, called rewrite rules , denoted by $ s\\rightarrow t $, an SRS extends the rewriting relation to all strings in which the left- and right-hand side of the rules appear as substrings , that is $ usv\\rightarrow utv $, where $ s $, $ t $, $ u $, and $ v $ are strings.","title":"Recursively-enumerable-language"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/Type-0/wikipedia-Recursively-enumerable-language/#recursively#enumerable#language","text":"","title":"Recursively enumerable language"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/Type-0/wikipedia-Recursively-enumerable-language/#unrestricted#grammar","text":"In automata theory , the class of unrestricted grammars (also called semi-Thue , type-0 or phrase structure grammars ) is the most general class of grammars in the Chomsky hierarchy . No restrictions are made on the productions of an unrestricted grammar, other than each of their left-hand sides being non-empty. This grammar class can generate arbitrary recursively enumerable languages .","title":"Unrestricted grammar"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/Type-0/wikipedia-Recursively-enumerable-language/#formal#definition","text":"An unrestricted grammar is a formal grammar $ G=(N,\\Sigma ,P,S) $, where $ N $ is a set of nonterminal symbols, $ \\Sigma $ is a set of terminal symbols , $ N $ and $ \\Sigma $ are disjoint, $ P $ is a set of production rules of the form $ \\alpha \\to \\beta $ where $ \\alpha $ and $ \\beta $ are strings of symbols in $ N\\cup \\Sigma $ and $ \\alpha $ is not the empty string, and $ S\\in N $ is a specially designated start symbol. As the name implies, there are no real restrictions on the types of production rules that unrestricted grammars can have.","title":"Formal definition"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/Type-0/wikipedia-Recursively-enumerable-language/#semi-thue#system","text":"In theoretical computer science and mathematical logic a string rewriting system ( SRS ), historically called a semi- Thue system , is a rewriting system over strings from a (usually finite ) alphabet . Given a binary relation $ R $ between fixed strings over the alphabet, called rewrite rules , denoted by $ s\\rightarrow t $, an SRS extends the rewriting relation to all strings in which the left- and right-hand side of the rules appear as substrings , that is $ usv\\rightarrow utv $, where $ s $, $ t $, $ u $, and $ v $ are strings.","title":"Semi-Thue system"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/Type-1/wikipedia-Context-sensitive-language/","text":"Context-sensitive language Context-sensitive grammar","title":"Context-sensitive-language"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/Type-1/wikipedia-Context-sensitive-language/#context-sensitive#language","text":"","title":"Context-sensitive language"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/Type-1/wikipedia-Context-sensitive-language/#context-sensitive#grammar","text":"","title":"Context-sensitive grammar"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/Type-2/Context-free-language/","text":"Context-free language Context-free grammar Context-free language $ S\\to SS | (S) | \\varepsilon $. $ {a {n}b {n}c {n}d {n}|n>0} $ Context-free grammar","title":"Context-free-language"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/Type-2/Context-free-language/#context-free#language","text":"$ S\\to SS | (S) | \\varepsilon $. $ {a {n}b {n}c {n}d {n}|n>0} $","title":"Context-free language"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/Type-2/Context-free-language/#context-free#grammar","text":"","title":"Context-free grammar"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/Type-2/Pushdown-automaton/","text":"wikipedia Pushdown automaton In the theory of computation , a branch of theoretical computer science , a pushdown automaton ( PDA ) is a type of automaton that employs a stack . Pushdown automata are used in theories about what can be computed by machines. They are more capable than finite-state machines but less capable than Turing machines . Deterministic pushdown automata can recognize all deterministic context-free languages while nondeterministic ones can recognize all context-free languages , with the former often used in parser design. The term \"pushdown\" refers to the fact that the stack can be regarded as being \"pushed down\" like a tray dispenser at a cafeteria, since the operations never work on elements other than the top element. A stack automaton , by contrast, does allow access to and operations on deeper elements. Stack automata can recognize a strictly larger set of languages than pushdown automata.[ 1] A nested stack automaton allows full access, and also allows stacked values to be entire sub-stacks rather than just single finite symbols. Informal description A finite state machine just looks at the input signal and the current state : it has no stack to work with. It chooses a new state, the result of following the transition. A pushdown automaton (PDA) differs from a finite state machine in two ways: It can use the top of the stack to decide which transition to take. It can manipulate the stack as part of performing a transition. A pushdown automaton reads a given input string from left to right. In each step, it chooses a transition by indexing a table by input symbol, current state, and the symbol at the top of the stack. A pushdown automaton can also manipulate the stack, as part of performing a transition. The manipulation can be to push a particular symbol to the top of the stack, or to pop off the top of the stack. The automaton can alternatively ignore the stack, and leave it as it is. Put together: Given an input symbol, current state, and stack symbol, the automaton can follow a transition to another state, and optionally manipulate (push or pop) the stack. NOTE: In fact, without concrete example, the above description is very difficult to understand. A LL parser is a typical pushdown automaton , the Wikipedia entry LL parser give an concrete and concise example to explain the mechanism of thee parser, that is pushdown automaton . After reading it, I think you will grasp what above paragraph describe. A diagram of a pushdown automaton Deterministic pushdown automaton","title":"Introduction"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/Type-2/Pushdown-automaton/#wikipedia#pushdown#automaton","text":"In the theory of computation , a branch of theoretical computer science , a pushdown automaton ( PDA ) is a type of automaton that employs a stack . Pushdown automata are used in theories about what can be computed by machines. They are more capable than finite-state machines but less capable than Turing machines . Deterministic pushdown automata can recognize all deterministic context-free languages while nondeterministic ones can recognize all context-free languages , with the former often used in parser design. The term \"pushdown\" refers to the fact that the stack can be regarded as being \"pushed down\" like a tray dispenser at a cafeteria, since the operations never work on elements other than the top element. A stack automaton , by contrast, does allow access to and operations on deeper elements. Stack automata can recognize a strictly larger set of languages than pushdown automata.[ 1] A nested stack automaton allows full access, and also allows stacked values to be entire sub-stacks rather than just single finite symbols.","title":"wikipedia Pushdown automaton"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/Type-2/Pushdown-automaton/#informal#description","text":"A finite state machine just looks at the input signal and the current state : it has no stack to work with. It chooses a new state, the result of following the transition. A pushdown automaton (PDA) differs from a finite state machine in two ways: It can use the top of the stack to decide which transition to take. It can manipulate the stack as part of performing a transition. A pushdown automaton reads a given input string from left to right. In each step, it chooses a transition by indexing a table by input symbol, current state, and the symbol at the top of the stack. A pushdown automaton can also manipulate the stack, as part of performing a transition. The manipulation can be to push a particular symbol to the top of the stack, or to pop off the top of the stack. The automaton can alternatively ignore the stack, and leave it as it is. Put together: Given an input symbol, current state, and stack symbol, the automaton can follow a transition to another state, and optionally manipulate (push or pop) the stack. NOTE: In fact, without concrete example, the above description is very difficult to understand. A LL parser is a typical pushdown automaton , the Wikipedia entry LL parser give an concrete and concise example to explain the mechanism of thee parser, that is pushdown automaton . After reading it, I think you will grasp what above paragraph describe. A diagram of a pushdown automaton","title":"Informal description"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/Type-2/Pushdown-automaton/#deterministic#pushdown#automaton","text":"","title":"Deterministic pushdown automaton"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/Type-3/","text":"Regular language \u53c2\u89c1 Regular-language \u7ae0\u8282\u3002","title":"Introduction"},{"location":"Formal-language/Formal-grammar/Chomsky-hierarchy/Type-3/#regular#language","text":"\u53c2\u89c1 Regular-language \u7ae0\u8282\u3002","title":"Regular language"},{"location":"Formal-language/Formal-grammar/Parsing-Expression-Grammars/","text":"Parsing expression grammar In computer science , a parsing expression grammar , or PEG , is a type of analytic formal grammar , i.e. it describes a formal language in terms of a set of rules for recognizing strings in the language. The formalism was introduced by Bryan Ford in 2004[ 1] and is closely related to the family of top-down parsing languages introduced in the early 1970s. Syntactically, PEGs also look similar to context-free grammars (CFGs), but they have a different interpretation: the choice operator selects the first match in PEG, while it is ambiguous in CFG. This is closer to how string recognition tends to be done in practice, e.g. by a recursive descent parser . NOTE: PEG include regular grammar. Unlike CFGs, PEGs cannot be ambiguous ; if a string parses, it has exactly one valid parse tree . It is conjectured that there exist context-free languages that cannot be recognized by a PEG, but this is not yet proven.[ 1] PEGs are well-suited to parsing computer languages (and artificial human languages such as Lojban ), but not natural languages where the performance of PEG algorithms is comparable to general CFG algorithms such as the Earley algorithm . NOTE: Python3.8+ use PEG to describe its grammar. See also The Packrat Parsing and Parsing Expression Grammars Page","title":"Introduction"},{"location":"Formal-language/Formal-grammar/Parsing-Expression-Grammars/#parsing#expression#grammar","text":"In computer science , a parsing expression grammar , or PEG , is a type of analytic formal grammar , i.e. it describes a formal language in terms of a set of rules for recognizing strings in the language. The formalism was introduced by Bryan Ford in 2004[ 1] and is closely related to the family of top-down parsing languages introduced in the early 1970s. Syntactically, PEGs also look similar to context-free grammars (CFGs), but they have a different interpretation: the choice operator selects the first match in PEG, while it is ambiguous in CFG. This is closer to how string recognition tends to be done in practice, e.g. by a recursive descent parser . NOTE: PEG include regular grammar. Unlike CFGs, PEGs cannot be ambiguous ; if a string parses, it has exactly one valid parse tree . It is conjectured that there exist context-free languages that cannot be recognized by a PEG, but this is not yet proven.[ 1] PEGs are well-suited to parsing computer languages (and artificial human languages such as Lojban ), but not natural languages where the performance of PEG algorithms is comparable to general CFG algorithms such as the Earley algorithm . NOTE: Python3.8+ use PEG to describe its grammar.","title":"Parsing expression grammar"},{"location":"Formal-language/Formal-grammar/Parsing-Expression-Grammars/#see#also","text":"The Packrat Parsing and Parsing Expression Grammars Page","title":"See also"},{"location":"Formal-language/Formal-grammar/Production%28computer-science%29/","text":"Production (computer science) \u4ea7\u751f\u5f0f\u7684\u9012\u5f52\u6027 \u9012\u5f52\u516c\u5f0fVS\u4ea7\u751f\u5f0f \u4eceMathematical logic\u7684\u89d2\u5ea6\u6765\u770bFormal grammars Backus\u2013Naur form Production (computer science) \u57fa\u672c\u4e0a\u6240\u6709\u7684formal grammar\u90fd\u662f\u4f7f\u7528\u7684production\u6765\u8fdb\u884c\u63cf\u8ff0\uff0c\u6240\u4ee5\u5bf9production\u8fdb\u884c\u5206\u6790\u662f\u6709\u4e00\u5b9a\u5fc5\u8981\u7684\u3002 \u4ea7\u751f\u5f0f\u7684\u9012\u5f52\u6027 \u5f53\u4ea7\u751f\u5f0f\u4f53\u4e2d\u5305\u542b\u4ea7\u751f\u5f0f\u5934\u90e8\u4e2d\u7684non-terminal\u7684\u65f6\uff0c\u8be5\u4ea7\u751f\u5f0f\u5c31\u662f recursive \uff0c\u5b83\u6240\u63cf\u8ff0\u7684grammar\u5c31\u662f recursive grammar \u3002 \u4e0e\u4ea7\u751f\u5f0f\u7684\u9012\u5f52\u6027\u76f8\u5173\u7684\u53e6\u5916\u4e00\u4e2a\u6982\u5ff5\u662f left recursion \u3002 \u9012\u5f52\u516c\u5f0fVS\u4ea7\u751f\u5f0f \u6570\u5b66\u4e2d\u7684\u9012\u5f52\u516c\u5f0f\uff08 recurrence relation \uff09\uff0c\u8bed\u8a00\u5b66\u4e2d\u7684\u4ea7\u751f\u5f0f\uff0c\u4e24\u8005\u5176\u5b9e\u6709\u7740\u5171\u540c\u4e4b\u5904\uff1a\u9012\u5f52\u3002 \u4ece Mathematical logic \u7684\u89d2\u5ea6\u6765\u770b Formal grammars \u5728 Formal-language \u7684\u300a\u4ece Mathematical logic \u7684\u89d2\u5ea6\u6765\u770b Formal grammars \u300b\u7ae0\u8282\u5c31\u4ece Mathematical logic \u7684\u89d2\u5ea6\u5206\u6790\u4e86 Formal grammars \uff0c\u5176\u5b9e\u8fd9\u662f\u5bf9production\u7684\u5206\u6790\u3002 \u4ece Formation rule \u7684\u89d2\u5ea6\u6765\u770b\u5f85production\uff0c\u5219\u5b83\u662f\u4e00\u79cd\u63a8\u5bfc\u3002\u5982\u679c\u4ece\u63a8\u5bfc\u7684\u89d2\u5ea6\u6765\u770b\u5f85\u4ea7\u751f\u5f0f\u7684\u8bdd\uff0c\u5219\u5173\u4e8e\u81ea\u9876\u5411\u4e0bparsing\u65e0\u6cd5\u5904\u7406\u5de6\u9012\u5f52\u7684\u60c5\u51b5\u5c31\u975e\u5e38\u4efb\u610f\u7406\u89e3\u4e86 Backus\u2013Naur form BNF\u672c\u8d28\u4e0a\u4e5f\u662f\u4e00\u79cd\u4ea7\u751f\u5f0f","title":"Introduction"},{"location":"Formal-language/Formal-grammar/Production%28computer-science%29/#production#computer#science","text":"\u57fa\u672c\u4e0a\u6240\u6709\u7684formal grammar\u90fd\u662f\u4f7f\u7528\u7684production\u6765\u8fdb\u884c\u63cf\u8ff0\uff0c\u6240\u4ee5\u5bf9production\u8fdb\u884c\u5206\u6790\u662f\u6709\u4e00\u5b9a\u5fc5\u8981\u7684\u3002","title":"Production (computer science)"},{"location":"Formal-language/Formal-grammar/Production%28computer-science%29/#_1","text":"\u5f53\u4ea7\u751f\u5f0f\u4f53\u4e2d\u5305\u542b\u4ea7\u751f\u5f0f\u5934\u90e8\u4e2d\u7684non-terminal\u7684\u65f6\uff0c\u8be5\u4ea7\u751f\u5f0f\u5c31\u662f recursive \uff0c\u5b83\u6240\u63cf\u8ff0\u7684grammar\u5c31\u662f recursive grammar \u3002 \u4e0e\u4ea7\u751f\u5f0f\u7684\u9012\u5f52\u6027\u76f8\u5173\u7684\u53e6\u5916\u4e00\u4e2a\u6982\u5ff5\u662f left recursion \u3002","title":"\u4ea7\u751f\u5f0f\u7684\u9012\u5f52\u6027"},{"location":"Formal-language/Formal-grammar/Production%28computer-science%29/#vs","text":"\u6570\u5b66\u4e2d\u7684\u9012\u5f52\u516c\u5f0f\uff08 recurrence relation \uff09\uff0c\u8bed\u8a00\u5b66\u4e2d\u7684\u4ea7\u751f\u5f0f\uff0c\u4e24\u8005\u5176\u5b9e\u6709\u7740\u5171\u540c\u4e4b\u5904\uff1a\u9012\u5f52\u3002","title":"\u9012\u5f52\u516c\u5f0fVS\u4ea7\u751f\u5f0f"},{"location":"Formal-language/Formal-grammar/Production%28computer-science%29/#mathematical#logicformal#grammars","text":"\u5728 Formal-language \u7684\u300a\u4ece Mathematical logic \u7684\u89d2\u5ea6\u6765\u770b Formal grammars \u300b\u7ae0\u8282\u5c31\u4ece Mathematical logic \u7684\u89d2\u5ea6\u5206\u6790\u4e86 Formal grammars \uff0c\u5176\u5b9e\u8fd9\u662f\u5bf9production\u7684\u5206\u6790\u3002 \u4ece Formation rule \u7684\u89d2\u5ea6\u6765\u770b\u5f85production\uff0c\u5219\u5b83\u662f\u4e00\u79cd\u63a8\u5bfc\u3002\u5982\u679c\u4ece\u63a8\u5bfc\u7684\u89d2\u5ea6\u6765\u770b\u5f85\u4ea7\u751f\u5f0f\u7684\u8bdd\uff0c\u5219\u5173\u4e8e\u81ea\u9876\u5411\u4e0bparsing\u65e0\u6cd5\u5904\u7406\u5de6\u9012\u5f52\u7684\u60c5\u51b5\u5c31\u975e\u5e38\u4efb\u610f\u7406\u89e3\u4e86","title":"\u4eceMathematical logic\u7684\u89d2\u5ea6\u6765\u770bFormal grammars"},{"location":"Formal-language/Formal-grammar/Production%28computer-science%29/#backusnaur#form","text":"BNF\u672c\u8d28\u4e0a\u4e5f\u662f\u4e00\u79cd\u4ea7\u751f\u5f0f","title":"Backus\u2013Naur form"},{"location":"Formal-language/Formal-grammar/wikipedia-Formal-grammar/","text":"Formal grammar In formal language theory , a grammar (when the context is not given, often called a formal grammar for clarity) is a set of production rules for strings in a formal language . The rules describe how to form strings from the language's alphabet that are valid according to the language's syntax . A grammar does not describe the meaning of the strings or what can be done with them in whatever context\u2014only their form. NOTE: \u4e0d\u6d89\u53ca semantics A formal grammar is a set of rules for rewriting strings, along with a \"start symbol\" from which rewriting starts. Therefore, a grammar is usually thought of as a language generator . However, it can also sometimes be used as the basis for a \" recognizer \"\u2014a function in computing that determines whether a given string belongs to the language or is grammatically incorrect. To describe such recognizers , formal language theory uses separate formalisms, known as automata theory . One of the interesting results of automata theory is that it is not possible to design a recognizer for certain formal languages . Parsing is the process of recognizing an utterance (a string in natural languages) by breaking it down to a set of symbols and analyzing each one against the grammar of the language. Most languages have the meanings of their utterances structured according to their syntax \u2014a practice known as compositional semantics . As a result, the first step to describing the meaning of an utterance in language is to break it down part by part and look at its analyzed form (known as its parse tree in computer science, and as its deep structure in generative grammar ). Formal definition Main article: Unrestricted grammar The syntax of grammars NOTE: \u8fd9\u4e00\u6bb5\u662f\u63cf\u8ff0\u8bed\u6cd5\u7684\u8bed\u6cd5\uff0c\u5176\u5b9e\u5c31\u662f Metasyntax The Chomsky hierarchy Main article: Chomsky hierarchy NOTE: Chomsky hierarchy \u5bf9formal grammar\u8fdb\u884c\u5206\u7c7b\u3002\u5728Chomsky-hierarchy\u7ae0\u8282\u5bf9\u5b83\u8fdb\u884c\u5206\u6790\u3002 Analytic grammars NOTE: \u5728compiler\u4e2d\uff0c\u5f80\u5f80\u662f\u57fa\u4e8egrammar\u6765\u5bf9language\uff08\u5176\u5b9e\u5c31\u662f\u6211\u4eec\u6240\u5199\u7684\u7a0b\u5e8f\uff09\u8fdb\u884c\u5206\u6790\uff0c\u8fd9\u4e2a\u8fc7\u7a0b\u5c31\u662f parsing ,","title":"Introduction"},{"location":"Formal-language/Formal-grammar/wikipedia-Formal-grammar/#formal#grammar","text":"In formal language theory , a grammar (when the context is not given, often called a formal grammar for clarity) is a set of production rules for strings in a formal language . The rules describe how to form strings from the language's alphabet that are valid according to the language's syntax . A grammar does not describe the meaning of the strings or what can be done with them in whatever context\u2014only their form. NOTE: \u4e0d\u6d89\u53ca semantics A formal grammar is a set of rules for rewriting strings, along with a \"start symbol\" from which rewriting starts. Therefore, a grammar is usually thought of as a language generator . However, it can also sometimes be used as the basis for a \" recognizer \"\u2014a function in computing that determines whether a given string belongs to the language or is grammatically incorrect. To describe such recognizers , formal language theory uses separate formalisms, known as automata theory . One of the interesting results of automata theory is that it is not possible to design a recognizer for certain formal languages . Parsing is the process of recognizing an utterance (a string in natural languages) by breaking it down to a set of symbols and analyzing each one against the grammar of the language. Most languages have the meanings of their utterances structured according to their syntax \u2014a practice known as compositional semantics . As a result, the first step to describing the meaning of an utterance in language is to break it down part by part and look at its analyzed form (known as its parse tree in computer science, and as its deep structure in generative grammar ).","title":"Formal grammar"},{"location":"Formal-language/Formal-grammar/wikipedia-Formal-grammar/#formal#definition","text":"Main article: Unrestricted grammar","title":"Formal definition"},{"location":"Formal-language/Formal-grammar/wikipedia-Formal-grammar/#the#syntax#of#grammars","text":"NOTE: \u8fd9\u4e00\u6bb5\u662f\u63cf\u8ff0\u8bed\u6cd5\u7684\u8bed\u6cd5\uff0c\u5176\u5b9e\u5c31\u662f Metasyntax","title":"The syntax of grammars"},{"location":"Formal-language/Formal-grammar/wikipedia-Formal-grammar/#the#chomsky#hierarchy","text":"Main article: Chomsky hierarchy NOTE: Chomsky hierarchy \u5bf9formal grammar\u8fdb\u884c\u5206\u7c7b\u3002\u5728Chomsky-hierarchy\u7ae0\u8282\u5bf9\u5b83\u8fdb\u884c\u5206\u6790\u3002","title":"The Chomsky hierarchy"},{"location":"Formal-language/Formal-grammar/wikipedia-Formal-grammar/#analytic#grammars","text":"NOTE: \u5728compiler\u4e2d\uff0c\u5f80\u5f80\u662f\u57fa\u4e8egrammar\u6765\u5bf9language\uff08\u5176\u5b9e\u5c31\u662f\u6211\u4eec\u6240\u5199\u7684\u7a0b\u5e8f\uff09\u8fdb\u884c\u5206\u6790\uff0c\u8fd9\u4e2a\u8fc7\u7a0b\u5c31\u662f parsing ,","title":"Analytic grammars"},{"location":"Formal-language/Intermediate-language/","text":"Intermediate language \"Intermediate language\"\u5373\"\u4e2d\u95f4\u8bed\u8a00\"\u3002 Wikipedia Intermediate language In computer science , an intermediate language is the language of an abstract machine designed to aid in the analysis of computer programs . NOTE: \u9762\u5411\u8ba1\u7b97\u7684 The term comes from their use in compilers , where the source code of a program is translated into a form more suitable for code-improving transformations before being used to generate object or machine code for a target machine. A popular format for intermediate languages is three-address code . The term is also used to refer to languages used as intermediates by some high-level programming languages which do not output object or machine code themselves, but output the intermediate language only. This is usually done to ease the process of optimization or to increase portability by using an intermediate language that has compilers for many processors and operating systems , such as C . Languages used for this fall in complexity between high-level languages and low-level languages, such as assembly languages . Intermediate representation A canonical example is found in most modern compilers , where the linear human-readable text representing a program is transformed into an intermediate graph data structure that allows flow analysis and re-arrangements before starting to create the list of actual CPU instructions that will do the work. Use of an Intermediate representation allows compiler systems like GNU GCC and LLVM to be targeted by many different source languages, and support generation for many different target architectures. Case study NOTE: \u6e90\u81ea Wikipedia Intermediate language \u3002\u4e3b\u8981\u662f\u5728compiler\u4e2d\u5e94\u7528\u3002 Three-address code NOTE: \u6700\u6700\u6d41\u884c\u7684 C as intermediate language Though not explicitly designed as an intermediate language, C 's nature as an abstraction of assembly and its ubiquity as the de facto system language in Unix-like and other operating systems has made it a popular intermediate language: Eiffel , Sather , Esterel , some dialects of Lisp ( Lush , Gambit ), Haskell ( Glasgow Haskell Compiler ), Squeak 's Smalltalk-subset Slang, Cython , Seed7 , SystemTap , Vala , and others make use of C as an intermediate language. Language for VM Any language targeting a virtual machine can be considered an intermediate language: Java bytecode Microsoft's Common Intermediate Language is an intermediate language designed to be shared by all compilers for the .NET Framework , before static or dynamic compilation to machine code. While most intermediate languages are designed to support statically typed languages, the Parrot intermediate representation is designed to support dynamically typed languages\u2014initially Perl and Python. TIMI is a high level that targets the IBM System i platform. NOTE: \u4e0b\u9762\u662f\u4e00\u4e9b\u8865\u5145 Python bytecode sqlite bytecode GCC IR The GNU Compiler Collection (GCC) uses several intermediate languages internally to simplify portability and cross-compilation . Among these languages are the historical Register Transfer Language (RTL) the tree language GENERIC the SSA -based GIMPLE . Standard Portable Intermediate Representation SPIR/SPIR-V LLVM Intermediate Representation HSA Intermediate Layer LLVM IR The LLVM compiler framework is based on the LLVM IR intermediate language, which has been productized by Apple as \"bitcode\".[ 1] [ 2] Deep learning IR \u53c2\u89c1\u5de5\u7a0bmachine-learning\u7684 Theory\\Deep-learning\\Guide\\Compiler \u7ae0\u8282\u3002","title":"Introduction"},{"location":"Formal-language/Intermediate-language/#intermediate#language","text":"\"Intermediate language\"\u5373\"\u4e2d\u95f4\u8bed\u8a00\"\u3002","title":"Intermediate language"},{"location":"Formal-language/Intermediate-language/#wikipedia#intermediate#language","text":"In computer science , an intermediate language is the language of an abstract machine designed to aid in the analysis of computer programs . NOTE: \u9762\u5411\u8ba1\u7b97\u7684 The term comes from their use in compilers , where the source code of a program is translated into a form more suitable for code-improving transformations before being used to generate object or machine code for a target machine. A popular format for intermediate languages is three-address code . The term is also used to refer to languages used as intermediates by some high-level programming languages which do not output object or machine code themselves, but output the intermediate language only. This is usually done to ease the process of optimization or to increase portability by using an intermediate language that has compilers for many processors and operating systems , such as C . Languages used for this fall in complexity between high-level languages and low-level languages, such as assembly languages .","title":"Wikipedia Intermediate language"},{"location":"Formal-language/Intermediate-language/#intermediate#representation","text":"A canonical example is found in most modern compilers , where the linear human-readable text representing a program is transformed into an intermediate graph data structure that allows flow analysis and re-arrangements before starting to create the list of actual CPU instructions that will do the work. Use of an Intermediate representation allows compiler systems like GNU GCC and LLVM to be targeted by many different source languages, and support generation for many different target architectures.","title":"Intermediate representation"},{"location":"Formal-language/Intermediate-language/#case#study","text":"NOTE: \u6e90\u81ea Wikipedia Intermediate language \u3002\u4e3b\u8981\u662f\u5728compiler\u4e2d\u5e94\u7528\u3002","title":"Case study"},{"location":"Formal-language/Intermediate-language/#three-address#code","text":"NOTE: \u6700\u6700\u6d41\u884c\u7684","title":"Three-address code"},{"location":"Formal-language/Intermediate-language/#c#as#intermediate#language","text":"Though not explicitly designed as an intermediate language, C 's nature as an abstraction of assembly and its ubiquity as the de facto system language in Unix-like and other operating systems has made it a popular intermediate language: Eiffel , Sather , Esterel , some dialects of Lisp ( Lush , Gambit ), Haskell ( Glasgow Haskell Compiler ), Squeak 's Smalltalk-subset Slang, Cython , Seed7 , SystemTap , Vala , and others make use of C as an intermediate language.","title":"C as intermediate language"},{"location":"Formal-language/Intermediate-language/#language#for#vm","text":"Any language targeting a virtual machine can be considered an intermediate language: Java bytecode Microsoft's Common Intermediate Language is an intermediate language designed to be shared by all compilers for the .NET Framework , before static or dynamic compilation to machine code. While most intermediate languages are designed to support statically typed languages, the Parrot intermediate representation is designed to support dynamically typed languages\u2014initially Perl and Python. TIMI is a high level that targets the IBM System i platform. NOTE: \u4e0b\u9762\u662f\u4e00\u4e9b\u8865\u5145 Python bytecode sqlite bytecode","title":"Language for VM"},{"location":"Formal-language/Intermediate-language/#gcc#ir","text":"The GNU Compiler Collection (GCC) uses several intermediate languages internally to simplify portability and cross-compilation . Among these languages are the historical Register Transfer Language (RTL) the tree language GENERIC the SSA -based GIMPLE . Standard Portable Intermediate Representation SPIR/SPIR-V LLVM Intermediate Representation HSA Intermediate Layer","title":"GCC IR"},{"location":"Formal-language/Intermediate-language/#llvm#ir","text":"The LLVM compiler framework is based on the LLVM IR intermediate language, which has been productized by Apple as \"bitcode\".[ 1] [ 2]","title":"LLVM IR"},{"location":"Formal-language/Intermediate-language/#deep#learning#ir","text":"\u53c2\u89c1\u5de5\u7a0bmachine-learning\u7684 Theory\\Deep-learning\\Guide\\Compiler \u7ae0\u8282\u3002","title":"Deep learning IR"},{"location":"Formal-language/Summary-of-theory/","text":"\u68b3\u7406 Generating VS parsing \u6211\u4eec\u5df2\u7ecf\u77e5\u9053 formal grammars \u662f generative grammar \u3002 Generative grammar \uff1a generative grammar considers grammar as a system of rules that generates exactly those combinations of words that form grammatical sentences in a given language \u4e0a\u8ff0\u6240\u63cf\u8ff0\u7684\u662fgenerating\u8fc7\u7a0b\uff0c\u5373\u7ed9\u5b9agrammar\uff0c**\u751f\u6210**sentence in a given language\uff0c\u8fd9\u4e2a\u8fc7\u7a0b\u5176\u5b9e\u662f\u4e0d\u65ad\u5730\u4f7f\u7528grammar rule\u6765\u8fdb\u884c\u63a8\u5bfc\u7684\u3002 \u5b83\u7684\u53cd\u95ee\u9898\u662f\uff1a\u7ed9\u5b9asentence\uff0c\u5224\u65ad\u5b83\u662f\u5426\u7b26\u5408\u8fd9\u4e2a\u8bed\u8a00\u7684grammar\u3002\u8fd9\u5c31\u662f parsing \u3002 \u901a\u8fc7\u4e0a\u9762\u7684\u5206\u6790\u53ef\u4ee5\u770b\u51fa\uff0cgenerating\u548c parsing \u4e92\u4e3a\u53cd\u8fc7\u7a0b\u3002 \u4ece Mathematical logic \u7684\u89d2\u5ea6\u6765\u770b Formal grammars \u5982\u679c\u4ece Mathematical logic \u7684\u903b\u8f91\u63a8\u5bfc\u7684\u89d2\u5ea6\u6765\u770b\u5f85 Formal grammars \u7684\u8bdd\uff0c formal grammars \u7684\u5f88\u591a\u5185\u5bb9\u5c31\u53d8\u5f97\u975e\u5e38\u5bb9\u6613\u7406\u89e3\uff1a formal grammars \u53ef\u4ee5\u770b\u505a\u662f\u4e00\u4e2a formal system \u3002 \u4e0b\u9762\u603b\u7ed3\u4e86formal grammar\u4e2d\u7684\u4e00\u4e9b\u6982\u5ff5\u548cmathematical logic\u4e2d\u7684\u4e00\u4e9b\u6982\u5ff5\u4e4b\u95f4\u7684\u5bf9\u5e94\u5173\u7cfb\uff0c\u5982\u4e0b\uff1a Formal grammar \u7684\u6982\u5ff5 Mathematical logic \u7684\u6982\u5ff5 Production rule Formation rule \u3001 Rule of inference \u3001 Rewriting \u4e0a\u8ff0\u5bf9\u5e94\u5173\u7cfb\u7684\u542b\u4e49\u662f\uff1a\u5982\u679c\u4ece Mathematical logic \u6765\u770b\u5f85 Production rule \u7684\u8bdd\uff0c\u5b83\u5c31\u76f8\u5f53\u4e8e\u662f Formation rule \u3001 Rule of inference \u3001 Rewriting \u3002 \u6309\u7167\u516c\u5f0f\u8fdb\u884c\u63a8\u5bfc\u4ece\u53e6\u5916\u4e00\u4e2a\u89d2\u5ea6\u6765\u770b\u5176\u5b9e\u662f\u91cd\u5199\uff0c\u4e0d\u65ad\u5730\u8fdb\u884c\u66ff\u6362\uff0c\u611f\u89c9\u6570\u7406\u903b\u8f91\u672c\u8d28\u4e0a\u5c31\u662f\u8fd9\u4e2a\u4e1c\u897f\u3002\u4ece\u8fd9\u4e2a\u89d2\u5ea6\u6765\u770b\uff0cparsing\u7684\u8fc7\u7a0b\u5176\u5b9e\u5c31\u662f\u4e0d\u65ad\u7684\u63a8\u5bfc\u7684\u8fc7\u7a0b\uff0c\u4e0d\u65ad\u7684\u91cd\u5199\u7684\u8fc7\u7a0b\u3002\u7531\u4e8e\u53ef\u80fd\u7684\u63a8\u5bfc\u683c\u5f0f\u662f\u975e\u5e38\u591a\u7684\uff0c\u6240\u4ee5\u9700\u8981\u4e0d\u65ad\u5730\u8fdb\u884c\u5c1d\u8bd5\uff0c\u8fd9\u4e2a\u8fc7\u7a0b\u5176\u5b9e\u5c31\u662f search \u3001 backtracking \uff0c\u6240\u4ee5\u4ece\u8fd9\u4e2a\u89d2\u5ea6\u6765\u770b\uff0c parsing \u6240\u505a\u7684\u5de5\u4f5c\u5176\u5b9e\u5c31\u662f\u63a8\u5bfc\u52a0search\u3002\u81ea\u9876\u5411\u4e0b\u5176\u5b9e\u6240\u5bf9\u5e94\u7684\u662f\u6b63\u5411\u63a8\u5bfc\uff0c\u81ea\u5e95\u5411\u4e0a\u5176\u5b9e\u6240\u5bf9\u5e94\u7684\u5c31\u662f\u65b9\u5411\u63a8\u5bfc\u3002 NOTE: \u5728\u9f99\u4e66\u76844.2.3 Derivations\u6709\u8fd9\u6837\u7684\u63cf\u8ff0\uff1a The construction of a parse tree can be made precise by taking a derivational view , in which productions are treated as rewriting rules . Beginning with the start symbol, each rewriting step replaces a nonterminal by the body of one of its productions. This derivational view corresponds to the top-down construction of a parse tree, but the precision afforded by derivations will be especially helpful when bottom-up parsing is discussed. As we shall see, bottom-up parsing is related to a class of derivations known as \"rightmost\" derivations, in which the rightmost nonterminal is rewritten at each step. \u4e0a\u9762\u7684\u8fd9\u4e9b\u5185\u5bb9\u7ed9\u6211\u7684\u542f\u53d1\u662f\uff1a\u4e0d\u540c\u7684\u5b66\u79d1\u5bf9\u540c\u4e00\u4e8b\u7269\u7684\u547d\u540d\u53ef\u80fd\u4e0d\u540c\uff0c\u4f46\u662f\u5b83\u4eec\u672c\u8d28\u4e0a\u6240\u63cf\u8ff0\u7684\u662f\u540c\u4e00\u4e8b\u7269\u3002 \u5176\u5b9e\u4e0a\u8ff0\u6240\u6709\u8fd9\u4e9b\u8ba8\u8bba\uff0c\u672c\u8d28\u4e0a\u90fd\u662f\u5c5e\u4e8e Logic \u5b66\u7684\u8303\u8f74\uff0c\u63a8\u5bfc\uff08 inference \uff09\u5c31\u5c5e\u4e8e\u903b\u8f91\u5b66\u7684\u8303\u8f74\u3002 Formal system and formal language \u4e0b\u9762\u8fd9\u6bb5\u6458\u81ea Formal systems A formal system (also called a logical calculus , or a logical system ) consists of a formal language together with a deductive apparatus (also called a deductive system ). The deductive apparatus may consist of a set of transformation rules (also called inference rules ) or a set of axioms , or have both. A formal system is used to derive (\u63a8\u5bfc) one expression from one or more other expressions. Propositional and predicate calculi are examples of formal systems. Formal grammars \u76f8\u5f53\u4e8e deductive apparatus \u3002 Automata theory \u548c Formal language Chomsky hierarchy \u5c06 Automata theory \u548c formal language \u8fdb\u884c\u4e86\u5173\u8054\u548c\u5bf9\u5e94\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c Automata theory \u5728\u5176\u4ed6\u9886\u57df\u6709\u7740\u975e\u5e38\u5e7f\u6cdb\u7684\u5e94\u7528\u3002 Turing machine and Mathematical logic \u5728\u7b2c\u4e00\u6bb5\u7684NOTE\u4e2d\u5c31\u5bf9\u4e24\u8005\u8fdb\u884c\u4e86\u5206\u6790\u3002 \u9664\u6b64\u4e4b\u5916\uff0c\u4e0b\u9762\u6587\u7ae0\u4e5f\u662f\u503c\u5f97\u9605\u8bfb\u7684\uff1a Automated theorem proving Formal methods","title":"Introduction"},{"location":"Formal-language/Summary-of-theory/#_1","text":"","title":"\u68b3\u7406"},{"location":"Formal-language/Summary-of-theory/#generating#vs#parsing","text":"\u6211\u4eec\u5df2\u7ecf\u77e5\u9053 formal grammars \u662f generative grammar \u3002 Generative grammar \uff1a generative grammar considers grammar as a system of rules that generates exactly those combinations of words that form grammatical sentences in a given language \u4e0a\u8ff0\u6240\u63cf\u8ff0\u7684\u662fgenerating\u8fc7\u7a0b\uff0c\u5373\u7ed9\u5b9agrammar\uff0c**\u751f\u6210**sentence in a given language\uff0c\u8fd9\u4e2a\u8fc7\u7a0b\u5176\u5b9e\u662f\u4e0d\u65ad\u5730\u4f7f\u7528grammar rule\u6765\u8fdb\u884c\u63a8\u5bfc\u7684\u3002 \u5b83\u7684\u53cd\u95ee\u9898\u662f\uff1a\u7ed9\u5b9asentence\uff0c\u5224\u65ad\u5b83\u662f\u5426\u7b26\u5408\u8fd9\u4e2a\u8bed\u8a00\u7684grammar\u3002\u8fd9\u5c31\u662f parsing \u3002 \u901a\u8fc7\u4e0a\u9762\u7684\u5206\u6790\u53ef\u4ee5\u770b\u51fa\uff0cgenerating\u548c parsing \u4e92\u4e3a\u53cd\u8fc7\u7a0b\u3002","title":"Generating VS parsing"},{"location":"Formal-language/Summary-of-theory/#mathematical#logicformal#grammars","text":"\u5982\u679c\u4ece Mathematical logic \u7684\u903b\u8f91\u63a8\u5bfc\u7684\u89d2\u5ea6\u6765\u770b\u5f85 Formal grammars \u7684\u8bdd\uff0c formal grammars \u7684\u5f88\u591a\u5185\u5bb9\u5c31\u53d8\u5f97\u975e\u5e38\u5bb9\u6613\u7406\u89e3\uff1a formal grammars \u53ef\u4ee5\u770b\u505a\u662f\u4e00\u4e2a formal system \u3002 \u4e0b\u9762\u603b\u7ed3\u4e86formal grammar\u4e2d\u7684\u4e00\u4e9b\u6982\u5ff5\u548cmathematical logic\u4e2d\u7684\u4e00\u4e9b\u6982\u5ff5\u4e4b\u95f4\u7684\u5bf9\u5e94\u5173\u7cfb\uff0c\u5982\u4e0b\uff1a Formal grammar \u7684\u6982\u5ff5 Mathematical logic \u7684\u6982\u5ff5 Production rule Formation rule \u3001 Rule of inference \u3001 Rewriting \u4e0a\u8ff0\u5bf9\u5e94\u5173\u7cfb\u7684\u542b\u4e49\u662f\uff1a\u5982\u679c\u4ece Mathematical logic \u6765\u770b\u5f85 Production rule \u7684\u8bdd\uff0c\u5b83\u5c31\u76f8\u5f53\u4e8e\u662f Formation rule \u3001 Rule of inference \u3001 Rewriting \u3002 \u6309\u7167\u516c\u5f0f\u8fdb\u884c\u63a8\u5bfc\u4ece\u53e6\u5916\u4e00\u4e2a\u89d2\u5ea6\u6765\u770b\u5176\u5b9e\u662f\u91cd\u5199\uff0c\u4e0d\u65ad\u5730\u8fdb\u884c\u66ff\u6362\uff0c\u611f\u89c9\u6570\u7406\u903b\u8f91\u672c\u8d28\u4e0a\u5c31\u662f\u8fd9\u4e2a\u4e1c\u897f\u3002\u4ece\u8fd9\u4e2a\u89d2\u5ea6\u6765\u770b\uff0cparsing\u7684\u8fc7\u7a0b\u5176\u5b9e\u5c31\u662f\u4e0d\u65ad\u7684\u63a8\u5bfc\u7684\u8fc7\u7a0b\uff0c\u4e0d\u65ad\u7684\u91cd\u5199\u7684\u8fc7\u7a0b\u3002\u7531\u4e8e\u53ef\u80fd\u7684\u63a8\u5bfc\u683c\u5f0f\u662f\u975e\u5e38\u591a\u7684\uff0c\u6240\u4ee5\u9700\u8981\u4e0d\u65ad\u5730\u8fdb\u884c\u5c1d\u8bd5\uff0c\u8fd9\u4e2a\u8fc7\u7a0b\u5176\u5b9e\u5c31\u662f search \u3001 backtracking \uff0c\u6240\u4ee5\u4ece\u8fd9\u4e2a\u89d2\u5ea6\u6765\u770b\uff0c parsing \u6240\u505a\u7684\u5de5\u4f5c\u5176\u5b9e\u5c31\u662f\u63a8\u5bfc\u52a0search\u3002\u81ea\u9876\u5411\u4e0b\u5176\u5b9e\u6240\u5bf9\u5e94\u7684\u662f\u6b63\u5411\u63a8\u5bfc\uff0c\u81ea\u5e95\u5411\u4e0a\u5176\u5b9e\u6240\u5bf9\u5e94\u7684\u5c31\u662f\u65b9\u5411\u63a8\u5bfc\u3002 NOTE: \u5728\u9f99\u4e66\u76844.2.3 Derivations\u6709\u8fd9\u6837\u7684\u63cf\u8ff0\uff1a The construction of a parse tree can be made precise by taking a derivational view , in which productions are treated as rewriting rules . Beginning with the start symbol, each rewriting step replaces a nonterminal by the body of one of its productions. This derivational view corresponds to the top-down construction of a parse tree, but the precision afforded by derivations will be especially helpful when bottom-up parsing is discussed. As we shall see, bottom-up parsing is related to a class of derivations known as \"rightmost\" derivations, in which the rightmost nonterminal is rewritten at each step. \u4e0a\u9762\u7684\u8fd9\u4e9b\u5185\u5bb9\u7ed9\u6211\u7684\u542f\u53d1\u662f\uff1a\u4e0d\u540c\u7684\u5b66\u79d1\u5bf9\u540c\u4e00\u4e8b\u7269\u7684\u547d\u540d\u53ef\u80fd\u4e0d\u540c\uff0c\u4f46\u662f\u5b83\u4eec\u672c\u8d28\u4e0a\u6240\u63cf\u8ff0\u7684\u662f\u540c\u4e00\u4e8b\u7269\u3002 \u5176\u5b9e\u4e0a\u8ff0\u6240\u6709\u8fd9\u4e9b\u8ba8\u8bba\uff0c\u672c\u8d28\u4e0a\u90fd\u662f\u5c5e\u4e8e Logic \u5b66\u7684\u8303\u8f74\uff0c\u63a8\u5bfc\uff08 inference \uff09\u5c31\u5c5e\u4e8e\u903b\u8f91\u5b66\u7684\u8303\u8f74\u3002","title":"\u4eceMathematical logic\u7684\u89d2\u5ea6\u6765\u770bFormal grammars"},{"location":"Formal-language/Summary-of-theory/#formal#system#and#formal#language","text":"\u4e0b\u9762\u8fd9\u6bb5\u6458\u81ea Formal systems A formal system (also called a logical calculus , or a logical system ) consists of a formal language together with a deductive apparatus (also called a deductive system ). The deductive apparatus may consist of a set of transformation rules (also called inference rules ) or a set of axioms , or have both. A formal system is used to derive (\u63a8\u5bfc) one expression from one or more other expressions. Propositional and predicate calculi are examples of formal systems. Formal grammars \u76f8\u5f53\u4e8e deductive apparatus \u3002","title":"Formal system and formal language"},{"location":"Formal-language/Summary-of-theory/#automata#theoryformal#language","text":"Chomsky hierarchy \u5c06 Automata theory \u548c formal language \u8fdb\u884c\u4e86\u5173\u8054\u548c\u5bf9\u5e94\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c Automata theory \u5728\u5176\u4ed6\u9886\u57df\u6709\u7740\u975e\u5e38\u5e7f\u6cdb\u7684\u5e94\u7528\u3002","title":"Automata theory\u548cFormal language"},{"location":"Formal-language/Summary-of-theory/#turing#machine#and#mathematical#logic","text":"\u5728\u7b2c\u4e00\u6bb5\u7684NOTE\u4e2d\u5c31\u5bf9\u4e24\u8005\u8fdb\u884c\u4e86\u5206\u6790\u3002 \u9664\u6b64\u4e4b\u5916\uff0c\u4e0b\u9762\u6587\u7ae0\u4e5f\u662f\u503c\u5f97\u9605\u8bfb\u7684\uff1a Automated theorem proving Formal methods","title":"Turing machine and Mathematical logic"},{"location":"Formal-language/draft/Formal-Languages%26Grammars%26Automata-thinking/","text":"application of state machine [uses for state machines closed] The Rise Of The State Machines Understanding State Machines Finite-state machine regex engine and automata https://www.regular-expressions.info/engine.html : While there are many implementations of regular expressions that differ sometimes slightly and sometimes significantly in syntax and behavior, there are basically only two kinds of regular expression engines: text-directed engines, and regex-directed engines. Nearly all modern regex flavors are based on regex-directed engines. This is because certain very useful features, such as lazy quantifiers and backreferences, can only be implemented in regex-directed engines. regex-directed engines vs Syntax-directed translation state machine vs automata state machine\u662f\u4e00\u79cdautomata","title":"application of state machine"},{"location":"Formal-language/draft/Formal-Languages%26Grammars%26Automata-thinking/#application#of#state#machine","text":"","title":"application of state machine"},{"location":"Formal-language/draft/Formal-Languages%26Grammars%26Automata-thinking/#uses#for#state#machines#closed","text":"","title":"[uses for state machines closed]"},{"location":"Formal-language/draft/Formal-Languages%26Grammars%26Automata-thinking/#the#rise#of#the#state#machines","text":"","title":"The Rise Of The State Machines"},{"location":"Formal-language/draft/Formal-Languages%26Grammars%26Automata-thinking/#understanding#state#machines","text":"","title":"Understanding State Machines"},{"location":"Formal-language/draft/Formal-Languages%26Grammars%26Automata-thinking/#finite-state#machine","text":"","title":"Finite-state machine"},{"location":"Formal-language/draft/Formal-Languages%26Grammars%26Automata-thinking/#regex#engine#and#automata","text":"https://www.regular-expressions.info/engine.html : While there are many implementations of regular expressions that differ sometimes slightly and sometimes significantly in syntax and behavior, there are basically only two kinds of regular expression engines: text-directed engines, and regex-directed engines. Nearly all modern regex flavors are based on regex-directed engines. This is because certain very useful features, such as lazy quantifiers and backreferences, can only be implemented in regex-directed engines.","title":"regex engine and automata"},{"location":"Formal-language/draft/Formal-Languages%26Grammars%26Automata-thinking/#regex-directed#engines#vs#syntax-directed#translation","text":"","title":"regex-directed engines vs Syntax-directed translation"},{"location":"Formal-language/draft/Formal-Languages%26Grammars%26Automata-thinking/#state#machine#vs#automata","text":"state machine\u662f\u4e00\u79cdautomata","title":"state machine vs automata"},{"location":"Formal-language/wikipedia-Formal-language/","text":"wikipedia Formal language NOTE: \u5145\u5206\u7406\u89e3\u672c\u6587\u7684\u524d\u63d0\u662f\u5bf9 Mathematical logic \u6709\u57fa\u672c\u7684\u8ba4\u77e5\uff0c\u53c2\u89c1\u4e0a\u4e00\u7ae0\u8282\u3002 In mathematics , computer science , and linguistics , a formal language consists of words whose letters are taken from an alphabet and are well-formed according to a specific set of rules. The alphabet of a formal language consist of symbols, letters, or tokens that concatenate into strings of the language. Each string concatenated from symbols of this alphabet is called a word , and the words that belong to a particular formal language are sometimes called well-formed words or well-formed formulas . A formal language is often defined by means of a formal grammar such as a regular grammar or context-free grammar , which consists of its formation rules . The field of formal language theory studies primarily the purely syntactical \uff08\u8bed\u6cd5\uff09 aspects of such languages\u2014that is, their internal structural patterns . Formal language theory sprang out of linguistics, as a way of understanding the syntactic regularities\uff08\u89c4\u5f8b\uff09 of natural languages . In computer science, formal languages are used among others as the basis for defining the grammar of programming languages and formalized versions of subsets of natural languages in which the words of the language represent concepts that are associated with particular meanings or semantics \uff08\u8bed\u4e49\uff09. In computational complexity theory , decision problems are typically defined as formal languages , and complexity classes are defined as the sets of the formal languages that can be parsed by machines with limited computational power. In logic and the foundations of mathematics , formal languages are used to represent the syntax of axiomatic systems , and mathematical formalism is the philosophy that all of mathematics can be reduced to the syntactic manipulation of formal languages in this way. NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u7684\u7b2c\u4e00\u53e5\u8bdd\u63ed\u793a\u4e86 formal language \u548c logic \u4e4b\u95f4\u7684\u5173\u7cfb\u3002 NOTE: \u6700\u540e\u4e00\u6bb5\u8bdd\u7684\u610f\u601d\u662f\uff1a mathematical formalism \u7684\u601d\u60f3\u662f\uff1a\u6240\u6709\u7684\u6570\u5b66\u90fd\u53ef\u4ee5\u901a\u8fc7\u8fd9\u79cd\u65b9\u5f0f\u7b80\u5316\u4e3aformal language\u7684syntactic manipulation\u3002\u6d4f\u89c8\u4e86\u4e00\u4e0b\u8fd9\u7bc7\u6587\u7ae0\uff0c\u53d1\u73b0 theory of computation \u4e2d\u7684\u5f88\u591a\u8bfe\u9898\u90fd\u6e90\u4e8e\u8fd9\u4e2a\u601d\u60f3\uff0c\u6bd4\u5982 Turing machine \u3002 Words over an alphabet An alphabet , in the context of formal languages, can be any set , although it often makes sense to use an alphabet in the usual sense of the word, or more generally a character set such as ASCII or Unicode . The elements of an alphabet are called its letters . An alphabet may contain an infinite number of elements; however, most definitions in formal language theory specify alphabets with a finite number of elements, and most results apply only to them. A word over an alphabet can be any finite sequence (i.e., string ) of letters. The set of all words over an alphabet \u03a3 is usually denoted by \u03a3* (using the Kleene star ). The length of a word is the number of letters it is composed of. For any alphabet, there is only one word of length 0, the empty word , which is often denoted by e, \u03b5, \u03bb or even \u039b. By concatenation one can combine two words to form a new word, whose length is the sum of the lengths of the original words. The result of concatenating a word with the empty word is the original word. In some applications, especially in logic , the alphabet is also known as the vocabulary and words are known as formulas or sentences ; this breaks the letter/word metaphor and replaces it by a word/sentence metaphor. NOTE: \u5728formal language\u7406\u8bba\u4e2d\uff0c alphabet \u3001 character set \u3001vocabulary\u53ef\u4ee5\u8ba4\u4e3a\u662f\u540c\u4e49\u8bcd\u3002 Definition A formal language L over an alphabet \u03a3 is a subset of \u03a3*, that is, a set of words over that alphabet. Sometimes the sets of words are grouped into expressions, whereas rules and constraints may be formulated for the creation of 'well-formed expressions'. NOTE: \u6240\u8c13\u7684rules\u5176\u5b9e\u5c31\u662fgrammar\u3002 In computer science and mathematics, which do not usually deal with natural languages , the adjective \"formal\" is often omitted as redundant. NOTE: \u6309\u7167\u8fd9\u4e2a\u8bf4\u6cd5\uff0cprogramming language\u7684\u66f4\u52a0\u4e25\u8c28\u7684\u8bf4\u6cd5\u662f\uff1aprogramming formal language\u3002 While formal language theory usually concerns itself with formal languages that are described by some syntactical rules, the actual definition of the concept \"formal language\" is only as above: a (possibly infinite) set of finite-length strings composed from a given alphabet, no more and no less. In practice, there are many languages that can be described by rules , such as regular languages or context-free languages . The notion of a formal grammar may be closer to the intuitive concept of a \"language,\" one described by syntactic rules. By an abuse of the definition, a particular formal language is often thought of as being equipped with a formal grammar that describes it. NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u6240\u5f3a\u8c03\u7684\u662fformal language\u7684\u51c6\u786e\u5b9a\u4e49\u4e2d\u662f\u4e0d\u5305\u542brules\uff08grammar\uff09\u7684\u3002\u4f46\u662f\u5b9e\u9645\u4e2d\uff0c\u8981\u60f3\u51c6\u786e\u7684\u5b9a\u4e49\u4e00\u95e8\u8bed\u8a00\u662f\u79bb\u4e0d\u5f00rules\u7684\u3002\u4ee5programming language\u4e3a\u4f8b\u7684\u8bdd\uff0c\u5b83\u9700\u8981\u8bcd\u6cd5\u548c\u8bed\u6cd5\u624d\u80fd\u591f\u6b63\u786e\u5730\u63cf\u8ff0\u8be5\u8bed\u8a00\u3002 Constructions For finite languages, one can explicitly enumerate all well-formed words. For example, we can describe a language L as just L = {a,\u2009b,\u2009ab,\u2009cba}. The degenerate case of this construction is the empty language , which contains no words at all ( L = \u2205 ). However, even over a finite (non-empty) alphabet such as \u03a3 = {a, b} there are an infinite number of finite-length words that can potentially be expressed: \"a\", \"abb\", \"ababba\", \"aaababbbbaab\", .... Therefore, formal languages are typically infinite, and describing an infinite formal language is not as simple as writing L = {a,\u2009b,\u2009ab,\u2009cba}. Here are some examples of formal languages: L = \u03a3*, the set of all words over \u03a3; L = \\{a\\}^* = {a^n} L = \\{a\\}^* = {a^n} , where n ranges over the natural numbers and \" a^n a^n \" means \"a\" repeated n times (this is the set of words consisting only of the symbol \"a\"); the set of syntactically correct programs in a given programming language (the syntax of which is usually defined by a context-free grammar ); the set of inputs upon which a certain Turing machine halts; or the set of maximal strings of alphanumeric ASCII characters on this line, i.e., the set {the, set, of, maximal, strings, alphanumeric, ASCII, characters, on, this, line, i, e}. Language-specification formalisms Formal languages are used as tools in multiple disciplines. However, formal language theory rarely concerns itself with particular languages (except as examples), but is mainly concerned with the study of various types of formalisms to describe languages. For instance, a language can be given as those strings generated by some formal grammar ; those strings described or matched by a particular regular expression ; those strings accepted by some automaton , such as a Turing machine or finite-state automaton ; those strings for which some decision procedure (an algorithm that asks a sequence of related YES/NO questions) produces the answer YES. Typical questions asked about such formalisms include: What is their expressive power? (Can formalism X describe every language that formalism Y can describe? Can it describe other languages?) What is their recognizability? (How difficult is it to decide whether a given word belongs to a language described by formalism X ?) What is their comparability? (How difficult is it to decide whether two languages, one described in formalism X and one in formalism Y , or in X again, are actually the same language?). Surprisingly often, the answer to these decision problems is \"it cannot be done at all\", or \"it is extremely expensive\" (with a characterization of how expensive). Therefore, formal language theory is a major application area of computability theory and complexity theory . Formal languages may be classified in the Chomsky hierarchy based on the expressive power of their generative grammar as well as the complexity of their recognizing automaton . Context-free grammars and regular grammars provide a good compromise between expressivity and ease of parsing , and are widely used in practical applications. Operations on languages Applications Programming languages Main articles: Compiler compiler and Syntax (programming languages) Formal theories, systems, and proofs","title":"Introduction"},{"location":"Formal-language/wikipedia-Formal-language/#wikipedia#formal#language","text":"NOTE: \u5145\u5206\u7406\u89e3\u672c\u6587\u7684\u524d\u63d0\u662f\u5bf9 Mathematical logic \u6709\u57fa\u672c\u7684\u8ba4\u77e5\uff0c\u53c2\u89c1\u4e0a\u4e00\u7ae0\u8282\u3002 In mathematics , computer science , and linguistics , a formal language consists of words whose letters are taken from an alphabet and are well-formed according to a specific set of rules. The alphabet of a formal language consist of symbols, letters, or tokens that concatenate into strings of the language. Each string concatenated from symbols of this alphabet is called a word , and the words that belong to a particular formal language are sometimes called well-formed words or well-formed formulas . A formal language is often defined by means of a formal grammar such as a regular grammar or context-free grammar , which consists of its formation rules . The field of formal language theory studies primarily the purely syntactical \uff08\u8bed\u6cd5\uff09 aspects of such languages\u2014that is, their internal structural patterns . Formal language theory sprang out of linguistics, as a way of understanding the syntactic regularities\uff08\u89c4\u5f8b\uff09 of natural languages . In computer science, formal languages are used among others as the basis for defining the grammar of programming languages and formalized versions of subsets of natural languages in which the words of the language represent concepts that are associated with particular meanings or semantics \uff08\u8bed\u4e49\uff09. In computational complexity theory , decision problems are typically defined as formal languages , and complexity classes are defined as the sets of the formal languages that can be parsed by machines with limited computational power. In logic and the foundations of mathematics , formal languages are used to represent the syntax of axiomatic systems , and mathematical formalism is the philosophy that all of mathematics can be reduced to the syntactic manipulation of formal languages in this way. NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u7684\u7b2c\u4e00\u53e5\u8bdd\u63ed\u793a\u4e86 formal language \u548c logic \u4e4b\u95f4\u7684\u5173\u7cfb\u3002 NOTE: \u6700\u540e\u4e00\u6bb5\u8bdd\u7684\u610f\u601d\u662f\uff1a mathematical formalism \u7684\u601d\u60f3\u662f\uff1a\u6240\u6709\u7684\u6570\u5b66\u90fd\u53ef\u4ee5\u901a\u8fc7\u8fd9\u79cd\u65b9\u5f0f\u7b80\u5316\u4e3aformal language\u7684syntactic manipulation\u3002\u6d4f\u89c8\u4e86\u4e00\u4e0b\u8fd9\u7bc7\u6587\u7ae0\uff0c\u53d1\u73b0 theory of computation \u4e2d\u7684\u5f88\u591a\u8bfe\u9898\u90fd\u6e90\u4e8e\u8fd9\u4e2a\u601d\u60f3\uff0c\u6bd4\u5982 Turing machine \u3002","title":"wikipedia Formal language"},{"location":"Formal-language/wikipedia-Formal-language/#words#over#an#alphabet","text":"An alphabet , in the context of formal languages, can be any set , although it often makes sense to use an alphabet in the usual sense of the word, or more generally a character set such as ASCII or Unicode . The elements of an alphabet are called its letters . An alphabet may contain an infinite number of elements; however, most definitions in formal language theory specify alphabets with a finite number of elements, and most results apply only to them. A word over an alphabet can be any finite sequence (i.e., string ) of letters. The set of all words over an alphabet \u03a3 is usually denoted by \u03a3* (using the Kleene star ). The length of a word is the number of letters it is composed of. For any alphabet, there is only one word of length 0, the empty word , which is often denoted by e, \u03b5, \u03bb or even \u039b. By concatenation one can combine two words to form a new word, whose length is the sum of the lengths of the original words. The result of concatenating a word with the empty word is the original word. In some applications, especially in logic , the alphabet is also known as the vocabulary and words are known as formulas or sentences ; this breaks the letter/word metaphor and replaces it by a word/sentence metaphor. NOTE: \u5728formal language\u7406\u8bba\u4e2d\uff0c alphabet \u3001 character set \u3001vocabulary\u53ef\u4ee5\u8ba4\u4e3a\u662f\u540c\u4e49\u8bcd\u3002","title":"Words over an alphabet"},{"location":"Formal-language/wikipedia-Formal-language/#definition","text":"A formal language L over an alphabet \u03a3 is a subset of \u03a3*, that is, a set of words over that alphabet. Sometimes the sets of words are grouped into expressions, whereas rules and constraints may be formulated for the creation of 'well-formed expressions'. NOTE: \u6240\u8c13\u7684rules\u5176\u5b9e\u5c31\u662fgrammar\u3002 In computer science and mathematics, which do not usually deal with natural languages , the adjective \"formal\" is often omitted as redundant. NOTE: \u6309\u7167\u8fd9\u4e2a\u8bf4\u6cd5\uff0cprogramming language\u7684\u66f4\u52a0\u4e25\u8c28\u7684\u8bf4\u6cd5\u662f\uff1aprogramming formal language\u3002 While formal language theory usually concerns itself with formal languages that are described by some syntactical rules, the actual definition of the concept \"formal language\" is only as above: a (possibly infinite) set of finite-length strings composed from a given alphabet, no more and no less. In practice, there are many languages that can be described by rules , such as regular languages or context-free languages . The notion of a formal grammar may be closer to the intuitive concept of a \"language,\" one described by syntactic rules. By an abuse of the definition, a particular formal language is often thought of as being equipped with a formal grammar that describes it. NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u6240\u5f3a\u8c03\u7684\u662fformal language\u7684\u51c6\u786e\u5b9a\u4e49\u4e2d\u662f\u4e0d\u5305\u542brules\uff08grammar\uff09\u7684\u3002\u4f46\u662f\u5b9e\u9645\u4e2d\uff0c\u8981\u60f3\u51c6\u786e\u7684\u5b9a\u4e49\u4e00\u95e8\u8bed\u8a00\u662f\u79bb\u4e0d\u5f00rules\u7684\u3002\u4ee5programming language\u4e3a\u4f8b\u7684\u8bdd\uff0c\u5b83\u9700\u8981\u8bcd\u6cd5\u548c\u8bed\u6cd5\u624d\u80fd\u591f\u6b63\u786e\u5730\u63cf\u8ff0\u8be5\u8bed\u8a00\u3002","title":"Definition"},{"location":"Formal-language/wikipedia-Formal-language/#constructions","text":"For finite languages, one can explicitly enumerate all well-formed words. For example, we can describe a language L as just L = {a,\u2009b,\u2009ab,\u2009cba}. The degenerate case of this construction is the empty language , which contains no words at all ( L = \u2205 ). However, even over a finite (non-empty) alphabet such as \u03a3 = {a, b} there are an infinite number of finite-length words that can potentially be expressed: \"a\", \"abb\", \"ababba\", \"aaababbbbaab\", .... Therefore, formal languages are typically infinite, and describing an infinite formal language is not as simple as writing L = {a,\u2009b,\u2009ab,\u2009cba}. Here are some examples of formal languages: L = \u03a3*, the set of all words over \u03a3; L = \\{a\\}^* = {a^n} L = \\{a\\}^* = {a^n} , where n ranges over the natural numbers and \" a^n a^n \" means \"a\" repeated n times (this is the set of words consisting only of the symbol \"a\"); the set of syntactically correct programs in a given programming language (the syntax of which is usually defined by a context-free grammar ); the set of inputs upon which a certain Turing machine halts; or the set of maximal strings of alphanumeric ASCII characters on this line, i.e., the set {the, set, of, maximal, strings, alphanumeric, ASCII, characters, on, this, line, i, e}.","title":"Constructions"},{"location":"Formal-language/wikipedia-Formal-language/#language-specification#formalisms","text":"Formal languages are used as tools in multiple disciplines. However, formal language theory rarely concerns itself with particular languages (except as examples), but is mainly concerned with the study of various types of formalisms to describe languages. For instance, a language can be given as those strings generated by some formal grammar ; those strings described or matched by a particular regular expression ; those strings accepted by some automaton , such as a Turing machine or finite-state automaton ; those strings for which some decision procedure (an algorithm that asks a sequence of related YES/NO questions) produces the answer YES. Typical questions asked about such formalisms include: What is their expressive power? (Can formalism X describe every language that formalism Y can describe? Can it describe other languages?) What is their recognizability? (How difficult is it to decide whether a given word belongs to a language described by formalism X ?) What is their comparability? (How difficult is it to decide whether two languages, one described in formalism X and one in formalism Y , or in X again, are actually the same language?). Surprisingly often, the answer to these decision problems is \"it cannot be done at all\", or \"it is extremely expensive\" (with a characterization of how expensive). Therefore, formal language theory is a major application area of computability theory and complexity theory . Formal languages may be classified in the Chomsky hierarchy based on the expressive power of their generative grammar as well as the complexity of their recognizing automaton . Context-free grammars and regular grammars provide a good compromise between expressivity and ease of parsing , and are widely used in practical applications.","title":"Language-specification formalisms"},{"location":"Formal-language/wikipedia-Formal-language/#operations#on#languages","text":"","title":"Operations on languages"},{"location":"Formal-language/wikipedia-Formal-language/#applications","text":"","title":"Applications"},{"location":"Formal-language/wikipedia-Formal-language/#programming#languages","text":"Main articles: Compiler compiler and Syntax (programming languages)","title":"Programming languages"},{"location":"Formal-language/wikipedia-Formal-language/#formal#theories#systems#and#proofs","text":"","title":"Formal theories, systems, and proofs"},{"location":"Formal-language-processing/","text":"\u5173\u4e8e\u672c\u7ae0 Application 1) \u5de5\u7a0b Parallel-computing\u7684 Application\\Parallel-numeric-processing-system \u7ae0\u8282\u3002 2) \u5de5\u7a0bDB\u7684: Implementation\\SQL-compiler \u7ae0\u8282 SQLite\\doc\\Technical-and-Design-Documentation\\Architecture-of-SQLite \u7ae0\u8282 3) \u5de5\u7a0bmachine-learning\u7684 Programming\\TensorFlow\\Implementation \u7ae0\u8282 TODO -- sqlite\u662f\u5982\u4f55\u6839\u636eAST\u6765\u751f\u6210command\u7684\uff1f \u53ef\u4ee5\u4eceIR\u6765\u8fdb\u884c\u5206\u6790\u3002 -- TensorFlow\u7684\u53ef\u6269\u5c55\u6027\u548csqlite\u7684\u53ef\u6269\u5c55\u6027\u662f\u975e\u5e38\u7c7b\u4f3c\u7684\uff0c\u8981\u8fdb\u884c\u603b\u7ed3\uff1b\u5173\u4e8eTensorFlow\u7684\u53ef\u6269\u5c55\u6027\uff0c\u5728TensorFlow whitepaper\u7684devices and worker process\u7ae0\u8282\u4e2d\u8fdb\u884c\u4e86\u8bf4\u660e\u3002","title":"Introduction"},{"location":"Formal-language-processing/#_1","text":"","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Formal-language-processing/#application","text":"1) \u5de5\u7a0b Parallel-computing\u7684 Application\\Parallel-numeric-processing-system \u7ae0\u8282\u3002 2) \u5de5\u7a0bDB\u7684: Implementation\\SQL-compiler \u7ae0\u8282 SQLite\\doc\\Technical-and-Design-Documentation\\Architecture-of-SQLite \u7ae0\u8282 3) \u5de5\u7a0bmachine-learning\u7684 Programming\\TensorFlow\\Implementation \u7ae0\u8282","title":"Application"},{"location":"Formal-language-processing/#todo","text":"-- sqlite\u662f\u5982\u4f55\u6839\u636eAST\u6765\u751f\u6210command\u7684\uff1f \u53ef\u4ee5\u4eceIR\u6765\u8fdb\u884c\u5206\u6790\u3002 -- TensorFlow\u7684\u53ef\u6269\u5c55\u6027\u548csqlite\u7684\u53ef\u6269\u5c55\u6027\u662f\u975e\u5e38\u7c7b\u4f3c\u7684\uff0c\u8981\u8fdb\u884c\u603b\u7ed3\uff1b\u5173\u4e8eTensorFlow\u7684\u53ef\u6269\u5c55\u6027\uff0c\u5728TensorFlow whitepaper\u7684devices and worker process\u7ae0\u8282\u4e2d\u8fdb\u884c\u4e86\u8bf4\u660e\u3002","title":"TODO"},{"location":"Formal-language-processing/Formal-language-processor/","text":"Formal language processor \u8ba8\u8bbalanguage processor\u7684\u5b9e\u73b0\u3002 \u4ee5\u4e0b\u9762\u4e09\u79cdimplementation\u4e3a\u4f8b\u6765\u8fdb\u884c\u8bf4\u660e: \u7ae0\u8282 sqlite \u5de5\u7a0bDB\u7684 Implementation\\SQLite\\doc\\Technical-and-Design-Documentation\\Architecture-of-SQLite \u7ae0\u8282 clang \u5de5\u7a0b programming-language \u7684 C-family-language\\C-and-C++\\From-source-code-to-exec\\Compile\\Implementation\\LLVM\\Clang \u7ae0\u8282 Python \u5de5\u7a0b programming-language \u7684 Python \u7ae0\u8282 \u5c42\u6b21\u5316\u7ed3\u6784 \u4e00\u822c\uff0cformal language processor\u90fd\u662f\u91c7\u7528\u7684**\u5c42\u6b21\u5316\u7ed3\u6784** \u5728\u5de5\u7a0bcompiler-principle\u4e2d\u4e5f\u6709\u5173\u4e8e**\u5c42\u6b21\u5316\u7ed3\u6784**\u7684\u8ba8\u8bba TODO: \u5173\u4e8eclang\u7684\u67b6\u6784\u4e2d\u4e2d\u95f4\u8868\u793a\u7684\u91cd\u8981\u610f\u4e49\uff0c\u53c2\u89c1\u9f99\u4e66chapter6\u7684\u7b2c\u4e00\u6bb5\u3002 \u5982\u4f55\u63cf\u8ff0\u4e4b\u95f4\u8868\u793a\uff1fASDL\u662f\u4e00\u79cd\u65b9\u5f0f \u4e2d\u95f4\u8868\u793a \u4e0d\u540c\u5c42\u6b21\u4e4b\u95f4\u9700\u8981\u4f7f\u7528**\u4e2d\u95f4\u8868\u793a** Interpreter/VM and hook function Interpreter/VM \u6267\u884c bytecode\uff0cbytecode \u6709 Interpreter/VM \u6765\u8fdb\u884c\u6267\u884c\uff0cbytecode\u7684\u4e00\u4e9boperation\u5f80\u5f80\u5bf9\u5e94\u4e8e\u4e00\u4e2afunction\u3002\u4e3a\u4e86\u652f\u6301\u53ef\u6269\u5c55\uff0c\u4e00\u822c\u90fd\u652f\u6301user defined hook function\u3002 Python \u548c sqlite\u90fd\u662f\u5178\u578b\u7684\u57fa\u4e8einterpreter\u7684\uff0c\u5b83\u4eec\u7684interpreter/virtual machine\u652f\u6301\u6267\u884chook function: \u6ce8\u89e3 Python 3. Data model \u00b6 sqlite sqlite virtual table: The Virtual Table Mechanism Of SQLite \u6211\u4eec\u5c06\u6b64\u79f0\u4e3ainterpreter model\u3002","title":"Introduction"},{"location":"Formal-language-processing/Formal-language-processor/#formal#language#processor","text":"\u8ba8\u8bbalanguage processor\u7684\u5b9e\u73b0\u3002 \u4ee5\u4e0b\u9762\u4e09\u79cdimplementation\u4e3a\u4f8b\u6765\u8fdb\u884c\u8bf4\u660e: \u7ae0\u8282 sqlite \u5de5\u7a0bDB\u7684 Implementation\\SQLite\\doc\\Technical-and-Design-Documentation\\Architecture-of-SQLite \u7ae0\u8282 clang \u5de5\u7a0b programming-language \u7684 C-family-language\\C-and-C++\\From-source-code-to-exec\\Compile\\Implementation\\LLVM\\Clang \u7ae0\u8282 Python \u5de5\u7a0b programming-language \u7684 Python \u7ae0\u8282","title":"Formal language processor"},{"location":"Formal-language-processing/Formal-language-processor/#_1","text":"\u4e00\u822c\uff0cformal language processor\u90fd\u662f\u91c7\u7528\u7684**\u5c42\u6b21\u5316\u7ed3\u6784** \u5728\u5de5\u7a0bcompiler-principle\u4e2d\u4e5f\u6709\u5173\u4e8e**\u5c42\u6b21\u5316\u7ed3\u6784**\u7684\u8ba8\u8bba TODO: \u5173\u4e8eclang\u7684\u67b6\u6784\u4e2d\u4e2d\u95f4\u8868\u793a\u7684\u91cd\u8981\u610f\u4e49\uff0c\u53c2\u89c1\u9f99\u4e66chapter6\u7684\u7b2c\u4e00\u6bb5\u3002 \u5982\u4f55\u63cf\u8ff0\u4e4b\u95f4\u8868\u793a\uff1fASDL\u662f\u4e00\u79cd\u65b9\u5f0f","title":"\u5c42\u6b21\u5316\u7ed3\u6784"},{"location":"Formal-language-processing/Formal-language-processor/#_2","text":"\u4e0d\u540c\u5c42\u6b21\u4e4b\u95f4\u9700\u8981\u4f7f\u7528**\u4e2d\u95f4\u8868\u793a**","title":"\u4e2d\u95f4\u8868\u793a"},{"location":"Formal-language-processing/Formal-language-processor/#interpretervm#and#hook#function","text":"Interpreter/VM \u6267\u884c bytecode\uff0cbytecode \u6709 Interpreter/VM \u6765\u8fdb\u884c\u6267\u884c\uff0cbytecode\u7684\u4e00\u4e9boperation\u5f80\u5f80\u5bf9\u5e94\u4e8e\u4e00\u4e2afunction\u3002\u4e3a\u4e86\u652f\u6301\u53ef\u6269\u5c55\uff0c\u4e00\u822c\u90fd\u652f\u6301user defined hook function\u3002 Python \u548c sqlite\u90fd\u662f\u5178\u578b\u7684\u57fa\u4e8einterpreter\u7684\uff0c\u5b83\u4eec\u7684interpreter/virtual machine\u652f\u6301\u6267\u884chook function: \u6ce8\u89e3 Python 3. Data model \u00b6 sqlite sqlite virtual table: The Virtual Table Mechanism Of SQLite \u6211\u4eec\u5c06\u6b64\u79f0\u4e3ainterpreter model\u3002","title":"Interpreter/VM and hook function"},{"location":"Formal-language-processing/Pattern/","text":"","title":"Introduction"},{"location":"Formal-language-processing/Pattern/Composite-pattern/","text":"Composite pattern wikipedia Composite pattern In software engineering , the composite pattern is a partitioning design pattern . The composite pattern describes a group of objects that are treated the same way as a single instance of the same type of object. The intent of a composite is to \"compose\" objects into tree structures to represent part-whole hierarchies. Implementing the composite pattern lets clients treat individual objects and compositions uniformly.[ 1] stackoverflow C++11 Composite Pattern with Smart Pointers","title":"Introduction"},{"location":"Formal-language-processing/Pattern/Composite-pattern/#composite#pattern","text":"","title":"Composite pattern"},{"location":"Formal-language-processing/Pattern/Composite-pattern/#wikipedia#composite#pattern","text":"In software engineering , the composite pattern is a partitioning design pattern . The composite pattern describes a group of objects that are treated the same way as a single instance of the same type of object. The intent of a composite is to \"compose\" objects into tree structures to represent part-whole hierarchies. Implementing the composite pattern lets clients treat individual objects and compositions uniformly.[ 1]","title":"wikipedia Composite pattern"},{"location":"Formal-language-processing/Pattern/Composite-pattern/#stackoverflow#c11#composite#pattern#with#smart#pointers","text":"","title":"stackoverflow C++11 Composite Pattern with Smart Pointers"},{"location":"Formal-language-processing/Pattern/Interpreter-pattern/","text":"Interpreter pattern \u548c\u5b83\u76f8\u5173\u7684pattern: 1 Composite pattern wikipedia Interpreter pattern : The syntax tree of a sentence in the language is an instance of the composite pattern and is used to evaluate (interpret) the sentence for a client.[ 1] :243 See also Composite pattern . \u56e0\u4e3aformal language\u662f\u5178\u578b\u7684\u7b26\u5408 containing\u5173\u7cfb\u7684\uff0c\u56e0\u6b64\u5b83\u662f\u53ef\u4ee5\u53ef\u4ee5\u4f7f\u7528tree structure\u7684\uff1b 2 Iterator pattern \u5176\u5b9e\u5b83\u66f4\u591a\u7684\u662f\u548c composite pattern \u76f8\u5173\uff0c\u901a\u8fc7 Iterator pattern \uff0c\u53ef\u4ee5\u4e3a tree structure\u6dfb\u52a0\u591a\u79cdalgorithm/behavior\u3002 3 Command pattern \u4e09\u5730\u5740\u7801\uff0c\u5176\u5b9e\u975e\u5e38\u7c7b\u4f3c\u4e8e\u4e00\u4e2acommand\uff1b wikipedia Interpreter pattern In computer programming , the interpreter pattern is a design pattern that specifies how to evaluate sentences in a language. The basic idea is to have a class for each symbol ( terminal or nonterminal ) in a specialized computer language . The syntax tree of a sentence in the language is an instance of the composite pattern and is used to evaluate (interpret) the sentence for a client.[ 1] :243 See also Composite pattern . eli.thegreenplace On the Composite and Interpreter design patterns","title":"Introduction"},{"location":"Formal-language-processing/Pattern/Interpreter-pattern/#interpreter#pattern","text":"\u548c\u5b83\u76f8\u5173\u7684pattern: 1 Composite pattern wikipedia Interpreter pattern : The syntax tree of a sentence in the language is an instance of the composite pattern and is used to evaluate (interpret) the sentence for a client.[ 1] :243 See also Composite pattern . \u56e0\u4e3aformal language\u662f\u5178\u578b\u7684\u7b26\u5408 containing\u5173\u7cfb\u7684\uff0c\u56e0\u6b64\u5b83\u662f\u53ef\u4ee5\u53ef\u4ee5\u4f7f\u7528tree structure\u7684\uff1b 2 Iterator pattern \u5176\u5b9e\u5b83\u66f4\u591a\u7684\u662f\u548c composite pattern \u76f8\u5173\uff0c\u901a\u8fc7 Iterator pattern \uff0c\u53ef\u4ee5\u4e3a tree structure\u6dfb\u52a0\u591a\u79cdalgorithm/behavior\u3002 3 Command pattern \u4e09\u5730\u5740\u7801\uff0c\u5176\u5b9e\u975e\u5e38\u7c7b\u4f3c\u4e8e\u4e00\u4e2acommand\uff1b","title":"Interpreter pattern"},{"location":"Formal-language-processing/Pattern/Interpreter-pattern/#wikipedia#interpreter#pattern","text":"In computer programming , the interpreter pattern is a design pattern that specifies how to evaluate sentences in a language. The basic idea is to have a class for each symbol ( terminal or nonterminal ) in a specialized computer language . The syntax tree of a sentence in the language is an instance of the composite pattern and is used to evaluate (interpret) the sentence for a client.[ 1] :243 See also Composite pattern .","title":"wikipedia Interpreter pattern"},{"location":"Formal-language-processing/Pattern/Interpreter-pattern/#elithegreenplace#on#the#composite#and#interpreter#design#patterns","text":"","title":"eli.thegreenplace On the Composite and Interpreter design patterns"},{"location":"Formal-language-processing/Pattern/Translator-Pattern/","text":"Translator Pattern \u5728\u9605\u8bfb wiki.c2 External Polymorphism \u65f6\uff0c\u5176\u4e2d\u63d0\u53ca\u4e86 Translator Pattern \uff0c\u770b\u4e86\u4e00\u4e0b\uff0c\u5b83\u8ba9\u6211\u60f3\u5230\u4e86composition pattern\u3001interpreter pattern\u3002 wiki.c2 Translator Pattern This is an attempt to present ThomasKuehne 's Translator pattern in a simplified form. You can get the real version from: http://homepages.mcs.vuw.ac.nz/~tk/publications/papers/translator.pdf See FunctionalPatternSystemForObjectOrientedDesign \u95ee\u9898\u63cf\u8ff0 Often objects are organized into complex data structures such as trees or graphs in order to represent a system of relationships between the objects. Many times one of these structures will be useful in more than one context. For instance an abstract syntax tree would be useful in either a compiler or a pretty printer. In these cases the behavior of the structure and its components is extrinsic(\u975e\u56fa\u6709\u7684\u3001\u5916\u5728\u7684) rather than intrinsic(\u56fa\u6709\u7684\u3001\u672c\u8d28\u7684). That is to say that the behavior of each object in the structure has more to do with how the object is viewed by the context than with the nature of the object itself. When this situation occurs the symptoms(\u75c7\u72b6) include: 1\u3001relationships and behaviors that are correct for one context but not for another, 2\u3001polymorphic methods on the nodes that serve only a narrow subset of clients, overly complex traversal mechanisms that are intrusive or that require excessive book keeping. Ordinarily it is impossible to remedy(\u7ea0\u6b63\u3001\u8865\u6551) this problem without violating the OpenClosedPrinciple because the definition of each object must change in response to its use in a new context. NOTE: \u4e00\u3001\u6982\u62ec\u6765\u8bf4\uff0c\u95ee\u9898\u5c31\u662f: 1\u3001\"the behavior of the structure and its components is extrinsic(\u975e\u56fa\u6709\u7684\u3001\u5916\u5728\u7684) rather than intrinsic\"\uff0c\u5373\"behavior of the structure\"\u662f\u7531\u5b83\u7684context\u51b3\u5b9a\u7684\uff0c\u800c\u4e0d\u662f\u7531\u5b83\u672c\u8eab\u51b3\u5b9a\u7684\uff0c\u8fd9\u5c31\u662f \"extrinsic VS intrinsic\" 2\u3001\"Ordinarily it is impossible to remedy(\u7ea0\u6b63\u3001\u8865\u6551) this problem without violating the OpenClosedPrinciple because the definition of each object must change in response to its use in a new context.\"\uff0c\u8ba9\u6211\u60f3\u5230\u4e86expression problem\u3002 \u89e3\u51b3\u65b9\u6848: translation Therefore: Define a recursive traversal of the structure starting from some root node. Define a GenericFunction that takes a node of the structure as a parameter and recursively translates that node, all of its sub-nodes and all of the edges between them to an equivalent structure in the new context. A one to one correspondence between the elements of the original structure and elements in the resulting structure need not be maintained, but the translation must be localized to each node and be composable (i.e. a node should be able to implement its translation in terms of translations on its sub-nodes.) Implement the elements in the resulting structure so that the system of relationships that it contains is capable of supplying the desired services. Finally, perform the desired operation by traversing the new structure and calling the appropriate method(s) on each node. NOTE: 1\u3001\u89e3\u51b3\u65b9\u6848\u5176\u5b9e\u8bf4\u8d77\u6765\u662f\u6bd4\u8f83\u7b80\u5355\u7684: translate to a new\u3001equivalent structure in the new context\uff0c\u7136\u540e\u5728\u8fd9\u4e2anew structure\u4e0a\u6267\u884ccomputation\uff0c\u8fd9\u5c31\u662f \"Translator Pattern\" \u4e2d Translator \u7684\u542b\u4e49 2\u3001\u5b83\u8ba9\u6211\u60f3\u8d77\u6765 Data, context and interaction Resulting context: Advantages This two-part process has several advantages. 1\u3001Most importantly, the original structure and it's elements need not change. The use of ExternalPolymorphism (via the GenericFunction ) requires only that the dynamic type of an object be obtainable at run-time. This advantage makes this approach desirable in situations where the VisitorPattern (which solves the same problem) is difficult or impossible to implement. 2\u3001The elements of the generated structure can be customized to the specific task. The elements of the new structure can be of completely new types (indeed this is desirable) and the relationships between them can be modified in ways that suit the new context even if they would be inappropriate for the old one so long as there is a two-way mapping between the two structures. 3\u3001Since the new structure is separate from the original its elements can be altered by the operation without harming the clients of the original. 4\u3001The use of HomomorphicMapping makes it possible to update the second structure and the results of operations on it in response to changes in the original structure. 5\u3001There is no dependence of the original structure on any part of the implementation of the new operation. 6\u3001The use of ExternalPolymorphism makes it easy to add new functions as needed without disturbing existing classes. Disadvantages There are of course disadvantages: 1\u3001 GenericFunction s are difficult to setup and maintain without direct language support. 2\u3001As with all functional patterns for object oriented programming this approach is not idiomatic and will not be recognised or appreciated by most OO practitioners. This is not an OO approach -- it is a functional approach designed to allow multi-paradigm programming in an OO environment. 3\u3001The use of ExternalPolymorphism makes it difficult to add new classes because all of the relevant functions will have to be updated. Objection: wouldn't a dispatch table allow one to work around this? AnswerMe NOTE: \u5f02\u8bae There may be an answer in the detailed discussion in the thesis. See ObjectFunctionalImplementation for discussion of attempts to implement the ideas. -- JohnFletcher Compare with: VisitorPattern stackoverflow Translator Pattern","title":"Introduction"},{"location":"Formal-language-processing/Pattern/Translator-Pattern/#translator#pattern","text":"\u5728\u9605\u8bfb wiki.c2 External Polymorphism \u65f6\uff0c\u5176\u4e2d\u63d0\u53ca\u4e86 Translator Pattern \uff0c\u770b\u4e86\u4e00\u4e0b\uff0c\u5b83\u8ba9\u6211\u60f3\u5230\u4e86composition pattern\u3001interpreter pattern\u3002","title":"Translator Pattern"},{"location":"Formal-language-processing/Pattern/Translator-Pattern/#wikic2#translator#pattern","text":"This is an attempt to present ThomasKuehne 's Translator pattern in a simplified form. You can get the real version from: http://homepages.mcs.vuw.ac.nz/~tk/publications/papers/translator.pdf See FunctionalPatternSystemForObjectOrientedDesign","title":"wiki.c2 Translator Pattern"},{"location":"Formal-language-processing/Pattern/Translator-Pattern/#_1","text":"Often objects are organized into complex data structures such as trees or graphs in order to represent a system of relationships between the objects. Many times one of these structures will be useful in more than one context. For instance an abstract syntax tree would be useful in either a compiler or a pretty printer. In these cases the behavior of the structure and its components is extrinsic(\u975e\u56fa\u6709\u7684\u3001\u5916\u5728\u7684) rather than intrinsic(\u56fa\u6709\u7684\u3001\u672c\u8d28\u7684). That is to say that the behavior of each object in the structure has more to do with how the object is viewed by the context than with the nature of the object itself. When this situation occurs the symptoms(\u75c7\u72b6) include: 1\u3001relationships and behaviors that are correct for one context but not for another, 2\u3001polymorphic methods on the nodes that serve only a narrow subset of clients, overly complex traversal mechanisms that are intrusive or that require excessive book keeping. Ordinarily it is impossible to remedy(\u7ea0\u6b63\u3001\u8865\u6551) this problem without violating the OpenClosedPrinciple because the definition of each object must change in response to its use in a new context. NOTE: \u4e00\u3001\u6982\u62ec\u6765\u8bf4\uff0c\u95ee\u9898\u5c31\u662f: 1\u3001\"the behavior of the structure and its components is extrinsic(\u975e\u56fa\u6709\u7684\u3001\u5916\u5728\u7684) rather than intrinsic\"\uff0c\u5373\"behavior of the structure\"\u662f\u7531\u5b83\u7684context\u51b3\u5b9a\u7684\uff0c\u800c\u4e0d\u662f\u7531\u5b83\u672c\u8eab\u51b3\u5b9a\u7684\uff0c\u8fd9\u5c31\u662f \"extrinsic VS intrinsic\" 2\u3001\"Ordinarily it is impossible to remedy(\u7ea0\u6b63\u3001\u8865\u6551) this problem without violating the OpenClosedPrinciple because the definition of each object must change in response to its use in a new context.\"\uff0c\u8ba9\u6211\u60f3\u5230\u4e86expression problem\u3002","title":"\u95ee\u9898\u63cf\u8ff0"},{"location":"Formal-language-processing/Pattern/Translator-Pattern/#translation","text":"Therefore: Define a recursive traversal of the structure starting from some root node. Define a GenericFunction that takes a node of the structure as a parameter and recursively translates that node, all of its sub-nodes and all of the edges between them to an equivalent structure in the new context. A one to one correspondence between the elements of the original structure and elements in the resulting structure need not be maintained, but the translation must be localized to each node and be composable (i.e. a node should be able to implement its translation in terms of translations on its sub-nodes.) Implement the elements in the resulting structure so that the system of relationships that it contains is capable of supplying the desired services. Finally, perform the desired operation by traversing the new structure and calling the appropriate method(s) on each node. NOTE: 1\u3001\u89e3\u51b3\u65b9\u6848\u5176\u5b9e\u8bf4\u8d77\u6765\u662f\u6bd4\u8f83\u7b80\u5355\u7684: translate to a new\u3001equivalent structure in the new context\uff0c\u7136\u540e\u5728\u8fd9\u4e2anew structure\u4e0a\u6267\u884ccomputation\uff0c\u8fd9\u5c31\u662f \"Translator Pattern\" \u4e2d Translator \u7684\u542b\u4e49 2\u3001\u5b83\u8ba9\u6211\u60f3\u8d77\u6765 Data, context and interaction Resulting context:","title":"\u89e3\u51b3\u65b9\u6848: translation"},{"location":"Formal-language-processing/Pattern/Translator-Pattern/#advantages","text":"This two-part process has several advantages. 1\u3001Most importantly, the original structure and it's elements need not change. The use of ExternalPolymorphism (via the GenericFunction ) requires only that the dynamic type of an object be obtainable at run-time. This advantage makes this approach desirable in situations where the VisitorPattern (which solves the same problem) is difficult or impossible to implement. 2\u3001The elements of the generated structure can be customized to the specific task. The elements of the new structure can be of completely new types (indeed this is desirable) and the relationships between them can be modified in ways that suit the new context even if they would be inappropriate for the old one so long as there is a two-way mapping between the two structures. 3\u3001Since the new structure is separate from the original its elements can be altered by the operation without harming the clients of the original. 4\u3001The use of HomomorphicMapping makes it possible to update the second structure and the results of operations on it in response to changes in the original structure. 5\u3001There is no dependence of the original structure on any part of the implementation of the new operation. 6\u3001The use of ExternalPolymorphism makes it easy to add new functions as needed without disturbing existing classes.","title":"Advantages"},{"location":"Formal-language-processing/Pattern/Translator-Pattern/#disadvantages","text":"There are of course disadvantages: 1\u3001 GenericFunction s are difficult to setup and maintain without direct language support. 2\u3001As with all functional patterns for object oriented programming this approach is not idiomatic and will not be recognised or appreciated by most OO practitioners. This is not an OO approach -- it is a functional approach designed to allow multi-paradigm programming in an OO environment. 3\u3001The use of ExternalPolymorphism makes it difficult to add new classes because all of the relevant functions will have to be updated. Objection: wouldn't a dispatch table allow one to work around this? AnswerMe NOTE: \u5f02\u8bae There may be an answer in the detailed discussion in the thesis. See ObjectFunctionalImplementation for discussion of attempts to implement the ideas. -- JohnFletcher Compare with: VisitorPattern","title":"Disadvantages"},{"location":"Formal-language-processing/Pattern/Translator-Pattern/#stackoverflow#translator#pattern","text":"","title":"stackoverflow Translator Pattern"},{"location":"LaTeX/","text":"","title":"Introduction"},{"location":"LaTeX/LaTeX-under/","text":"\\underset tutorialspoint \\underset - Tex Command \\underset{\\rm bottom}{\\rm top} \\underset{\\rm bottom}{\\rm top} \\underset{\\rm bottom}{\\rm top} stackexchange How to put text below some text in an equation \\underset{Under}{Normal} \\underset{Under}{Normal} \\underset{Under}{Normal} \\mathop{Normal}_{Under} \\mathop{Normal}_{Under} \\mathop{Normal}_{Under}","title":"Introduction"},{"location":"LaTeX/LaTeX-under/#underset","text":"","title":"\\underset"},{"location":"LaTeX/LaTeX-under/#tutorialspoint#underset#-#tex#command","text":"\\underset{\\rm bottom}{\\rm top} \\underset{\\rm bottom}{\\rm top} \\underset{\\rm bottom}{\\rm top}","title":"tutorialspoint \\underset - Tex Command"},{"location":"LaTeX/LaTeX-under/#stackexchange#how#to#put#text#below#some#text#in#an#equation","text":"\\underset{Under}{Normal} \\underset{Under}{Normal} \\underset{Under}{Normal} \\mathop{Normal}_{Under} \\mathop{Normal}_{Under} \\mathop{Normal}_{Under}","title":"stackexchange How to put text below some text in an equation"},{"location":"Language/","text":"Language \u4e00\u5207\u201c\u63cf\u8ff0\u201d\u90fd\u662f\u8bed\u8a00\uff1f \u5f53\u8c08\u5230**\u8bed\u8a00**\u540e\uff0c\u90a3\u4e48\u5f97\u8bf4\u8bf4\u201c\u63cf\u8ff0\u201d\u8fd9\u4e2a\u8bcd\u4e86\uff0c\u611f\u89c9\u8fd9\u4e2a\u8bcd\u662f\u4e00\u4e2a\u975e\u5e38\u5bbd\u6cdb\u3001\u975e\u5e38\u56ca\u62ec\u7684\u8bcd\uff0c\u6bd4\u5982\uff1a \u5728wikipedia Language of mathematics \u7684\"The meanings of mathematics\"\u6bb5\u4e2d\u5c31\u4f7f\u7528\u4e86\u201cdescribes \u201d\u8fd9\u4e2a\u8bcd\uff08\u8fd9\u6bb5\u8bdd\u603b\u7ed3\u7684\u592a\u597d\u4ee5\u81f3\u4e8e\u6211\u5fcd\u4e0d\u4f4f\u5730\u628a\u5b83\u6458\u5f55\u8fc7\u6765\u4e86\uff09\uff1a Mathematics describes the real world : many areas of mathematics originated with attempts to describe and solve real world phenomena - from measuring farms ( geometry ) to falling apples ( calculus ) to gambling(\u8d4c\u535a) ( probability ). Mathematics is widely used in modern physics and engineering , and has been hugely successful in helping us to understand more about the universe around us from its largest scales ( physical cosmology ) to its smallest ( quantum mechanics ). Indeed, the very success of mathematics in this respect has been a source of puzzlement for some philosophers (see The Unreasonable Effectiveness of Mathematics in the Natural Sciences by Eugene Wigner ). Mathematics describes abstract structures : on the other hand, there are areas of pure mathematics which deal with abstract structures , which have no known physical counterparts at all. However, it is difficult to give any categorical examples here, as even the most abstract structures can be co-opted as models in some branch of physics (see Calabi-Yau spaces and string theory ). NOTE: \u8fd9\u548ccomputer science\u5bc6\u5207\u76f8\u5173 Mathematics describes mathematics : mathematics can be used reflexively to describe itself\u2014this is an area of mathematics called metamathematics . \u90a3\u4e0d\u7981\u60f3\u95ee\uff1a\u6570\u5b66\u662f\u4e00\u95e8\u8bed\u8a00\u5417\uff1f\u5982\u679c\u4ece\u201c\u63cf\u8ff0\u201d\u7684\u89d2\u5ea6\u6765\u770b\u8bdd\uff0c\u6211\u89c9\u5f97\u53ef\u4ee5\u56de\u7b54\u201c\u662f\u201d\uff0c\u4e0b\u9762\u662f\u539f\u6587\u4e2d\u7d27\u8ddf\u7740\u7684\u5bf9\u8fd9\u4e2a\u95ee\u9898\u7684\u8bba\u8ff0\uff1a Mathematics can communicate a range of meanings that is as wide as (although different from) that of a natural language . As English mathematician R.L.E. Schwarzenberger says: My own attitude, which I share with many of my colleagues, is simply that **mathematics is a language* . Like English, or Latin, or Chinese, there are certain concepts for which mathematics is particularly well suited: it would be as foolish to attempt to write a love poem in the language of mathematics as to prove the Fundamental Theorem of Algebra using the English language.* \u6839\u636e\u4e0a\u9762\u7684\u8bba\u8ff0\u6765\u770b\uff0c English mathematician R.L.E. Schwarzenberger \u8ba4\u4e3a \u6570\u5b66\u662f\u4e00\u95e8\u8bed\u8a00\u3002 \u8ba9\u6211\u4eec\u6cbf\u7740\u8fd9\u4e2a\u601d\u8def\u8fdb\u4e00\u6b65\u8fdb\u884c\u63a8\u5e7f\u5c31\u5f97\u5230\u672c\u5c0f\u8282\u7684\u6807\u9898\u6240\u63cf\u8ff0\u7684\u95ee\u9898\uff1a\u201c\u4e00\u5207\u201c\u63cf\u8ff0\u201d\u90fd\u662f\u8bed\u8a00\uff1f\u201d\uff0c\u8fd9\u4e2a\u95ee\u9898\u6211\u65e0\u6cd5\u7ed9\u51fa\u7b54\u6848\uff0c\u4ee5\u6211\u76ee\u524d\u7684\u8ba4\u77e5\u6c34\u5e73\uff0c\u6211\u89c9\u5f97\u662f\u7684\u3002 Property of language \u8bed\u8a00\u7684\u9012\u5f52\u6027 \u50cfCFG\u5c31\u5177\u5907\u9012\u5f52\u6027\uff0c\u6709 recursive grammar \u7684\u6982\u5ff5\u3002\u5173\u4e8e\u8bed\u8a00\u7684\u9012\u5f52\u6027\u5728 Production(computer-science) \u3001 Chomsky-hierarchy \u4e2d\u6709\u4e13\u95e8\u7684\u63cf\u8ff0\u3002 See also: Recursive language Human-readable and machine-readable \u4e0b\u9762\u8fd9\u6bb5\u662f\u6211\u5728\u9605\u8bfb The Python Language Specification \u65f6\u9047\u5230\u7684\uff1a Contained within the CPython source code is the definition of the Python language. This is the reference specification used by all the Python interpreters. The specification is in both human-readable and machine-readable format. Inside the documentation is a detailed explanation of the Python language, what is allowed, and how each statement should behave. \u5b83\u5bf9\u6211\u7684\u542f\u53d1\u662f\uff1a \u4e0d\u540c\u7684\u8bed\u8a00\u6709\u7740\u5404\u81ea\u7684\u4f18\u52bf\uff0c\u6bd4\u5982\u6709\u7684\u8bed\u8a00\u5c31\u4e0d\u662fmachine-readable\u3002 \u5728\u5de5\u7a0b\u4e2d\uff0c\u6211\u4eec\u5f80\u5f80\u9700\u8981\u5c06\u4e00\u79cd\u63cf\u8ff0\u65b9\u5f0f\u8f6c\u6362\u4e3a\u53e6\u5916\u4e00\u79cd\u63cf\u8ff0\u65b9\u5f0f \u4e0d\u540c\u8bed\u8a00\u6709\u7740\u5404\u81ea\u7684\u4f18\u52bf English mathematician R.L.E. Schwarzenberger \u7684\u8fd9\u756a\u8a00\u8bba\uff08\u53c2\u89c1\u4e0a\u4e00\u8282\uff09\u5411\u6211\u4eec\u63ed\u793a\u4e86\uff1a\u4e0d\u540c\u7684\u8bed\u8a00\u6709\u7740\u5404\u81ea\u7684\u4f18\u52bf\uff0c\u5373\u6709\u7684\u8bed\u8a00\u662f\u975e\u5e38\u9002\u5408\u4e8e\u63cf\u8ff0\u67d0\u4e00\u7c7b\u4e8b\u7269\uff08\u6216\u8005\u95ee\u9898\uff09\u7684\uff0c\u6216\u8005\u8bf4\uff0c\u4f7f\u7528\u4e0d\u540c\u7684\u8bed\u8a00\u6765\u63cf\u8ff0\u76f8\u540c\u7684\u95ee\u9898\uff0c\u4f7f\u7528\u8fd9\u79cd\u8bed\u8a00\u66f4\u52a0\u5730\u4fbf\u5229\uff0c\u66f4\u52a0\u6613\u4e8e\u7406\u89e3\uff0c\u800c\u6709\u7684\u8bed\u8a00\u5219\u53ef\u80fd\u6bd4\u8f83\u7e41\u7410\u4e14\u4e0d\u5229\u4e8e\u7406\u89e3\uff0c\u4e5f\u5c31\u662f\u5bf9\u8fd9\u7c7b\u95ee\u9898\u800c\u5df2\uff0c\u8fd9\u79cd\u8bed\u8a00\u66f4\u52a0\u5730**expressive**\u3002\u6b63\u5982\u5b83\u6240\u603b\u7ed3\u7684\u8fd9\u4e2a\u4f8b\u5b50\uff0c\u81ea\u7136\u8bed\u8a00\u663e\u7136\u66f4\u52a0\u9002\u5408\u4e8e\u8868\u8fbe\u60c5\u611f\uff0c\u6570\u5b66\u8bed\u8a00\u66f4\u52a0\u9002\u5408\u4e8e\u8fdb\u884c\u4e25\u683c\u5730\u8bc1\u660e\u3002 \u6211\u4eec\u77e5\u9053\uff0c\u76ee\u524d\u5df2\u7ecf\u6709\u975e\u5e38\u591a\u7684programming language\u4e86\uff0c\u7ef4\u57fa\u767e\u79d1\u7684 List of programming languages \u4e2d\uff0c\u5df2\u7ecf\u6536\u5f55\u4e86\u7ea6700\u4e2dprogramming language\uff0c\u6240\u4ee5\uff0c\u6211\u4eec\u6709\u5fc5\u8981\u5206\u6790\u4e00\u4e0b\u4e0d\u540c\u7684programming language\u7684\u5404\u81ea\u7684\u4f18\u52bf\u3002\u5173\u4e8e\u6b64\uff0c\u53c2\u89c1\u5de5\u7a0b programming-language \u7684\u6587\u7ae0Expressive of programming language\u3002 \u8bed\u8a00\u7684expressive power \u53c2\u89c1 ./Expressive-power \u7ae0\u8282\u3002 \u5982\u4f55\u6765\u8fdb\u884c\u63cf\u8ff0/\u5982\u4f55\u9009\u62e9\u8bed\u8a00\uff1f \u5982\u4f55\u6765\u8fdb\u884c\u63cf\u8ff0\uff1f\u4f5c\u4e3a\u4e00\u4e2asoftware engineer\uff0c\u8fd9\u662f\u9700\u8981\u6211\u4eec\u4e0d\u65ad\u5730\u8fdb\u884c\u601d\u8003\u7684\u95ee\u9898\uff0c\u4e0b\u9762\u662f\u6211\u7684\u4e00\u4e9b\u7ecf\u9a8c: \u4f7f\u7528\u4e0d\u540c\u7684\u5b66\u79d1\u7684\u8bed\u8a00\u6765\u8fdb\u884c\u63cf\u8ff0 \u901a\u8fc7\u524d\u9762\u7684\u5185\u5bb9\uff0c\u6211\u4eec\u5e94\u8be5\u5df2\u7ecf\u5bf9\u8bed\u8a00\u6709\u4e86\u66f4\u52a0\u5bbd\u6cdb\u7684\u8ba4\u8bc6\u4e86\u3002\u4e0d\u540c\u7684\u5b66\u79d1\u521b\u5efa\u4e86\u5404\u81ea\u7684\u7406\u8bba\u4f53\u7cfb\uff08\u521b\u5efa\u4e86\u6982\u5ff5\u3001\u89c4\u5219\u7b49\uff09\uff0c\u8fd9\u5c31\u5f62\u6210\u4e86\u8be5\u5b66\u79d1\u7684\u7279\u6709\u7684**\u8bed\u8a00**\uff0c\u8fd9\u5c31\u5f62\u6210\u4e86\u5bf9\u4e8e\u540c\u4e00\u4e2a\u4e8b\u7269\uff0c\u5404\u4e2a\u5b66\u79d1\u90fd\u53ef\u4ee5\u4f7f\u7528\u81ea\u5df1\u7684\u8bed\u8a00\u6765\u5bf9\u5b83\u8fdb\u884c\u63cf\u8ff0\uff0c\u8fd9\u5c31\u597d\u6bd4\u5bf9\u4e8e\u201c\u82f9\u679c\u201d\uff0c\u4e2d\u6587\u3001\u82f1\u6587\u3001\u6cd5\u6587\u6709\u7740\u5404\u81ea\u7684\u63cf\u8ff0\u65b9\u5f0f\u3002 \u62e5\u6709\u8fd9\u6837\u7684\u8ba4\u77e5\u662f\u975e\u5e38\u91cd\u8981\u7684\uff0c\u6bd4\u5982\uff0c\u5f53\u6211\u4eec\u5728\u9605\u8bfb\u7ef4\u57fa\u767e\u79d1\u7684\u4e00\u4e9b\u6587\u7ae0\u7684\u65f6\u5019\uff0c\u5e38\u5e38\u4f1a\u78b0\u5230\u7684\u4e00\u79cd\u60c5\u51b5\u662f\u67d0\u67d0\u6982\u5ff5\uff0c\u6570\u5b66\u4e2d\u600e\u4e48\u63cf\u8ff0\u3001\u8ba1\u7b97\u673a\u79d1\u5b66\u4e2d\u600e\u4e48\u63cf\u8ff0\u3001\u8bed\u8a00\u5b66\u4e2d\u600e\u4e48\u63cf\u8ff0\u3002 \u62e5\u6709\u8fd9\u6837\u7684\u8ba4\u77e5\u5bf9\u4e8e\u8f6f\u4ef6\u5de5\u7a0b\u5e08\u5c24\u5176\u91cd\u8981\uff0c\u6b63\u5982\u5728\u672c\u6587\u5f00\u5934\u505a\u8bf4\u7684\uff1a \u6211\u4eec\u6240\u505a\u7684\u5f88\u591a\u5de5\u4f5c\uff0c\u5c31\u662f\u5c06\u4eba\u4eec\u4f7f\u7528 natural language \u3001 language of mathematics \u7b49\u8bed\u8a00\u7684\u63cf\u8ff0\uff0c\u8f6c\u6362\u4e3a programming language \u7684\u63cf\u8ff0 Example: \u4f7f\u7528\u4e0d\u540c\u7684\u63cf\u8ff0\u8bed\u8a00\u6765\u63cf\u8ff0MLP: \u5178\u578b\u7684\u4f8b\u5b50\u5c31\u662f\u5bf9\u4e8eMLP\uff0c\u5bf9\u4e8e\u540c\u4e00\u4e2a\u7ed3\u6784\uff0c\u53ef\u4ee5\u4f7f\u7528\u4e0d\u540c\u7684\u8bed\u8a00\u6765\u8fdb\u884c\u63cf\u8ff0\u3002\u53ef\u4ee5\u4f7f\u7528**graph**\u3001**math expression**\u6765\u8fdb\u884c\u63cf\u8ff0\uff0c\u5728\u6587\u7ae0 zhihu \u5982\u4f55\u76f4\u89c2\u5730\u89e3\u91ca backpropagation \u7b97\u6cd5\uff1f - Anonymous\u7684\u56de\u7b54 - \u77e5\u4e4e \u4e2d\u6709\u5982\u4e0b\u63cf\u8ff0\uff1a \u591a\u5c42\u795e\u7ecf\u7f51\u7edc\u672c\u8d28\u4e0a\u662f\u4e00\u4e2a\u591a\u5c42\u590d\u5408\u51fd\u6570\uff0c\u6570\u5b66\u662f\u4e00\u95e8\u7b80\u6d01\u4f46\u662f\u542b\u4e49\u4e30\u5bcc\u7684\u539f\u56e0\uff0c\u7b80\u5355\u7684\u516c\u5f0f\uff0c\u4f46\u662f\u80fd\u591f\u8868\u8fbe\u5f3a\u5927\u7684\u7ed3\u6784 Programming model and programming paradigm \u5728\u4e0d\u540c\u9886\u57df\uff0c\u6709\u7740\u9002\u5408\u4e8e\u8be5\u9886\u57df\u95ee\u9898\u7684\u95ee\u9898\u7684\u63cf\u8ff0\u65b9\u5f0f\uff0c\u8fd9\u5c31\u662f\u6240\u8c13\u7684programming model\u3001programming paradigm\u3002 \u5173\u4e8eprogramming model\uff0c\u53c2\u89c1\u5de5\u7a0bprogramming-language\u7684 Theory\\Programming-model \u7ae0\u8282\u3002 \u5173\u4e8eprogramming paradigm\uff0c\u53c2\u89c1\u5de5\u7a0bprogramming-language\u7684 Theory\\Programming-paradigm \u7ae0\u8282\u3002 \u4f7f\u7528\u66f4\u52a0\u62bd\u8c61\u7684\u8bed\u8a00 \u5178\u578b\u7684\u4f8b\u5b50\u5c31\u662fC++ iterator\u3001C++ range\u3002iterator\u662f\u4e00\u79cd\u975e\u5e38\u5f3a\u5927\u7684\u62bd\u8c61\u7684\u63cf\u8ff0\u65b9\u5f0f\uff0c\u53ef\u4ee5\u62bd\u8c61\u5730\u63cf\u8ff0container\u3001stream\u3002 \u4f7f\u7528\u9002\u5408\u4e8e\u95ee\u9898\u7684\u8bed\u8a00 \u6bd4\u5982\u4f7f\u7528DSL\uff1b \u6bd4\u5982\u521b\u9020\u9002\u5408\u4e8e\u8be5\u9886\u57df\u7684\u8bed\u8a00\uff0cJavaScript\u5c31\u662f\u8fd9\u6837\u7684\u4e00\u4e2a\u4f8b\u5b50\uff1b","title":"Introduction"},{"location":"Language/#language","text":"","title":"Language"},{"location":"Language/#_1","text":"\u5f53\u8c08\u5230**\u8bed\u8a00**\u540e\uff0c\u90a3\u4e48\u5f97\u8bf4\u8bf4\u201c\u63cf\u8ff0\u201d\u8fd9\u4e2a\u8bcd\u4e86\uff0c\u611f\u89c9\u8fd9\u4e2a\u8bcd\u662f\u4e00\u4e2a\u975e\u5e38\u5bbd\u6cdb\u3001\u975e\u5e38\u56ca\u62ec\u7684\u8bcd\uff0c\u6bd4\u5982\uff1a \u5728wikipedia Language of mathematics \u7684\"The meanings of mathematics\"\u6bb5\u4e2d\u5c31\u4f7f\u7528\u4e86\u201cdescribes \u201d\u8fd9\u4e2a\u8bcd\uff08\u8fd9\u6bb5\u8bdd\u603b\u7ed3\u7684\u592a\u597d\u4ee5\u81f3\u4e8e\u6211\u5fcd\u4e0d\u4f4f\u5730\u628a\u5b83\u6458\u5f55\u8fc7\u6765\u4e86\uff09\uff1a Mathematics describes the real world : many areas of mathematics originated with attempts to describe and solve real world phenomena - from measuring farms ( geometry ) to falling apples ( calculus ) to gambling(\u8d4c\u535a) ( probability ). Mathematics is widely used in modern physics and engineering , and has been hugely successful in helping us to understand more about the universe around us from its largest scales ( physical cosmology ) to its smallest ( quantum mechanics ). Indeed, the very success of mathematics in this respect has been a source of puzzlement for some philosophers (see The Unreasonable Effectiveness of Mathematics in the Natural Sciences by Eugene Wigner ). Mathematics describes abstract structures : on the other hand, there are areas of pure mathematics which deal with abstract structures , which have no known physical counterparts at all. However, it is difficult to give any categorical examples here, as even the most abstract structures can be co-opted as models in some branch of physics (see Calabi-Yau spaces and string theory ). NOTE: \u8fd9\u548ccomputer science\u5bc6\u5207\u76f8\u5173 Mathematics describes mathematics : mathematics can be used reflexively to describe itself\u2014this is an area of mathematics called metamathematics . \u90a3\u4e0d\u7981\u60f3\u95ee\uff1a\u6570\u5b66\u662f\u4e00\u95e8\u8bed\u8a00\u5417\uff1f\u5982\u679c\u4ece\u201c\u63cf\u8ff0\u201d\u7684\u89d2\u5ea6\u6765\u770b\u8bdd\uff0c\u6211\u89c9\u5f97\u53ef\u4ee5\u56de\u7b54\u201c\u662f\u201d\uff0c\u4e0b\u9762\u662f\u539f\u6587\u4e2d\u7d27\u8ddf\u7740\u7684\u5bf9\u8fd9\u4e2a\u95ee\u9898\u7684\u8bba\u8ff0\uff1a Mathematics can communicate a range of meanings that is as wide as (although different from) that of a natural language . As English mathematician R.L.E. Schwarzenberger says: My own attitude, which I share with many of my colleagues, is simply that **mathematics is a language* . Like English, or Latin, or Chinese, there are certain concepts for which mathematics is particularly well suited: it would be as foolish to attempt to write a love poem in the language of mathematics as to prove the Fundamental Theorem of Algebra using the English language.* \u6839\u636e\u4e0a\u9762\u7684\u8bba\u8ff0\u6765\u770b\uff0c English mathematician R.L.E. Schwarzenberger \u8ba4\u4e3a \u6570\u5b66\u662f\u4e00\u95e8\u8bed\u8a00\u3002 \u8ba9\u6211\u4eec\u6cbf\u7740\u8fd9\u4e2a\u601d\u8def\u8fdb\u4e00\u6b65\u8fdb\u884c\u63a8\u5e7f\u5c31\u5f97\u5230\u672c\u5c0f\u8282\u7684\u6807\u9898\u6240\u63cf\u8ff0\u7684\u95ee\u9898\uff1a\u201c\u4e00\u5207\u201c\u63cf\u8ff0\u201d\u90fd\u662f\u8bed\u8a00\uff1f\u201d\uff0c\u8fd9\u4e2a\u95ee\u9898\u6211\u65e0\u6cd5\u7ed9\u51fa\u7b54\u6848\uff0c\u4ee5\u6211\u76ee\u524d\u7684\u8ba4\u77e5\u6c34\u5e73\uff0c\u6211\u89c9\u5f97\u662f\u7684\u3002","title":"\u4e00\u5207\u201c\u63cf\u8ff0\u201d\u90fd\u662f\u8bed\u8a00\uff1f"},{"location":"Language/#property#of#language","text":"","title":"Property of language"},{"location":"Language/#_2","text":"\u50cfCFG\u5c31\u5177\u5907\u9012\u5f52\u6027\uff0c\u6709 recursive grammar \u7684\u6982\u5ff5\u3002\u5173\u4e8e\u8bed\u8a00\u7684\u9012\u5f52\u6027\u5728 Production(computer-science) \u3001 Chomsky-hierarchy \u4e2d\u6709\u4e13\u95e8\u7684\u63cf\u8ff0\u3002 See also: Recursive language","title":"\u8bed\u8a00\u7684\u9012\u5f52\u6027"},{"location":"Language/#human-readable#and#machine-readable","text":"\u4e0b\u9762\u8fd9\u6bb5\u662f\u6211\u5728\u9605\u8bfb The Python Language Specification \u65f6\u9047\u5230\u7684\uff1a Contained within the CPython source code is the definition of the Python language. This is the reference specification used by all the Python interpreters. The specification is in both human-readable and machine-readable format. Inside the documentation is a detailed explanation of the Python language, what is allowed, and how each statement should behave. \u5b83\u5bf9\u6211\u7684\u542f\u53d1\u662f\uff1a \u4e0d\u540c\u7684\u8bed\u8a00\u6709\u7740\u5404\u81ea\u7684\u4f18\u52bf\uff0c\u6bd4\u5982\u6709\u7684\u8bed\u8a00\u5c31\u4e0d\u662fmachine-readable\u3002 \u5728\u5de5\u7a0b\u4e2d\uff0c\u6211\u4eec\u5f80\u5f80\u9700\u8981\u5c06\u4e00\u79cd\u63cf\u8ff0\u65b9\u5f0f\u8f6c\u6362\u4e3a\u53e6\u5916\u4e00\u79cd\u63cf\u8ff0\u65b9\u5f0f","title":"Human-readable and machine-readable"},{"location":"Language/#_3","text":"English mathematician R.L.E. Schwarzenberger \u7684\u8fd9\u756a\u8a00\u8bba\uff08\u53c2\u89c1\u4e0a\u4e00\u8282\uff09\u5411\u6211\u4eec\u63ed\u793a\u4e86\uff1a\u4e0d\u540c\u7684\u8bed\u8a00\u6709\u7740\u5404\u81ea\u7684\u4f18\u52bf\uff0c\u5373\u6709\u7684\u8bed\u8a00\u662f\u975e\u5e38\u9002\u5408\u4e8e\u63cf\u8ff0\u67d0\u4e00\u7c7b\u4e8b\u7269\uff08\u6216\u8005\u95ee\u9898\uff09\u7684\uff0c\u6216\u8005\u8bf4\uff0c\u4f7f\u7528\u4e0d\u540c\u7684\u8bed\u8a00\u6765\u63cf\u8ff0\u76f8\u540c\u7684\u95ee\u9898\uff0c\u4f7f\u7528\u8fd9\u79cd\u8bed\u8a00\u66f4\u52a0\u5730\u4fbf\u5229\uff0c\u66f4\u52a0\u6613\u4e8e\u7406\u89e3\uff0c\u800c\u6709\u7684\u8bed\u8a00\u5219\u53ef\u80fd\u6bd4\u8f83\u7e41\u7410\u4e14\u4e0d\u5229\u4e8e\u7406\u89e3\uff0c\u4e5f\u5c31\u662f\u5bf9\u8fd9\u7c7b\u95ee\u9898\u800c\u5df2\uff0c\u8fd9\u79cd\u8bed\u8a00\u66f4\u52a0\u5730**expressive**\u3002\u6b63\u5982\u5b83\u6240\u603b\u7ed3\u7684\u8fd9\u4e2a\u4f8b\u5b50\uff0c\u81ea\u7136\u8bed\u8a00\u663e\u7136\u66f4\u52a0\u9002\u5408\u4e8e\u8868\u8fbe\u60c5\u611f\uff0c\u6570\u5b66\u8bed\u8a00\u66f4\u52a0\u9002\u5408\u4e8e\u8fdb\u884c\u4e25\u683c\u5730\u8bc1\u660e\u3002 \u6211\u4eec\u77e5\u9053\uff0c\u76ee\u524d\u5df2\u7ecf\u6709\u975e\u5e38\u591a\u7684programming language\u4e86\uff0c\u7ef4\u57fa\u767e\u79d1\u7684 List of programming languages \u4e2d\uff0c\u5df2\u7ecf\u6536\u5f55\u4e86\u7ea6700\u4e2dprogramming language\uff0c\u6240\u4ee5\uff0c\u6211\u4eec\u6709\u5fc5\u8981\u5206\u6790\u4e00\u4e0b\u4e0d\u540c\u7684programming language\u7684\u5404\u81ea\u7684\u4f18\u52bf\u3002\u5173\u4e8e\u6b64\uff0c\u53c2\u89c1\u5de5\u7a0b programming-language \u7684\u6587\u7ae0Expressive of programming language\u3002","title":"\u4e0d\u540c\u8bed\u8a00\u6709\u7740\u5404\u81ea\u7684\u4f18\u52bf"},{"location":"Language/#expressive#power","text":"\u53c2\u89c1 ./Expressive-power \u7ae0\u8282\u3002","title":"\u8bed\u8a00\u7684expressive power"},{"location":"Language/#_4","text":"\u5982\u4f55\u6765\u8fdb\u884c\u63cf\u8ff0\uff1f\u4f5c\u4e3a\u4e00\u4e2asoftware engineer\uff0c\u8fd9\u662f\u9700\u8981\u6211\u4eec\u4e0d\u65ad\u5730\u8fdb\u884c\u601d\u8003\u7684\u95ee\u9898\uff0c\u4e0b\u9762\u662f\u6211\u7684\u4e00\u4e9b\u7ecf\u9a8c:","title":"\u5982\u4f55\u6765\u8fdb\u884c\u63cf\u8ff0/\u5982\u4f55\u9009\u62e9\u8bed\u8a00\uff1f"},{"location":"Language/#_5","text":"\u901a\u8fc7\u524d\u9762\u7684\u5185\u5bb9\uff0c\u6211\u4eec\u5e94\u8be5\u5df2\u7ecf\u5bf9\u8bed\u8a00\u6709\u4e86\u66f4\u52a0\u5bbd\u6cdb\u7684\u8ba4\u8bc6\u4e86\u3002\u4e0d\u540c\u7684\u5b66\u79d1\u521b\u5efa\u4e86\u5404\u81ea\u7684\u7406\u8bba\u4f53\u7cfb\uff08\u521b\u5efa\u4e86\u6982\u5ff5\u3001\u89c4\u5219\u7b49\uff09\uff0c\u8fd9\u5c31\u5f62\u6210\u4e86\u8be5\u5b66\u79d1\u7684\u7279\u6709\u7684**\u8bed\u8a00**\uff0c\u8fd9\u5c31\u5f62\u6210\u4e86\u5bf9\u4e8e\u540c\u4e00\u4e2a\u4e8b\u7269\uff0c\u5404\u4e2a\u5b66\u79d1\u90fd\u53ef\u4ee5\u4f7f\u7528\u81ea\u5df1\u7684\u8bed\u8a00\u6765\u5bf9\u5b83\u8fdb\u884c\u63cf\u8ff0\uff0c\u8fd9\u5c31\u597d\u6bd4\u5bf9\u4e8e\u201c\u82f9\u679c\u201d\uff0c\u4e2d\u6587\u3001\u82f1\u6587\u3001\u6cd5\u6587\u6709\u7740\u5404\u81ea\u7684\u63cf\u8ff0\u65b9\u5f0f\u3002 \u62e5\u6709\u8fd9\u6837\u7684\u8ba4\u77e5\u662f\u975e\u5e38\u91cd\u8981\u7684\uff0c\u6bd4\u5982\uff0c\u5f53\u6211\u4eec\u5728\u9605\u8bfb\u7ef4\u57fa\u767e\u79d1\u7684\u4e00\u4e9b\u6587\u7ae0\u7684\u65f6\u5019\uff0c\u5e38\u5e38\u4f1a\u78b0\u5230\u7684\u4e00\u79cd\u60c5\u51b5\u662f\u67d0\u67d0\u6982\u5ff5\uff0c\u6570\u5b66\u4e2d\u600e\u4e48\u63cf\u8ff0\u3001\u8ba1\u7b97\u673a\u79d1\u5b66\u4e2d\u600e\u4e48\u63cf\u8ff0\u3001\u8bed\u8a00\u5b66\u4e2d\u600e\u4e48\u63cf\u8ff0\u3002 \u62e5\u6709\u8fd9\u6837\u7684\u8ba4\u77e5\u5bf9\u4e8e\u8f6f\u4ef6\u5de5\u7a0b\u5e08\u5c24\u5176\u91cd\u8981\uff0c\u6b63\u5982\u5728\u672c\u6587\u5f00\u5934\u505a\u8bf4\u7684\uff1a \u6211\u4eec\u6240\u505a\u7684\u5f88\u591a\u5de5\u4f5c\uff0c\u5c31\u662f\u5c06\u4eba\u4eec\u4f7f\u7528 natural language \u3001 language of mathematics \u7b49\u8bed\u8a00\u7684\u63cf\u8ff0\uff0c\u8f6c\u6362\u4e3a programming language \u7684\u63cf\u8ff0 Example: \u4f7f\u7528\u4e0d\u540c\u7684\u63cf\u8ff0\u8bed\u8a00\u6765\u63cf\u8ff0MLP: \u5178\u578b\u7684\u4f8b\u5b50\u5c31\u662f\u5bf9\u4e8eMLP\uff0c\u5bf9\u4e8e\u540c\u4e00\u4e2a\u7ed3\u6784\uff0c\u53ef\u4ee5\u4f7f\u7528\u4e0d\u540c\u7684\u8bed\u8a00\u6765\u8fdb\u884c\u63cf\u8ff0\u3002\u53ef\u4ee5\u4f7f\u7528**graph**\u3001**math expression**\u6765\u8fdb\u884c\u63cf\u8ff0\uff0c\u5728\u6587\u7ae0 zhihu \u5982\u4f55\u76f4\u89c2\u5730\u89e3\u91ca backpropagation \u7b97\u6cd5\uff1f - Anonymous\u7684\u56de\u7b54 - \u77e5\u4e4e \u4e2d\u6709\u5982\u4e0b\u63cf\u8ff0\uff1a \u591a\u5c42\u795e\u7ecf\u7f51\u7edc\u672c\u8d28\u4e0a\u662f\u4e00\u4e2a\u591a\u5c42\u590d\u5408\u51fd\u6570\uff0c\u6570\u5b66\u662f\u4e00\u95e8\u7b80\u6d01\u4f46\u662f\u542b\u4e49\u4e30\u5bcc\u7684\u539f\u56e0\uff0c\u7b80\u5355\u7684\u516c\u5f0f\uff0c\u4f46\u662f\u80fd\u591f\u8868\u8fbe\u5f3a\u5927\u7684\u7ed3\u6784","title":"\u4f7f\u7528\u4e0d\u540c\u7684\u5b66\u79d1\u7684\u8bed\u8a00\u6765\u8fdb\u884c\u63cf\u8ff0"},{"location":"Language/#programming#model#and#programming#paradigm","text":"\u5728\u4e0d\u540c\u9886\u57df\uff0c\u6709\u7740\u9002\u5408\u4e8e\u8be5\u9886\u57df\u95ee\u9898\u7684\u95ee\u9898\u7684\u63cf\u8ff0\u65b9\u5f0f\uff0c\u8fd9\u5c31\u662f\u6240\u8c13\u7684programming model\u3001programming paradigm\u3002 \u5173\u4e8eprogramming model\uff0c\u53c2\u89c1\u5de5\u7a0bprogramming-language\u7684 Theory\\Programming-model \u7ae0\u8282\u3002 \u5173\u4e8eprogramming paradigm\uff0c\u53c2\u89c1\u5de5\u7a0bprogramming-language\u7684 Theory\\Programming-paradigm \u7ae0\u8282\u3002","title":"Programming model and programming paradigm"},{"location":"Language/#_6","text":"\u5178\u578b\u7684\u4f8b\u5b50\u5c31\u662fC++ iterator\u3001C++ range\u3002iterator\u662f\u4e00\u79cd\u975e\u5e38\u5f3a\u5927\u7684\u62bd\u8c61\u7684\u63cf\u8ff0\u65b9\u5f0f\uff0c\u53ef\u4ee5\u62bd\u8c61\u5730\u63cf\u8ff0container\u3001stream\u3002","title":"\u4f7f\u7528\u66f4\u52a0\u62bd\u8c61\u7684\u8bed\u8a00"},{"location":"Language/#_7","text":"\u6bd4\u5982\u4f7f\u7528DSL\uff1b \u6bd4\u5982\u521b\u9020\u9002\u5408\u4e8e\u8be5\u9886\u57df\u7684\u8bed\u8a00\uff0cJavaScript\u5c31\u662f\u8fd9\u6837\u7684\u4e00\u4e2a\u4f8b\u5b50\uff1b","title":"\u4f7f\u7528\u9002\u5408\u4e8e\u95ee\u9898\u7684\u8bed\u8a00"},{"location":"Language/Language-in-discipline/","text":"\u4e0d\u540c\u5b66\u79d1/\u9886\u57df\u4e2d\u7684\u8bed\u8a00(\u6216\u8005\u8bf4\u8868\u793a\u65b9\u5f0f) \u5404\u79cd\u5b66\u79d1/\u9886\u57df\uff0c\u5728\u8fdb\u884c\u7814\u7a76\u7684\u65f6\u5019\uff0c\u9700\u8981\u4f7f\u7528\u7b80\u6d01\u7684\u8bed\u8a00\u6765**\u63cf\u8ff0**/**\u8868\u793a**\u590d\u6742\u7684\u95ee\u9898\uff0c\u4ee5\u8fbe\u5230 \u62bd\u8c61 \u7684\u76ee\u7684\uff0c\u62bd\u8c61\u7684\u8fc7\u7a0b\u5bf9\u4e8e\u4efb\u4f55\u5b66\u79d1\u7684\u7406\u8bba\u7684\u5efa\u7acb\u90fd\u662f\u81f3\u5173\u91cd\u8981\u7684\uff0c\u56e0\u4e3a\u62bd\u8c61\u7684\u8fc7\u7a0b\u662f\u5bf9\u95ee\u9898\u672c\u8d28\u7684\u9760\u8fd1\u7684\u8fc7\u7a0b\u3002\u56e0\u6b64\u4e0d\u540c\u5b66\u79d1\u5c31\u521b\u9020\u4e86\u8be5\u9886\u57df\u7684\u8bed\u8a00\uff0c\u4e0b\u9762\u603b\u7ed3\u4e86\u4e00\u4e9b\u5e38\u89c1\u7684\u5b66\u79d1\u4e2d\u4f7f\u7528\u7684\u8bed\u8a00(\u6216\u8005\u8bf4\u8868\u793a\u65b9\u5f0f)\uff1a Mathematics \u6570\u5b66\u4e2d\u4f7f\u7528math expression\u6765\u8868\u793a\u8ba1\u7b97\uff0c\u5b83\u662fhuman-readable\u3001machine-readable\u3002 \u53c2\u89c1: wikipedia Expression (mathematics) Computer science computer science\u4e2d\u7684\u8bed\u8a00\uff0c\u88ab\u79f0\u4e3a \u0441omputer language \uff0c\u5728wikipedia \u0441omputer language \u4e2d\u5bf9\u5b83\u8fdb\u884c\u4e86\u975e\u5e38\u597d\u7684\u5206\u7c7b\uff0c\u4e0b\u9762\u662f\u53c2\u8003\u81ea\u5176\u4e2d\u7684\u5206\u7c7b: 1) programming language \u8868\u793a\u7b97\u6cd5\uff0chuman-readable\u3001machine-readable 2) Specification language 3) Interface description language (IDL) human-readable\u3001machine-readable\u3002\u4e0b\u9762\u662f\u4e00\u4e9b\u5e94\u7528\u4e86IDL\u7684\u4e00\u4e9bsoftware: Thrift interface description language \u00b6 protobuf 4) Markup language human-readable\u3001machine-readable\uff0c\u6bd4\u5982: YAML HTML 5) Data modeling languages \u63cf\u8ff0\u7ed3\u6784\u7684\u8bed\u8a00 \u53c2\u89c1 Language\\Language-and-computation\\Language-for-structure \u7ae0\u8282\u3002 Compiler\u4e2d\u7684\u8bed\u8a00 \u5728compiler\u4e2d\u4f7f\u7528\u4e86\u591a\u79cd Intermediate representation \uff0c\u8fd9\u4e9bIR\u90fd\u662f\u5bf9source code\u7684\u4e0d\u540c\u7684\u8868\u793a/\u63cf\u8ff0\u3002 \u53c2\u89c1 1) \u5de5\u7a0bcompiler-principle","title":"Language-in-discipline"},{"location":"Language/Language-in-discipline/#_1","text":"\u5404\u79cd\u5b66\u79d1/\u9886\u57df\uff0c\u5728\u8fdb\u884c\u7814\u7a76\u7684\u65f6\u5019\uff0c\u9700\u8981\u4f7f\u7528\u7b80\u6d01\u7684\u8bed\u8a00\u6765**\u63cf\u8ff0**/**\u8868\u793a**\u590d\u6742\u7684\u95ee\u9898\uff0c\u4ee5\u8fbe\u5230 \u62bd\u8c61 \u7684\u76ee\u7684\uff0c\u62bd\u8c61\u7684\u8fc7\u7a0b\u5bf9\u4e8e\u4efb\u4f55\u5b66\u79d1\u7684\u7406\u8bba\u7684\u5efa\u7acb\u90fd\u662f\u81f3\u5173\u91cd\u8981\u7684\uff0c\u56e0\u4e3a\u62bd\u8c61\u7684\u8fc7\u7a0b\u662f\u5bf9\u95ee\u9898\u672c\u8d28\u7684\u9760\u8fd1\u7684\u8fc7\u7a0b\u3002\u56e0\u6b64\u4e0d\u540c\u5b66\u79d1\u5c31\u521b\u9020\u4e86\u8be5\u9886\u57df\u7684\u8bed\u8a00\uff0c\u4e0b\u9762\u603b\u7ed3\u4e86\u4e00\u4e9b\u5e38\u89c1\u7684\u5b66\u79d1\u4e2d\u4f7f\u7528\u7684\u8bed\u8a00(\u6216\u8005\u8bf4\u8868\u793a\u65b9\u5f0f)\uff1a","title":"\u4e0d\u540c\u5b66\u79d1/\u9886\u57df\u4e2d\u7684\u8bed\u8a00(\u6216\u8005\u8bf4\u8868\u793a\u65b9\u5f0f)"},{"location":"Language/Language-in-discipline/#mathematics","text":"\u6570\u5b66\u4e2d\u4f7f\u7528math expression\u6765\u8868\u793a\u8ba1\u7b97\uff0c\u5b83\u662fhuman-readable\u3001machine-readable\u3002 \u53c2\u89c1: wikipedia Expression (mathematics)","title":"Mathematics"},{"location":"Language/Language-in-discipline/#computer#science","text":"computer science\u4e2d\u7684\u8bed\u8a00\uff0c\u88ab\u79f0\u4e3a \u0441omputer language \uff0c\u5728wikipedia \u0441omputer language \u4e2d\u5bf9\u5b83\u8fdb\u884c\u4e86\u975e\u5e38\u597d\u7684\u5206\u7c7b\uff0c\u4e0b\u9762\u662f\u53c2\u8003\u81ea\u5176\u4e2d\u7684\u5206\u7c7b: 1) programming language \u8868\u793a\u7b97\u6cd5\uff0chuman-readable\u3001machine-readable 2) Specification language 3) Interface description language (IDL) human-readable\u3001machine-readable\u3002\u4e0b\u9762\u662f\u4e00\u4e9b\u5e94\u7528\u4e86IDL\u7684\u4e00\u4e9bsoftware: Thrift interface description language \u00b6 protobuf 4) Markup language human-readable\u3001machine-readable\uff0c\u6bd4\u5982: YAML HTML 5) Data modeling languages","title":"Computer science"},{"location":"Language/Language-in-discipline/#_2","text":"\u53c2\u89c1 Language\\Language-and-computation\\Language-for-structure \u7ae0\u8282\u3002","title":"\u63cf\u8ff0\u7ed3\u6784\u7684\u8bed\u8a00"},{"location":"Language/Language-in-discipline/#compiler","text":"\u5728compiler\u4e2d\u4f7f\u7528\u4e86\u591a\u79cd Intermediate representation \uff0c\u8fd9\u4e9bIR\u90fd\u662f\u5bf9source code\u7684\u4e0d\u540c\u7684\u8868\u793a/\u63cf\u8ff0\u3002 \u53c2\u89c1 1) \u5de5\u7a0bcompiler-principle","title":"Compiler\u4e2d\u7684\u8bed\u8a00"},{"location":"Language/Classification/","text":"Classification of language \u8bed\u8a00\u7684\u5206\u7c7b\u65b9\u6cd5\u662f\u975e\u5e38\u591a\u7684\uff0c\u5728wikipedia Language \u4e2d\u7ed9\u51fa \u4e86language\u7684\u7b80\u5355\u5206\u7c7b\u65b9\u6cd5: 1) Constructed language \u4eba\u9020\u8bed\u8a00 2) Natural languages \u81ea\u7136\u8bed\u8a00 3) Formal language \u5f62\u5f0f\u8bed\u8a00 Programming language \u5373\"\u7f16\u7a0b\u8bed\u8a00\"\uff0c\u5b83\u662f\u4e00\u79cd formal language\u3002\u540e\u9762\u4f1a\u5bf9\u5b83\u8fdb\u884c\u8be6\u7ec6\u4ecb\u7ecd\u3002 \u9700\u8981\u6ce8\u610f\u7684\u662f: Formal language \u4e0d\u662f natural language \u3002 \u9664\u4e86\u4e0a\u8ff0\u5206\u7c7b\u65b9\u6cd5\uff0c\u8fd8\u5305\u62ec\u5982\u4e0b\u5206\u7c7b\u65b9\u6cd5: 1) GPL and DSL\uff0c\u53c2\u89c1 ./GPL-and-DSL 2) Official and dialect\uff0c\u53c2\u89c1 Official-and-dialect \u5f62\u5f0f\u8bed\u8a00 \u79d1\u5b66\u9700\u8981\u4e25\u8c28\u7684\u3001\u51c6\u786e\u7684\u63cf\u8ff0\u65b9\u5f0f\uff0c\u6240\u4ee5\u5b83\u4f7f\u7528\u7684\u8bed\u8a00\u4e0d\u540c\u4e8e\u4eba\u7c7b\u8bf4\u8bdd\u65f6\u4f7f\u7528\u7684 \u81ea\u7136\u8bed\u8a00 \uff0c\u5728\u79d1\u5b66\u4e2d\uff0c\u5f80\u5f80\u4f7f\u7528\u7684\u4e00\u79cd\u53eb\u505a formal language \u7684\u8bed\u8a00\uff0c\u8fd9\u7c7b\u8bed\u8a00\u6709\u7740\u8bf8\u591a\u4f18\u826f\u7684\u7279\u6027\uff0c\u5b83\u662f\u5f88\u591a\u5b66\u79d1\u7684\u57fa\u7840\u3002\u5b83\u76f8\u8f83\u4e8e \u81ea\u7136\u8bed\u8a00 \uff0c\u6709\u7740\u8bf8\u591a\u4f18\u52bf\uff0c\u5176\u4e2d\u4e00\u4e2a\u4f18\u52bf\u5c31\u662f machine-readable\uff0c\u6240\u4ee5\u8fd9\u4e5f\u662f\u5b83\u5438\u5f15\u8ba1\u7b97\u673a\u79d1\u5b66\u5bb6\u7684\u4e00\u4e2a\u539f\u56e0\u3002\u5728\u4e0b\u7ae0\u5c06\u5bf9\u5176\u8fdb\u884c\u8be6\u7ec6\u8ba8\u8bba\u3002","title":"Introduction"},{"location":"Language/Classification/#classification#of#language","text":"\u8bed\u8a00\u7684\u5206\u7c7b\u65b9\u6cd5\u662f\u975e\u5e38\u591a\u7684\uff0c\u5728wikipedia Language \u4e2d\u7ed9\u51fa \u4e86language\u7684\u7b80\u5355\u5206\u7c7b\u65b9\u6cd5: 1) Constructed language \u4eba\u9020\u8bed\u8a00 2) Natural languages \u81ea\u7136\u8bed\u8a00 3) Formal language \u5f62\u5f0f\u8bed\u8a00 Programming language \u5373\"\u7f16\u7a0b\u8bed\u8a00\"\uff0c\u5b83\u662f\u4e00\u79cd formal language\u3002\u540e\u9762\u4f1a\u5bf9\u5b83\u8fdb\u884c\u8be6\u7ec6\u4ecb\u7ecd\u3002 \u9700\u8981\u6ce8\u610f\u7684\u662f: Formal language \u4e0d\u662f natural language \u3002 \u9664\u4e86\u4e0a\u8ff0\u5206\u7c7b\u65b9\u6cd5\uff0c\u8fd8\u5305\u62ec\u5982\u4e0b\u5206\u7c7b\u65b9\u6cd5: 1) GPL and DSL\uff0c\u53c2\u89c1 ./GPL-and-DSL 2) Official and dialect\uff0c\u53c2\u89c1 Official-and-dialect","title":"Classification of language"},{"location":"Language/Classification/#_1","text":"\u79d1\u5b66\u9700\u8981\u4e25\u8c28\u7684\u3001\u51c6\u786e\u7684\u63cf\u8ff0\u65b9\u5f0f\uff0c\u6240\u4ee5\u5b83\u4f7f\u7528\u7684\u8bed\u8a00\u4e0d\u540c\u4e8e\u4eba\u7c7b\u8bf4\u8bdd\u65f6\u4f7f\u7528\u7684 \u81ea\u7136\u8bed\u8a00 \uff0c\u5728\u79d1\u5b66\u4e2d\uff0c\u5f80\u5f80\u4f7f\u7528\u7684\u4e00\u79cd\u53eb\u505a formal language \u7684\u8bed\u8a00\uff0c\u8fd9\u7c7b\u8bed\u8a00\u6709\u7740\u8bf8\u591a\u4f18\u826f\u7684\u7279\u6027\uff0c\u5b83\u662f\u5f88\u591a\u5b66\u79d1\u7684\u57fa\u7840\u3002\u5b83\u76f8\u8f83\u4e8e \u81ea\u7136\u8bed\u8a00 \uff0c\u6709\u7740\u8bf8\u591a\u4f18\u52bf\uff0c\u5176\u4e2d\u4e00\u4e2a\u4f18\u52bf\u5c31\u662f machine-readable\uff0c\u6240\u4ee5\u8fd9\u4e5f\u662f\u5b83\u5438\u5f15\u8ba1\u7b97\u673a\u79d1\u5b66\u5bb6\u7684\u4e00\u4e2a\u539f\u56e0\u3002\u5728\u4e0b\u7ae0\u5c06\u5bf9\u5176\u8fdb\u884c\u8be6\u7ec6\u8ba8\u8bba\u3002","title":"\u5f62\u5f0f\u8bed\u8a00"},{"location":"Language/Classification/GPL-and-DSL/","text":"GPL and DSL GPL \u662f\u6307 general-purpose language\uff0cDSL \u662f\u6307 domain-specific language\u3002 General purpose language wikipedia General purpose language Domain-specific language \u53c2\u89c1 Domain-specific-language \u7ae0\u8282\u3002","title":"GPL-and-DSL"},{"location":"Language/Classification/GPL-and-DSL/#gpl#and#dsl","text":"GPL \u662f\u6307 general-purpose language\uff0cDSL \u662f\u6307 domain-specific language\u3002","title":"GPL and DSL"},{"location":"Language/Classification/GPL-and-DSL/#general#purpose#language","text":"wikipedia General purpose language","title":"General purpose language"},{"location":"Language/Classification/GPL-and-DSL/#domain-specific#language","text":"\u53c2\u89c1 Domain-specific-language \u7ae0\u8282\u3002","title":"Domain-specific language"},{"location":"Language/Classification/Host-and-embeded-and-meta/","text":"Host language \u7ecf\u5e38\u4f1a\u51fa\u73b0\u591a\u79cdlanguage\u7684\u540c\u65f6\u8fd0\u7528\u3002 Host language and DSL Host language\u662f\u4e00\u79cdgeneral programming language\uff0c\u53ef\u4ee5\u7528\u5b83\u6765\u63cf\u8ff0 DSL\u3002 Examples: 1) deep learning\u4e2d\u4f7f\u7528Python API\u6765\u63cf\u8ff0 computational graph \u8be6\u89c1: Deep Learning Programming Paradigm Host langauge and meta language Examples 1) C++ template meta programming \u53c2\u89c1 C-family-language\\C++\\Language-reference\\Template\\Template-metaprogramming \u7ae0\u8282\u3002","title":"Host-and-embeded-and-meta"},{"location":"Language/Classification/Host-and-embeded-and-meta/#host#language","text":"\u7ecf\u5e38\u4f1a\u51fa\u73b0\u591a\u79cdlanguage\u7684\u540c\u65f6\u8fd0\u7528\u3002","title":"Host language"},{"location":"Language/Classification/Host-and-embeded-and-meta/#host#language#and#dsl","text":"Host language\u662f\u4e00\u79cdgeneral programming language\uff0c\u53ef\u4ee5\u7528\u5b83\u6765\u63cf\u8ff0 DSL\u3002","title":"Host language and DSL"},{"location":"Language/Classification/Host-and-embeded-and-meta/#examples","text":"1) deep learning\u4e2d\u4f7f\u7528Python API\u6765\u63cf\u8ff0 computational graph \u8be6\u89c1: Deep Learning Programming Paradigm","title":"Examples:"},{"location":"Language/Classification/Host-and-embeded-and-meta/#host#langauge#and#meta#language","text":"","title":"Host langauge and meta language"},{"location":"Language/Classification/Host-and-embeded-and-meta/#examples_1","text":"1) C++ template meta programming \u53c2\u89c1 C-family-language\\C++\\Language-reference\\Template\\Template-metaprogramming \u7ae0\u8282\u3002","title":"Examples"},{"location":"Language/Classification/Official-and-dialect/","text":"Official and dialect \u5b98\u8bdd\u548c\u65b9\u8a00\u3002 Dialect What is dialect? wikipedia Dialect SQL dialect microsoft SQL Dialect C/C++ dialect gcc 3.4 Options Controlling C Dialect gcc 3.5 Options Controlling C++ Dialect","title":"Official-and-dialect"},{"location":"Language/Classification/Official-and-dialect/#official#and#dialect","text":"\u5b98\u8bdd\u548c\u65b9\u8a00\u3002","title":"Official and dialect"},{"location":"Language/Classification/Official-and-dialect/#dialect","text":"","title":"Dialect"},{"location":"Language/Classification/Official-and-dialect/#what#is#dialect","text":"wikipedia Dialect","title":"What is dialect?"},{"location":"Language/Classification/Official-and-dialect/#sql#dialect","text":"microsoft SQL Dialect","title":"SQL dialect"},{"location":"Language/Classification/Official-and-dialect/#cc#dialect","text":"gcc 3.4 Options Controlling C Dialect gcc 3.5 Options Controlling C++ Dialect","title":"C/C++ dialect"},{"location":"Language/Classification/Domain-specific-language/","text":"Domain-specific language wikipedia Domain-specific language Example \u4e0b\u9762\u662f\u4e00\u4e9b\u4f8b\u5b50: 1\u3001 SQL SQL is a domain-specific language used in programming and designed for managing data held in a relational database management system, or for stream processing in a relational data stream management system. It is particularly useful in handling structured data , i.e. data incorporating relations among entities and variables. 2\u3001Zephyr-ASDL \u53c2\u89c1 Zephyr-ASDL \u7ae0\u8282\u3002 3\u3001 Gherkin language","title":"Introduction"},{"location":"Language/Classification/Domain-specific-language/#domain-specific#language","text":"","title":"Domain-specific language"},{"location":"Language/Classification/Domain-specific-language/#wikipedia#domain-specific#language","text":"","title":"wikipedia Domain-specific language"},{"location":"Language/Classification/Domain-specific-language/#example","text":"\u4e0b\u9762\u662f\u4e00\u4e9b\u4f8b\u5b50:","title":"Example"},{"location":"Language/Classification/Domain-specific-language/#1sql","text":"SQL is a domain-specific language used in programming and designed for managing data held in a relational database management system, or for stream processing in a relational data stream management system. It is particularly useful in handling structured data , i.e. data incorporating relations among entities and variables.","title":"1\u3001SQL"},{"location":"Language/Classification/Domain-specific-language/#2zephyr-asdl","text":"\u53c2\u89c1 Zephyr-ASDL \u7ae0\u8282\u3002","title":"2\u3001Zephyr-ASDL"},{"location":"Language/Classification/Domain-specific-language/#3gherkin#language","text":"","title":"3\u3001Gherkin language"},{"location":"Language/Classification/Domain-specific-language/martinfowler-Domain-Specific-Languages/","text":"martinfowler Domain Specific Languages","title":"Introduction"},{"location":"Language/Classification/Domain-specific-language/martinfowler-Domain-Specific-Languages/#martinfowler#domain#specific#languages","text":"","title":"martinfowler Domain Specific Languages"},{"location":"Language/Expressive-power/","text":"Expressive power Mathematics can communicate a range of meanings that is as wide as (although different from) that of a natural language . \u8fd9\u6bb5\u8bdd\u5411\u6211\u4eec\u4f20\u8fbe\u4e86\u8fd9\u6837\u7684\u542b\u4e49\uff1a\u4e0d\u540c\u7684\u8bed\u8a00 \u6240\u80fd\u591f\u63cf\u8ff0\u7684meaning\u7684\u8303\u56f4 \u662f\u4e0d\u540c\u7684\u3002\u4e0b\u9762\u6211\u4eec\u4f7f\u7528\u96c6\u5408\u7684\u89c2\u70b9\u6765\u63cf\u8ff0\u8fd9\u4e2a\u542b\u4e49\uff1a\u5982\u679c\u6211\u4eec\u5c06\u8bed\u8a00\u201c\u6240\u80fd\u591f\u63cf\u8ff0\u7684meaning\u201d\u653e\u5230\u4e00\u4e2a\u96c6\u5408\u4e2d\uff0c\u628a\u8fd9\u4e2a\u96c6\u5408\u79f0\u4e3a meaning set\uff0c\u90a3\u4e48\u4e0d\u540c\u8bed\u8a00\u7684meaning set\u7684\u5927\u5c0f\u662f\u4e0d\u540c\u7684\u3002\u4f7f\u7528\u6211\u4eec\u7684\u81ea\u7136\u8bed\u8a00\u6765\u63cf\u8ff0\u5c31\u662f\uff1a\u6709\u7684\u8bed\u8a00\u80fd\u591f\u63cf\u8ff0\u7684\u8303\u56f4\u66f4\u5927\u3001\u6709\u7684\u8bed\u8a00\u65e0\u6cd5\u63cf\u8ff0\u53e6\u5916\u4e00\u4e2a\u8bed\u8a00\u6240\u8868\u8fbe\u7684\u3002\u8fd9\u5c31\u662f\u672c\u8282\u6807\u9898\u4e2d\u7684\u201cexpressive power\u201d\u7684\u542b\u4e49\u3002 \u5173\u4e8eexpressive power\uff0c\u53c2\u89c1\uff1a \u7ef4\u57fa\u767e\u79d1 Expressive power \u7ef4\u57fa\u767e\u79d1 Combinatory categorial grammar \uff08\u5176\u4e2d\u63d0\u53ca\u4e86expressive power\uff09 Chomsky hierarchy \u5173\u4e8eexpressive power\u7684\u53e6\u5916\u4e00\u4e2a\u975e\u5e38\u7ecf\u5178\u7684\u6848\u4f8b\u662f: Chomsky hierarchy\uff0c\u53c2\u89c1 Formal-language \u7ae0\u8282\u3002","title":"Introduction"},{"location":"Language/Expressive-power/#expressive#power","text":"Mathematics can communicate a range of meanings that is as wide as (although different from) that of a natural language . \u8fd9\u6bb5\u8bdd\u5411\u6211\u4eec\u4f20\u8fbe\u4e86\u8fd9\u6837\u7684\u542b\u4e49\uff1a\u4e0d\u540c\u7684\u8bed\u8a00 \u6240\u80fd\u591f\u63cf\u8ff0\u7684meaning\u7684\u8303\u56f4 \u662f\u4e0d\u540c\u7684\u3002\u4e0b\u9762\u6211\u4eec\u4f7f\u7528\u96c6\u5408\u7684\u89c2\u70b9\u6765\u63cf\u8ff0\u8fd9\u4e2a\u542b\u4e49\uff1a\u5982\u679c\u6211\u4eec\u5c06\u8bed\u8a00\u201c\u6240\u80fd\u591f\u63cf\u8ff0\u7684meaning\u201d\u653e\u5230\u4e00\u4e2a\u96c6\u5408\u4e2d\uff0c\u628a\u8fd9\u4e2a\u96c6\u5408\u79f0\u4e3a meaning set\uff0c\u90a3\u4e48\u4e0d\u540c\u8bed\u8a00\u7684meaning set\u7684\u5927\u5c0f\u662f\u4e0d\u540c\u7684\u3002\u4f7f\u7528\u6211\u4eec\u7684\u81ea\u7136\u8bed\u8a00\u6765\u63cf\u8ff0\u5c31\u662f\uff1a\u6709\u7684\u8bed\u8a00\u80fd\u591f\u63cf\u8ff0\u7684\u8303\u56f4\u66f4\u5927\u3001\u6709\u7684\u8bed\u8a00\u65e0\u6cd5\u63cf\u8ff0\u53e6\u5916\u4e00\u4e2a\u8bed\u8a00\u6240\u8868\u8fbe\u7684\u3002\u8fd9\u5c31\u662f\u672c\u8282\u6807\u9898\u4e2d\u7684\u201cexpressive power\u201d\u7684\u542b\u4e49\u3002 \u5173\u4e8eexpressive power\uff0c\u53c2\u89c1\uff1a \u7ef4\u57fa\u767e\u79d1 Expressive power \u7ef4\u57fa\u767e\u79d1 Combinatory categorial grammar \uff08\u5176\u4e2d\u63d0\u53ca\u4e86expressive power\uff09","title":"Expressive power"},{"location":"Language/Expressive-power/#chomsky#hierarchy","text":"\u5173\u4e8eexpressive power\u7684\u53e6\u5916\u4e00\u4e2a\u975e\u5e38\u7ecf\u5178\u7684\u6848\u4f8b\u662f: Chomsky hierarchy\uff0c\u53c2\u89c1 Formal-language \u7ae0\u8282\u3002","title":"Chomsky hierarchy"},{"location":"Language/Language-agnostic/","text":"Language-agnostic softwareengineering What is language-agnosticism and why is it called that? softwareengineering What should I do to be language-agnostic?","title":"Introduction"},{"location":"Language/Language-agnostic/#language-agnostic","text":"","title":"Language-agnostic"},{"location":"Language/Language-agnostic/#softwareengineering#what#is#language-agnosticism#and#why#is#it#called#that","text":"","title":"softwareengineering What is language-agnosticism and why is it called that?"},{"location":"Language/Language-agnostic/#softwareengineering#what#should#i#do#to#be#language-agnostic","text":"","title":"softwareengineering What should I do to be language-agnostic?"},{"location":"Language/Language-and-computation/","text":"Language and computation \u4f5c\u4e3a\u8f6f\u4ef6\u5de5\u7a0b\u5e08\uff0c\u6211\u4eec\u9700\u8981\u4ececomputation\u7684\u89d2\u5ea6\u6765\u601d\u8003language\uff0c\u6211\u4eec\u9700\u8981\u601d\u8003language \u548c computation\u4e4b\u95f4\u7684\u5173\u8054\u3002 \u5728\u5de5\u7a0bdiscrete\u7684 Relation-structure-computation\\Structuralization-and-formalization \u7ae0\u8282\u4e2d\uff0c\u63d0\u51fa\u4e86\u5982\u4e0b\u89c2\u70b9: \u53ea\u6709**\u7ed3\u6784\u5316**\u540e\uff0c\u624d\u80fd\u591f\u8fdb\u884c\u8ba1\u7b97 \u56e0\u6b64: 1) \u6211\u4eec\u9700\u8981\u63cf\u8ff0\u7ed3\u6784\u7684\u8bed\u8a00 2) \u6211\u4eec\u9700\u8981\u63cf\u8ff0\u8bed\u8a00\u7684**\u7ed3\u6784** \u63cf\u8ff0\u8bed\u8a00\u7684\u7ed3\u6784 \u5728linguistic\u4e2d\uff0cgrammar\u662f\u5bf9\u8bed\u8a00\u7684\u7ed3\u6784\u7684\u63cf\u8ff0\u3002\u53ea\u6709\u5bf9\u8bed\u8a00\u7684\u7ed3\u6784\u8fdb\u884c\u5b8c\u6574\u5b9a\u4e49\u540e\uff0c\u624d\u80fd\u591f\u5bf9language\u8fdb\u884ccompute\uff0c\u8fd9\u662f\u8ba1\u7b97\u8bed\u8a00\u5b66\u4e2d\u7684\u91cd\u8981\u4e3b\u9898\uff0c\u5176\u4e2d\u5c31\u5305\u62eccompiler principle\u3002 \u5728 ./Structure-of-language \u4e2d\u5c06\u5bf9\u8fd9\u4e2a\u4e3b\u9898\u8fdb\u884c\u5c55\u5f00\u3002 \u63cf\u8ff0\u7ed3\u6784\u7684\u8bed\u8a00 \u5728 ./Language-for-structure \u4e2d\u5c06\u5bf9\u8fd9\u4e2a\u4e3b\u9898\u8fdb\u884c\u5c55\u5f00\u3002","title":"Introduction"},{"location":"Language/Language-and-computation/#language#and#computation","text":"\u4f5c\u4e3a\u8f6f\u4ef6\u5de5\u7a0b\u5e08\uff0c\u6211\u4eec\u9700\u8981\u4ececomputation\u7684\u89d2\u5ea6\u6765\u601d\u8003language\uff0c\u6211\u4eec\u9700\u8981\u601d\u8003language \u548c computation\u4e4b\u95f4\u7684\u5173\u8054\u3002 \u5728\u5de5\u7a0bdiscrete\u7684 Relation-structure-computation\\Structuralization-and-formalization \u7ae0\u8282\u4e2d\uff0c\u63d0\u51fa\u4e86\u5982\u4e0b\u89c2\u70b9: \u53ea\u6709**\u7ed3\u6784\u5316**\u540e\uff0c\u624d\u80fd\u591f\u8fdb\u884c\u8ba1\u7b97 \u56e0\u6b64: 1) \u6211\u4eec\u9700\u8981\u63cf\u8ff0\u7ed3\u6784\u7684\u8bed\u8a00 2) \u6211\u4eec\u9700\u8981\u63cf\u8ff0\u8bed\u8a00\u7684**\u7ed3\u6784**","title":"Language and computation"},{"location":"Language/Language-and-computation/#_1","text":"\u5728linguistic\u4e2d\uff0cgrammar\u662f\u5bf9\u8bed\u8a00\u7684\u7ed3\u6784\u7684\u63cf\u8ff0\u3002\u53ea\u6709\u5bf9\u8bed\u8a00\u7684\u7ed3\u6784\u8fdb\u884c\u5b8c\u6574\u5b9a\u4e49\u540e\uff0c\u624d\u80fd\u591f\u5bf9language\u8fdb\u884ccompute\uff0c\u8fd9\u662f\u8ba1\u7b97\u8bed\u8a00\u5b66\u4e2d\u7684\u91cd\u8981\u4e3b\u9898\uff0c\u5176\u4e2d\u5c31\u5305\u62eccompiler principle\u3002 \u5728 ./Structure-of-language \u4e2d\u5c06\u5bf9\u8fd9\u4e2a\u4e3b\u9898\u8fdb\u884c\u5c55\u5f00\u3002","title":"\u63cf\u8ff0\u8bed\u8a00\u7684\u7ed3\u6784"},{"location":"Language/Language-and-computation/#_2","text":"\u5728 ./Language-for-structure \u4e2d\u5c06\u5bf9\u8fd9\u4e2a\u4e3b\u9898\u8fdb\u884c\u5c55\u5f00\u3002","title":"\u63cf\u8ff0\u7ed3\u6784\u7684\u8bed\u8a00"},{"location":"Language/Language-and-computation/Language-for-structure/","text":"\u63cf\u8ff0\u7ed3\u6784\u7684\u8bed\u8a00 \u5728\u5de5\u7a0b\u5de5\u7a0bdiscrete\u7684 Relation-structure-computation\\Structuralization-and-formalization \u7ae0\u8282\u4e2d\u63d0\u51fa\u4e86\u7ed3\u6784\u5316\uff0c\u5728\u5176\u4e2d\u6211\u4eec\u5df2\u7ecf\u603b\u7ed3\u4e86\u4ece\u8bed\u8a00\u5b66\u7684\u89d2\u5ea6\u6765\u770b\u5f85\u7ed3\u6784\u5316\u3002 Formal grammar\u662f\u5bf9language structure\u7684\u7ed3\u6784\u7684\u63cf\u8ff0\uff0c\u5b83\u4f7f\u7528**symbol expression**\u6765\u4f5c\u4e3a\u63cf\u8ff0\u8bed\u8a00\uff0csymbol expression\u662f\u4e00\u79cd\u975e\u5e38\u597d\u7684\u63cf\u8ff0\u7ed3\u6784\u7684\u65b9\u5f0f\u3002 symbol expression\uff0c\u5728\u5de5\u7a0bprogramming-language\u7684 Expression-oriented-language \u7ae0\u8282\u8fdb\u884c\u4e86\u4ecb\u7ecd\u3002 \u4e0b\u9762\u662f\u4e00\u4e9b\u6848\u4f8b: Abstract syntax description language(ASDL) \u5728\u8bba\u6587 The Zephyr Abstract Syntax Description Language \u4e2d\u6709\u8fd9\u6837\u7684\u603b\u7ed3\uff1a Regular expressions describe lexical structures of programming languages. Context free grammars describe syntactic structures of programming languages . ASDL describes the abstract syntax of compiler intermediate representations (IRs) and other tree-like data structures. Algebraic data types \u8bed\u8a00\u5b66\u4e2d\u7684\u63cf\u8ff0\u7ed3\u6784\u7684\u8bed\u8a00 \u5728\u8bed\u8a00\u5b66\u4e2d\uff0c grammar \u6765\u63cf\u8ff0\u8bed\u8a00\u7684\u7ed3\u6784\uff0c formal language \u7684grammar\u662f formal grammar \uff0c\u6bd4\u5982 context free grammar \u3002 Production (computer science) \u5e38\u5e38\u7528\u6765\u8868\u793a context free grammar \u3002 Markup language \u5404\u79cdMarkup language\u5176\u5b9e\u4e5f\u662f\u5728\u63cf\u8ff0\u6587\u4ef6\u7684\u7ed3\u6784\u3002 See also \u5728\u6211\u7684\u5de5\u7a0b data-structure \u7ed9\u51fa\u4e86\u5404\u79cd\u6570\u636e\u7ed3\u6784\u7684\u63cf\u8ff0\u65b9\u5f0f\uff0c\u4e0b\u9762\u7ed9\u51fa\u94fe\u63a5\uff1a https://github.com/dengking/data-structure/blob/master/docs/tree/representing-trees.md","title":"Introduction"},{"location":"Language/Language-and-computation/Language-for-structure/#_1","text":"\u5728\u5de5\u7a0b\u5de5\u7a0bdiscrete\u7684 Relation-structure-computation\\Structuralization-and-formalization \u7ae0\u8282\u4e2d\u63d0\u51fa\u4e86\u7ed3\u6784\u5316\uff0c\u5728\u5176\u4e2d\u6211\u4eec\u5df2\u7ecf\u603b\u7ed3\u4e86\u4ece\u8bed\u8a00\u5b66\u7684\u89d2\u5ea6\u6765\u770b\u5f85\u7ed3\u6784\u5316\u3002 Formal grammar\u662f\u5bf9language structure\u7684\u7ed3\u6784\u7684\u63cf\u8ff0\uff0c\u5b83\u4f7f\u7528**symbol expression**\u6765\u4f5c\u4e3a\u63cf\u8ff0\u8bed\u8a00\uff0csymbol expression\u662f\u4e00\u79cd\u975e\u5e38\u597d\u7684\u63cf\u8ff0\u7ed3\u6784\u7684\u65b9\u5f0f\u3002 symbol expression\uff0c\u5728\u5de5\u7a0bprogramming-language\u7684 Expression-oriented-language \u7ae0\u8282\u8fdb\u884c\u4e86\u4ecb\u7ecd\u3002 \u4e0b\u9762\u662f\u4e00\u4e9b\u6848\u4f8b:","title":"\u63cf\u8ff0\u7ed3\u6784\u7684\u8bed\u8a00"},{"location":"Language/Language-and-computation/Language-for-structure/#abstract#syntax#description#languageasdl","text":"\u5728\u8bba\u6587 The Zephyr Abstract Syntax Description Language \u4e2d\u6709\u8fd9\u6837\u7684\u603b\u7ed3\uff1a Regular expressions describe lexical structures of programming languages. Context free grammars describe syntactic structures of programming languages . ASDL describes the abstract syntax of compiler intermediate representations (IRs) and other tree-like data structures.","title":"Abstract syntax description language(ASDL)"},{"location":"Language/Language-and-computation/Language-for-structure/#algebraic#data#types","text":"","title":"Algebraic data types"},{"location":"Language/Language-and-computation/Language-for-structure/#_2","text":"\u5728\u8bed\u8a00\u5b66\u4e2d\uff0c grammar \u6765\u63cf\u8ff0\u8bed\u8a00\u7684\u7ed3\u6784\uff0c formal language \u7684grammar\u662f formal grammar \uff0c\u6bd4\u5982 context free grammar \u3002 Production (computer science) \u5e38\u5e38\u7528\u6765\u8868\u793a context free grammar \u3002","title":"\u8bed\u8a00\u5b66\u4e2d\u7684\u63cf\u8ff0\u7ed3\u6784\u7684\u8bed\u8a00"},{"location":"Language/Language-and-computation/Language-for-structure/#markup#language","text":"\u5404\u79cdMarkup language\u5176\u5b9e\u4e5f\u662f\u5728\u63cf\u8ff0\u6587\u4ef6\u7684\u7ed3\u6784\u3002","title":"Markup language"},{"location":"Language/Language-and-computation/Language-for-structure/#see#also","text":"\u5728\u6211\u7684\u5de5\u7a0b data-structure \u7ed9\u51fa\u4e86\u5404\u79cd\u6570\u636e\u7ed3\u6784\u7684\u63cf\u8ff0\u65b9\u5f0f\uff0c\u4e0b\u9762\u7ed9\u51fa\u94fe\u63a5\uff1a https://github.com/dengking/data-structure/blob/master/docs/tree/representing-trees.md","title":"See also"},{"location":"Language/Language-and-computation/Language-for-structure/Zephyr-ASDL/","text":"Abstract Syntax Description Language \u5173\u4e8eASDL\uff0c\u8bba\u6587 The Zephyr Abstract Syntax Description Language \u8fdb\u884c\u4e86\u975e\u5e38\u597d\u7684\u9610\u8ff0\u3002 sourceforge Zephyr ASDL Home Page Introduction The Zephyr Abstract Syntax Description Language (ASDL) is a language designed to describe the tree-like data structures in compilers. Its main goal is to provide a method for compiler components written in different languages to interoperate. ASDL makes it easier for applications written in a variety of programming languages to communicate complex recursive data structures. asdlGen is a tool that takes ASDL descriptions and produces implementations of those descriptions in a variety of popular languages. ASDL and asdlGen together provide the following advantages Concise descriptions of important data structures. Automatic generation of data structure implementations for C, C++ , Java, Standard ML, and Haskell. Automatic generation of functions to read and write the data structures to disk in a machine and language independent way. ASDL descriptions describe the tree-like data structures such as abstract syntax trees (ASTs) and compiler intermediate representations (IRs). Tools such as asdlGen automatically produce the equivalent data structure definitions for C, C++ , Java, Standard ML, OCaml, and Haskell. asdlGen also produces functions for each language that read and write the data structures to and from a platform and language independent sequence of bytes. The sequence of bytes is called a pickle . ASDL pickles can be interactively viewed and edited with a graphical browser , or pretty printed into a simple textual format. The browser provides some advanced features such as display styles and tree based versions of standard unix tools such as diff and grep . ASDL was part of the Zephyr National Compiler Infrastructure project.","title":"Introduction"},{"location":"Language/Language-and-computation/Language-for-structure/Zephyr-ASDL/#abstract#syntax#description#language","text":"\u5173\u4e8eASDL\uff0c\u8bba\u6587 The Zephyr Abstract Syntax Description Language \u8fdb\u884c\u4e86\u975e\u5e38\u597d\u7684\u9610\u8ff0\u3002","title":"Abstract Syntax Description Language"},{"location":"Language/Language-and-computation/Language-for-structure/Zephyr-ASDL/#sourceforge#zephyr#asdl#home#page","text":"","title":"sourceforge Zephyr ASDL Home Page"},{"location":"Language/Language-and-computation/Language-for-structure/Zephyr-ASDL/#introduction","text":"The Zephyr Abstract Syntax Description Language (ASDL) is a language designed to describe the tree-like data structures in compilers. Its main goal is to provide a method for compiler components written in different languages to interoperate. ASDL makes it easier for applications written in a variety of programming languages to communicate complex recursive data structures. asdlGen is a tool that takes ASDL descriptions and produces implementations of those descriptions in a variety of popular languages. ASDL and asdlGen together provide the following advantages Concise descriptions of important data structures. Automatic generation of data structure implementations for C, C++ , Java, Standard ML, and Haskell. Automatic generation of functions to read and write the data structures to disk in a machine and language independent way. ASDL descriptions describe the tree-like data structures such as abstract syntax trees (ASTs) and compiler intermediate representations (IRs). Tools such as asdlGen automatically produce the equivalent data structure definitions for C, C++ , Java, Standard ML, OCaml, and Haskell. asdlGen also produces functions for each language that read and write the data structures to and from a platform and language independent sequence of bytes. The sequence of bytes is called a pickle . ASDL pickles can be interactively viewed and edited with a graphical browser , or pretty printed into a simple textual format. The browser provides some advanced features such as display styles and tree based versions of standard unix tools such as diff and grep . ASDL was part of the Zephyr National Compiler Infrastructure project.","title":"Introduction"},{"location":"Language/Language-and-computation/Language-for-structure/Zephyr-ASDL/paper-The-Zephyr-Abstract-Syntax-Description-Language/","text":"The Zephyr Abstract Syntax Description Language","title":"Introduction"},{"location":"Language/Language-and-computation/Language-for-structure/Zephyr-ASDL/paper-The-Zephyr-Abstract-Syntax-Description-Language/#the#zephyr#abstract#syntax#description#language","text":"","title":"The Zephyr Abstract Syntax Description Language"},{"location":"Language/Language-and-computation/Language-for-structure/Zephyr-ASDL/thegreenplace-Using-ASDL-to-describe-ASTs-in-compilers/","text":"thegreenplace Using ASDL to describe ASTs in compilers ASTs (Abstract Syntax Trees) are an important data structure in compiler front-ends. If you've written a few parsers, you almost definitely ran into the need to describe the result of the parsing in terms of an AST. While the kinds of nodes such ASTs have and their structure is very specific to the source language, many commonalities come up. In other words, coding \"yet another AST\" gets really old after you've done it a few times. Worry not, as you'd expect from the programmer crowd, this problem was \"solved\" by adding another level of abstraction. Yes, an abstraction over Abstract Syntax Trees, oh my! The abstraction here is some textual format (let's call it a DSL to sound smart) that describes what the AST looks like, along with machinery to auto-generate the code that implements this AST. Most solutions in this domain are ad-hoc, but one that I've seen used more than once is ASDL - Abstract Syntax Definition Language. The self-description from the website sounds about right: The Zephyr Abstract Syntax Description Lanuguage (ASDL) is a language designed to describe the tree-like data structures in compilers. Its main goal is to provide a method for compiler components written in different languages to interoperate. ASDL makes it easier for applications written in a variety of programming languages to communicate complex recursive data structures. To given an example, here's a short snippet from an ASDL definition of a simple programming language: program = Program(class* classes) class = Class(identifier name, identifier? parent, feature* features) [...] expression = Assign(identifier name, expression expr) | StaticDispatch(expression expr, identifier type_name, identifier name, expression* actual) | Dispatch(expression expr, identifier name, expression* actual) [...]","title":"Introduction"},{"location":"Language/Language-and-computation/Language-for-structure/Zephyr-ASDL/thegreenplace-Using-ASDL-to-describe-ASTs-in-compilers/#thegreenplace#using#asdl#to#describe#asts#in#compilers","text":"ASTs (Abstract Syntax Trees) are an important data structure in compiler front-ends. If you've written a few parsers, you almost definitely ran into the need to describe the result of the parsing in terms of an AST. While the kinds of nodes such ASTs have and their structure is very specific to the source language, many commonalities come up. In other words, coding \"yet another AST\" gets really old after you've done it a few times. Worry not, as you'd expect from the programmer crowd, this problem was \"solved\" by adding another level of abstraction. Yes, an abstraction over Abstract Syntax Trees, oh my! The abstraction here is some textual format (let's call it a DSL to sound smart) that describes what the AST looks like, along with machinery to auto-generate the code that implements this AST. Most solutions in this domain are ad-hoc, but one that I've seen used more than once is ASDL - Abstract Syntax Definition Language. The self-description from the website sounds about right: The Zephyr Abstract Syntax Description Lanuguage (ASDL) is a language designed to describe the tree-like data structures in compilers. Its main goal is to provide a method for compiler components written in different languages to interoperate. ASDL makes it easier for applications written in a variety of programming languages to communicate complex recursive data structures. To given an example, here's a short snippet from an ASDL definition of a simple programming language: program = Program(class* classes) class = Class(identifier name, identifier? parent, feature* features) [...] expression = Assign(identifier name, expression expr) | StaticDispatch(expression expr, identifier type_name, identifier name, expression* actual) | Dispatch(expression expr, identifier name, expression* actual) [...]","title":"thegreenplace Using ASDL to describe ASTs in compilers"},{"location":"Language/Language-and-computation/Structure-of-language/Language-and-grammar/","text":"Language and grammar \u672c\u6587\u91cd\u8981\u662f\u57fa\u4e8e\u7ef4\u57fa\u767e\u79d1 Language \u548c\u7ef4\u57fa\u767e\u79d1 Grammar \u603b\u7ed3\u800c\u6765\u3002 \u5173\u4e8e\u201dwhat is language\uff1f\u201c\uff0c\u8fd9\u4e2a\u95ee\u9898\uff0c\u6211\u5f88\u96be\u7ed9\u51fa\u56de\u7b54\uff0c\u53c2\u8003\uff1a \u7ef4\u57fa\u767e\u79d1 Language Language \uff08\u6211\u7684\u4e00\u7bc7\u6587\u7ae0\uff09 \u672c\u7ae0\u65e2\u7136\u662f\u5173\u4e8e\u8bed\u8a00\u7684\uff0c\u5b83\u5c5e\u4e8e linguistics \uff08\u8bed\u8a00\u5b66\uff09\uff0c\u90a3\u770b\u770b\u5f53\u4eca\u8bed\u8a00\u5b66\u7684\u7814\u7a76\u5427\uff0c\u4e0b\u9762\u662f\u6458\u81ea\u7ef4\u57fa\u767e\u79d1 Language \u7684 Modern linguistics \u7ae0\u8282\uff1a In the 1960s, Noam Chomsky formulated the generative theory of language . According to this theory, the most basic form of language is a set of syntactic rules that is universal for all humans and which underlies the grammars of all human languages. This set of rules is called Universal Grammar ; for Chomsky, describing it is the primary objective of the discipline of linguistics. Thus, he considered that the grammars of individual languages are only of importance to linguistics insofar as they allow us to deduce the universal underlying rules from which the observable linguistic variability is generated. In opposition to the formal theories of the generative school, functional theories of language propose that since language is fundamentally a tool, its structures are best analyzed and understood by reference to their functions. Formal theories of grammar seek to define the different elements of language and describe the way they relate to each other as systems of formal rules or operations, while functional theories seek to define the functions performed by language and then relate them to the linguistic elements that carry them out. The framework of cognitive linguistics interprets language in terms of the concepts (which are sometimes universal, and sometimes specific to a particular language) which underlie its forms. Cognitive linguistics is primarily concerned with how the mind creates meaning through language \u6211\u4eec\u76ee\u524d\u7684\u5173\u4e8elanguage\u7684\u4e00\u4e9b\u95ee\u9898\uff0c\u57fa\u672c\u4e0a\u90fd\u662f\u91c7\u7528\u7684 Noam Chomsky \u7684 generative theory of language \u5b66\u8bf4\uff0c\u4e5f\u5c31\u662f\u5728\u4e0b\u4e00\u6bb5\u4e2d\u4f1a\u8ba8\u8bba\u7684 Generative grammar \u3002 Grammar \u5728 \u8bed\u8a00\u5b66 \u4e2d\uff0c\u4f7f\u7528 grammar \u6765\u63cf\u8ff0\u8bed\u8a00\u7684\u7ed3\u6784\u3002\u53ea\u6709\u77e5\u9053\u4e86language\u7684structure\uff0c\u624d\u80fd\u591f\u5bf9\u5176\u8fdb\u884c\u8ba1\u7b97\u3002 \u8bed\u8a00\u5b66\u5bb6\u5f88\u65e9\u5c31\u53d1\u73b0\u4e86\u8bed\u8a00\u4e5f\u662f\u6709\u7ed3\u6784\u7684\uff0c\u4ed6\u4eec\u4f7f\u7528 Grammar \u6765\u63cf\u8ff0\u8bed\u8a00\u7684\u7ed3\u6784\u3002 \u5728\u7ef4\u57fa\u767e\u79d1 Grammar \u4e2d\u603b\u7ed3\u4e86\u5173\u4e8egrammar\u7684 Theoretical frameworks \uff0c\u5982\u679c\u4f7f\u7528\u6211\u4eec\u7684\u4e2d\u56fd\u8bdd\u6765\u7406\u89e3\u7684\u662f\uff0c\u5b83\u4eec\u662f\u4e0d\u540c\u7684\u5b66\u8bf4\u6216\u6d41\u6d3e\uff0c\u672c\u6587\u91cd\u70b9\u5173\u6ce8\u90a3\u4e9b\u57fa\u4e8e\"innate \" universal grammar \" \" \u601d\u60f3\u7684\u6d41\u6d3e\uff0c\u8fd9\u4e2a\u601d\u60f3\u662f\u7531 Noam Chomsky \u63d0\u51fa\uff0c\u8be5\u601d\u60f3\u7684\u6838\u5fc3\uff1a The basic postulate of UG is that a certain set of structural rules are innate to humans. Generative grammar \u5c31\u662f\u57fa\u4e8e\u8be5\u601d\u60f3\u7684\u4e00\u4e2a\u6d41\u6d3e\uff0c\u4e0b\u9762\u5bf9\u5176\u8fdb\u884c\u5206\u6790\u3002 Generative grammar \u8fd9\u4e2a\u6d41\u6d3e\u662f\u7531 Noam Chomsky \u6240\u521b\u5efa\uff0c\u5b83\u7684\u6838\u5fc3\u601d\u60f3\u662f\uff1a generative grammar considers grammar as a system of rules that generates exactly those combinations of words that form grammatical sentences in a given language. \u8fd9\u6bb5\u8bdd\u7684\u610f\u601d\u662f\uff1a\u4e00\u53e5\u8bdd\u662f\u6839\u636e\u8bed\u6cd5\u89c4\u5219\u63a8\u5bfc\u800c\u751f\u6210\u7684\u3002\u201cgenerate\u201d\u7684\u4e2d\u6587\u610f\u601d\u662f\u201c\u751f\u6210\u201d\uff0c\u201c\u4ea7\u751f\u201d\uff08\u610f\u601d\u975e\u5e38\u7c7b\u4f3c\u4e8e\u540e\u9762\u4f1a\u63a5\u89e6\u5230\u7684 production \uff08\u4ea7\u751f\u5f0f\uff09\uff09\uff0c\u201crule\u201d\u662f\u6307\u8bed\u6cd5\u89c4\u5219\u3002 \u8bf7\u601d\u8003\u8fd9\u4e9b\u95ee\u9898\uff1a \u5982\u4f55\u6765\u8868\u793a\u8fd9\u4e9b\u89c4\u5219 \u5982\u4f55\u6765\u8fdb\u884c\u63a8\u5bfc \u8fd9\u4e9b\u95ee\u9898\u5728 compiler-principle \u4e2d\u7ed9\u51fa\u4e86\u7b54\u6848\uff0c\u672c\u7ae0\u4f1a\u5bf9\u8fd9\u4e9b\u95ee\u9898\u8fdb\u884c\u8fdb\u4e00\u6b65\u5730\u5206\u6790\u3002 \u672c\u7ae0\u5c06\u8981\u4ecb\u7ecd\u7684formal grammar\u5c31\u662f\u5c5e\u4e8e\u8fd9\u4e2a\u6d41\u6d3e\u3002 \u76ee\u524d\u6211\u5728 NLP \u548c automata-and-formal-language \u4e2d\u63a5\u89e6\u4e86generative grammar\uff0c\u8fd9\u9879\u76ee\uff0c\u524d\u8005\u662f\u5173\u4e8enatural language\uff0c\u540e\u8005\u662f\u5173\u4e8eformal language\u3002","title":"Grammar"},{"location":"Language/Language-and-computation/Structure-of-language/Language-and-grammar/#language#and#grammar","text":"\u672c\u6587\u91cd\u8981\u662f\u57fa\u4e8e\u7ef4\u57fa\u767e\u79d1 Language \u548c\u7ef4\u57fa\u767e\u79d1 Grammar \u603b\u7ed3\u800c\u6765\u3002 \u5173\u4e8e\u201dwhat is language\uff1f\u201c\uff0c\u8fd9\u4e2a\u95ee\u9898\uff0c\u6211\u5f88\u96be\u7ed9\u51fa\u56de\u7b54\uff0c\u53c2\u8003\uff1a \u7ef4\u57fa\u767e\u79d1 Language Language \uff08\u6211\u7684\u4e00\u7bc7\u6587\u7ae0\uff09 \u672c\u7ae0\u65e2\u7136\u662f\u5173\u4e8e\u8bed\u8a00\u7684\uff0c\u5b83\u5c5e\u4e8e linguistics \uff08\u8bed\u8a00\u5b66\uff09\uff0c\u90a3\u770b\u770b\u5f53\u4eca\u8bed\u8a00\u5b66\u7684\u7814\u7a76\u5427\uff0c\u4e0b\u9762\u662f\u6458\u81ea\u7ef4\u57fa\u767e\u79d1 Language \u7684 Modern linguistics \u7ae0\u8282\uff1a In the 1960s, Noam Chomsky formulated the generative theory of language . According to this theory, the most basic form of language is a set of syntactic rules that is universal for all humans and which underlies the grammars of all human languages. This set of rules is called Universal Grammar ; for Chomsky, describing it is the primary objective of the discipline of linguistics. Thus, he considered that the grammars of individual languages are only of importance to linguistics insofar as they allow us to deduce the universal underlying rules from which the observable linguistic variability is generated. In opposition to the formal theories of the generative school, functional theories of language propose that since language is fundamentally a tool, its structures are best analyzed and understood by reference to their functions. Formal theories of grammar seek to define the different elements of language and describe the way they relate to each other as systems of formal rules or operations, while functional theories seek to define the functions performed by language and then relate them to the linguistic elements that carry them out. The framework of cognitive linguistics interprets language in terms of the concepts (which are sometimes universal, and sometimes specific to a particular language) which underlie its forms. Cognitive linguistics is primarily concerned with how the mind creates meaning through language \u6211\u4eec\u76ee\u524d\u7684\u5173\u4e8elanguage\u7684\u4e00\u4e9b\u95ee\u9898\uff0c\u57fa\u672c\u4e0a\u90fd\u662f\u91c7\u7528\u7684 Noam Chomsky \u7684 generative theory of language \u5b66\u8bf4\uff0c\u4e5f\u5c31\u662f\u5728\u4e0b\u4e00\u6bb5\u4e2d\u4f1a\u8ba8\u8bba\u7684 Generative grammar \u3002","title":"Language and grammar"},{"location":"Language/Language-and-computation/Structure-of-language/Language-and-grammar/#grammar","text":"\u5728 \u8bed\u8a00\u5b66 \u4e2d\uff0c\u4f7f\u7528 grammar \u6765\u63cf\u8ff0\u8bed\u8a00\u7684\u7ed3\u6784\u3002\u53ea\u6709\u77e5\u9053\u4e86language\u7684structure\uff0c\u624d\u80fd\u591f\u5bf9\u5176\u8fdb\u884c\u8ba1\u7b97\u3002 \u8bed\u8a00\u5b66\u5bb6\u5f88\u65e9\u5c31\u53d1\u73b0\u4e86\u8bed\u8a00\u4e5f\u662f\u6709\u7ed3\u6784\u7684\uff0c\u4ed6\u4eec\u4f7f\u7528 Grammar \u6765\u63cf\u8ff0\u8bed\u8a00\u7684\u7ed3\u6784\u3002 \u5728\u7ef4\u57fa\u767e\u79d1 Grammar \u4e2d\u603b\u7ed3\u4e86\u5173\u4e8egrammar\u7684 Theoretical frameworks \uff0c\u5982\u679c\u4f7f\u7528\u6211\u4eec\u7684\u4e2d\u56fd\u8bdd\u6765\u7406\u89e3\u7684\u662f\uff0c\u5b83\u4eec\u662f\u4e0d\u540c\u7684\u5b66\u8bf4\u6216\u6d41\u6d3e\uff0c\u672c\u6587\u91cd\u70b9\u5173\u6ce8\u90a3\u4e9b\u57fa\u4e8e\"innate \" universal grammar \" \" \u601d\u60f3\u7684\u6d41\u6d3e\uff0c\u8fd9\u4e2a\u601d\u60f3\u662f\u7531 Noam Chomsky \u63d0\u51fa\uff0c\u8be5\u601d\u60f3\u7684\u6838\u5fc3\uff1a The basic postulate of UG is that a certain set of structural rules are innate to humans. Generative grammar \u5c31\u662f\u57fa\u4e8e\u8be5\u601d\u60f3\u7684\u4e00\u4e2a\u6d41\u6d3e\uff0c\u4e0b\u9762\u5bf9\u5176\u8fdb\u884c\u5206\u6790\u3002","title":"Grammar"},{"location":"Language/Language-and-computation/Structure-of-language/Language-and-grammar/#generative#grammar","text":"\u8fd9\u4e2a\u6d41\u6d3e\u662f\u7531 Noam Chomsky \u6240\u521b\u5efa\uff0c\u5b83\u7684\u6838\u5fc3\u601d\u60f3\u662f\uff1a generative grammar considers grammar as a system of rules that generates exactly those combinations of words that form grammatical sentences in a given language. \u8fd9\u6bb5\u8bdd\u7684\u610f\u601d\u662f\uff1a\u4e00\u53e5\u8bdd\u662f\u6839\u636e\u8bed\u6cd5\u89c4\u5219\u63a8\u5bfc\u800c\u751f\u6210\u7684\u3002\u201cgenerate\u201d\u7684\u4e2d\u6587\u610f\u601d\u662f\u201c\u751f\u6210\u201d\uff0c\u201c\u4ea7\u751f\u201d\uff08\u610f\u601d\u975e\u5e38\u7c7b\u4f3c\u4e8e\u540e\u9762\u4f1a\u63a5\u89e6\u5230\u7684 production \uff08\u4ea7\u751f\u5f0f\uff09\uff09\uff0c\u201crule\u201d\u662f\u6307\u8bed\u6cd5\u89c4\u5219\u3002 \u8bf7\u601d\u8003\u8fd9\u4e9b\u95ee\u9898\uff1a \u5982\u4f55\u6765\u8868\u793a\u8fd9\u4e9b\u89c4\u5219 \u5982\u4f55\u6765\u8fdb\u884c\u63a8\u5bfc \u8fd9\u4e9b\u95ee\u9898\u5728 compiler-principle \u4e2d\u7ed9\u51fa\u4e86\u7b54\u6848\uff0c\u672c\u7ae0\u4f1a\u5bf9\u8fd9\u4e9b\u95ee\u9898\u8fdb\u884c\u8fdb\u4e00\u6b65\u5730\u5206\u6790\u3002 \u672c\u7ae0\u5c06\u8981\u4ecb\u7ecd\u7684formal grammar\u5c31\u662f\u5c5e\u4e8e\u8fd9\u4e2a\u6d41\u6d3e\u3002 \u76ee\u524d\u6211\u5728 NLP \u548c automata-and-formal-language \u4e2d\u63a5\u89e6\u4e86generative grammar\uff0c\u8fd9\u9879\u76ee\uff0c\u524d\u8005\u662f\u5173\u4e8enatural language\uff0c\u540e\u8005\u662f\u5173\u4e8eformal language\u3002","title":"Generative grammar"},{"location":"Mathematical-logic/","text":"Mathematical logic \u5feb\u901f\u5b66\u4e60\u8be5\u7406\u8bba\u7684\u4e00\u4e9b\u7b14\u8bb0\u3002\u9996\u5148\u5b66\u4e60\u4e00\u4e9b\u57fa\u7840\u6982\u5ff5\uff0c\u7136\u540e\u5728\u53bb\u5b66\u4e60\u590d\u6742\u4e00\u4e9b\u7684\u6982\u5ff5\u3002 Axiom and Rule of inference and Theorem Axiom \u53ef\u4ee5\u4f5c\u4e3a Rule of inference \u7684 premise \uff08\u524d\u7f6e\u6761\u4ef6\uff09\uff0c\u7ed3\u679c\u63a8\u5bfc\uff0c\u4ece\u800c\u5f97\u5230 Theorem Axiom \u516c\u7406\uff0c\u603b\u662f\u4e3aTrue An axiom or postulate is a statement that is taken to be true , to serve as a premise \uff08\u524d\u7f6e\u6761\u4ef6\uff09 or starting point for further reasoning and arguments. Rule of inference In logic , a rule of inference , inference rule or transformation rule is a logical form consisting of a function which takes premises, analyzes their syntax , and returns a conclusion (or conclusions ). For example, the rule of inference called modus ponens takes two premises, one in the form \"If p then q\" and another in the form \"p\", and returns the conclusion \"q\". The rule is valid with respect to the semantics of classical logic (as well as the semantics of many other non-classical logics ), in the sense that if the premises are true (under an interpretation), then so is the conclusion. \u63a8\u5bfc\u89c4\u5219\u3002\u201cpremise\"\u7684\u4e2d\u6587\u610f\u601d\u662f\u201d\u524d\u63d0\u201c\u3002\u5bf9\u5b83\u7684\u7b80\u5355\u7406\u89e3\uff1a\u5982\u679c\u524d\u63d0\u6761\u4ef6\u90fd\u6ee1\u8db3\uff0c\u5219\u53ef\u4ee5\u5f97\u51fa\u7ed3\u8bba\u3002 \u5728\u539f\u6587\u7684 The standard form of rules of inference \u6bb5\u7ed9\u51fa\u7684\u5f62\u5f0f\u662f\u975e\u5e38\u4efb\u610f\u7406\u89e3\u7684\u3002 Theorem In mathematics , a theorem is a non-self-evident statement that has been proven to be true, either on the basis of generally accepted statements such as axioms or on the basis previously established statements such as other theorems. A theorem is hence a logical consequence of the axioms, with a proof of the theorem being a logical argument which establishes its truth through the inference rules of a deductive system . \u5b9a\u7406\u3002 \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u7684**inference rules**\u5c31\u662f Rule of inference \u3002 Well-formed formula \u201cformula\u201d\u7684\u4e2d\u6587\u610f\u601d\u662f\u201c\u516c\u5f0f\u201d\uff0c\u201cwell-formed\u201d\u5373\u826f\u6784\u7684\uff0c\u4e5f\u5c31\u662f\u7b26\u5408grammar\u7684\u610f\u601d\uff08\u5982\u679c\u6709\u4e00\u5b9a\u7684formal language\u7684\u57fa\u7840\uff0c\u7406\u89e3well-formed\u662f\u6bd4\u8f83\u5bb9\u6613\u7684\uff09\u3002 \u5173\u4e8eformula\u7684\u4f8b\u5b50\u662f\u5f88\u591a\u7684\uff1a Newton-Leibniz formula grammar rule\u5c31\u662fformula\u3002 \u6bd4\u5982\u5728\u539f\u6587\u7684 Propositional calculus \u3002 Proof theory Proof theory is a major branch of mathematical logic that represents proofs as formal mathematical objects , facilitating their analysis by mathematical techniques. Proofs are typically presented as inductively-defined data structures such as plain lists, boxed lists, or trees , which are constructed according to the axioms and rules of inference of the logical system. As such, proof theory is syntactic in nature, in contrast to model theory , which is semantic in nature. \u8bc1\u660e\u7406\u8bba\uff0c\u63cf\u8ff0\u5982\u4f55\u6765\u8fdb\u884c\u8bc1\u660e\uff0c\u6309\u7167\u4e0a\u8ff0\u63cf\u8ff0\uff0c\u5c31\u662f\u4e0d\u65ad\u5730\u4f7f\u7528 axioms and rules of inference \u8fdb\u884c\u63a8\u5bfc\u7684\u8fc7\u7a0b \uff0c\u8fd9\u4e2a\u8fc7\u7a0b\u63a8\u5bfc\u8fc7\u7a0b\u662f\u53ef\u4ee5\u5c55\u793a\u4e3a\u4e00\u79cd\u6570\u636e\u7ed3\u6784\uff0c\u6bd4\u5982\u5217\u8868\u3001\u6811\u3002 Parse tree \u5c31\u662f\u4e00\u4e2a\u5178\u578b\u7684\u4f8b\u5b50\uff0c\u5728\u81ea\u9876\u5411\u4e0b parsing \u7684\u8fc7\u7a0b\u4e2d\uff0cparser\u4e0d\u65ad\u5730\u4f7f\u7528production\u8fdb\u884c\u63a8\u5bfc\uff08expand\uff09\uff0c\u6700\u7ec8\u751f\u6210\u4e86\u4e00\u68f5parse tree\u3002 \u6ce8\u610f\uff0c\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u7684\u201cinductively-defined\u201d\u6240\u6307\u4e3a recursive definition \uff0c\u5373\u9012\u5f52\u5b9a\u4e49\u3002 Formal proof \u6709\u4e86\u524d\u9762\u7684\u8fd9\u4e9b\u94fa\u57ab\uff0c\u73b0\u5728\u7406\u89e3 Formal proof \u5c31\u4e0d\u96be\u4e86\u3002 In logic and mathematics , a formal proof or derivation is a finite sequence of sentences (called well-formed formulas in the case of a formal language ), each of which is an axiom , an assumption, or follows from the preceding sentences in the sequence by a rule of inference . \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u7684\u201ceach of which\u201d\u662f\u4fee\u9970 \u201csentences\u201d \u7684\u5b9a\u8bed\u4ece\u53e5\u3002 It differs from a natural language argument in that it is rigorous, unambiguous and mechanically checkable. \u8fd9\u6bb5\u8bdd\u6240\u63cf\u8ff0\u7684\u662fformal\u7684\u4f18\u52bf\u6240\u5728\u3002 The theorem is a syntactic consequence of all the well-formed formulas preceding it in the proof. \u8bc1\u660e\u7684\u76ee\u7684\u662f\u5f97\u5230theorem\uff1f Checking formal proofs is usually simple, while the problem of finding proofs ( automated theorem proving ) is usually computationally intractable and/or only semi-decidable , depending upon the formal system in use. \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u7684\u201cfinding proof\u201d\u6240\u6307\u7684\u5e94\u8be5\u662f\u7ed9\u5b9atheorem \uff0c\u53d6\u5bfb\u627e\u5f97\u5230\u8fd9\u4e2atheorem\u7684proof\uff0c\u8fd9\u975e\u5e38\u7c7b\u4f3c\u4e8e parsing \u3002 \u601d\u8003\uff1aproof VS inference \u8bc1\u660e\u548c\u63a8\u7406\u7684\u5dee\u5f02\uff1f\u8bc1\u660e\u7684\u8fc7\u7a0b\u662f\u4e0d\u65ad\u5730\u8fdb\u884cinfer\uff0c\u5373\u4e0d\u65ad\u5730\u4f7f\u7528 Rule of inference \u3002 Formal system A formal system is used for inferring theorems from axioms according to a set of rules. These rules, which are used for carrying out the inference of theorems from axioms, are the logical calculus of the formal system. A formal system is essentially an \" axiomatic system \". In 1921, David Hilbert proposed to use such system as the foundation for the knowledge in mathematics . A formal system may represent a well-defined system of abstract thought . The term formalism is sometimes a rough synonym for formal system , but is also refers to a given style of notation , for example, Paul Dirac 's bra\u2013ket notation . \u6709\u4e86\u524d\u9762\u7684\u7406\u8bba\u57fa\u7840\uff0c \u73b0\u5728\u6765\u770bformal system\u5e94\u8be5\u4e0d\u96be\u7406\u89e3\u5b83\u4e86\u3002\u5982\u679c\u5c06\u4e00\u4e2aformal system\u770b\u505a\u662f\u4e00\u4e2a\u673a\u5668\u7684\u8bdd\uff0c\u5b83\u9700\u8981\u6709\u5982\u4e0b\u914d\u7f6e\uff1a Deductive inference\uff08deductive apparatus\uff09 \u90a3\u8fd9\u4e2a\u673a\u5668\u53ef\u4ee5\u7528\u6765\u505a\u4ec0\u4e48\u5462\uff1f proof \u4f7f\u7528formal system\u6765\u63cf\u8ff0formal grammar \u901a\u8fc7\u4e0a\u9762\u7684\u63cf\u8ff0\uff0c\u53ef\u4ee5\u5f97\u77e5\uff1a\u4e00\u4e2a\u8bed\u8a00\u7684formal grammar\u5176\u5b9e\u53ef\u4ee5\u770b\u505a\u662f\u4e00\u4e2aformal system\uff0cformal grammar generate sentence\u7684\u8fc7\u7a0b\u5176\u5b9e\u5c31\u662fformal system\u8fdb\u884cformal proof\u7684\u8fc7\u7a0b\uff1bparsing\u7684\u8fc7\u7a0b\u5176\u5b9e\u662ffind proof\u7684\u8fc7\u7a0b\u3002\u66f4\u591a\u5173\u4e8e\u6b64\u7684\u5185\u5bb9\uff0c\u5728Formal-language\u7ae0\u8282\u4e2d\u4f1a\u8fdb\u884c\u63cf\u8ff0\u3002 \u63d0\u53caformal system\u7684\u6587\u7ae0 Formal proof \u7684 Formal systems A formal system is used to derive one expression from one or more other expressions. List of formal systems Lambda calculus Mathematical logic and formal language \u7ef4\u57fa\u767e\u79d1\u5c06 formal language \u4e5f\u5f52\u5165\u5230\u4e86 Mathematical logic \u9886\u57df\u4e2d\u3002\u4f7f\u7528 Mathematical logic \u7684\u601d\u60f3\u6765\u770b\u5f85formal language\u4e2d\u7684\u4e00\u4e9b\u5217\u95ee\u9898\u662f\u66f4\u52a0\u5bb9\u6613\u7406\u89e3\u7684\u3002","title":"Introduction"},{"location":"Mathematical-logic/#mathematical#logic","text":"\u5feb\u901f\u5b66\u4e60\u8be5\u7406\u8bba\u7684\u4e00\u4e9b\u7b14\u8bb0\u3002\u9996\u5148\u5b66\u4e60\u4e00\u4e9b\u57fa\u7840\u6982\u5ff5\uff0c\u7136\u540e\u5728\u53bb\u5b66\u4e60\u590d\u6742\u4e00\u4e9b\u7684\u6982\u5ff5\u3002","title":"Mathematical logic"},{"location":"Mathematical-logic/#axiom#and#rule#of#inference#and#theorem","text":"Axiom \u53ef\u4ee5\u4f5c\u4e3a Rule of inference \u7684 premise \uff08\u524d\u7f6e\u6761\u4ef6\uff09\uff0c\u7ed3\u679c\u63a8\u5bfc\uff0c\u4ece\u800c\u5f97\u5230 Theorem","title":"Axiom and Rule of inference and Theorem"},{"location":"Mathematical-logic/#axiom","text":"\u516c\u7406\uff0c\u603b\u662f\u4e3aTrue An axiom or postulate is a statement that is taken to be true , to serve as a premise \uff08\u524d\u7f6e\u6761\u4ef6\uff09 or starting point for further reasoning and arguments.","title":"Axiom"},{"location":"Mathematical-logic/#rule#of#inference","text":"In logic , a rule of inference , inference rule or transformation rule is a logical form consisting of a function which takes premises, analyzes their syntax , and returns a conclusion (or conclusions ). For example, the rule of inference called modus ponens takes two premises, one in the form \"If p then q\" and another in the form \"p\", and returns the conclusion \"q\". The rule is valid with respect to the semantics of classical logic (as well as the semantics of many other non-classical logics ), in the sense that if the premises are true (under an interpretation), then so is the conclusion. \u63a8\u5bfc\u89c4\u5219\u3002\u201cpremise\"\u7684\u4e2d\u6587\u610f\u601d\u662f\u201d\u524d\u63d0\u201c\u3002\u5bf9\u5b83\u7684\u7b80\u5355\u7406\u89e3\uff1a\u5982\u679c\u524d\u63d0\u6761\u4ef6\u90fd\u6ee1\u8db3\uff0c\u5219\u53ef\u4ee5\u5f97\u51fa\u7ed3\u8bba\u3002 \u5728\u539f\u6587\u7684 The standard form of rules of inference \u6bb5\u7ed9\u51fa\u7684\u5f62\u5f0f\u662f\u975e\u5e38\u4efb\u610f\u7406\u89e3\u7684\u3002","title":"Rule of inference"},{"location":"Mathematical-logic/#theorem","text":"In mathematics , a theorem is a non-self-evident statement that has been proven to be true, either on the basis of generally accepted statements such as axioms or on the basis previously established statements such as other theorems. A theorem is hence a logical consequence of the axioms, with a proof of the theorem being a logical argument which establishes its truth through the inference rules of a deductive system . \u5b9a\u7406\u3002 \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u7684**inference rules**\u5c31\u662f Rule of inference \u3002","title":"Theorem"},{"location":"Mathematical-logic/#well-formed#formula","text":"\u201cformula\u201d\u7684\u4e2d\u6587\u610f\u601d\u662f\u201c\u516c\u5f0f\u201d\uff0c\u201cwell-formed\u201d\u5373\u826f\u6784\u7684\uff0c\u4e5f\u5c31\u662f\u7b26\u5408grammar\u7684\u610f\u601d\uff08\u5982\u679c\u6709\u4e00\u5b9a\u7684formal language\u7684\u57fa\u7840\uff0c\u7406\u89e3well-formed\u662f\u6bd4\u8f83\u5bb9\u6613\u7684\uff09\u3002 \u5173\u4e8eformula\u7684\u4f8b\u5b50\u662f\u5f88\u591a\u7684\uff1a Newton-Leibniz formula grammar rule\u5c31\u662fformula\u3002 \u6bd4\u5982\u5728\u539f\u6587\u7684 Propositional calculus \u3002","title":"Well-formed formula"},{"location":"Mathematical-logic/#proof#theory","text":"Proof theory is a major branch of mathematical logic that represents proofs as formal mathematical objects , facilitating their analysis by mathematical techniques. Proofs are typically presented as inductively-defined data structures such as plain lists, boxed lists, or trees , which are constructed according to the axioms and rules of inference of the logical system. As such, proof theory is syntactic in nature, in contrast to model theory , which is semantic in nature. \u8bc1\u660e\u7406\u8bba\uff0c\u63cf\u8ff0\u5982\u4f55\u6765\u8fdb\u884c\u8bc1\u660e\uff0c\u6309\u7167\u4e0a\u8ff0\u63cf\u8ff0\uff0c\u5c31\u662f\u4e0d\u65ad\u5730\u4f7f\u7528 axioms and rules of inference \u8fdb\u884c\u63a8\u5bfc\u7684\u8fc7\u7a0b \uff0c\u8fd9\u4e2a\u8fc7\u7a0b\u63a8\u5bfc\u8fc7\u7a0b\u662f\u53ef\u4ee5\u5c55\u793a\u4e3a\u4e00\u79cd\u6570\u636e\u7ed3\u6784\uff0c\u6bd4\u5982\u5217\u8868\u3001\u6811\u3002 Parse tree \u5c31\u662f\u4e00\u4e2a\u5178\u578b\u7684\u4f8b\u5b50\uff0c\u5728\u81ea\u9876\u5411\u4e0b parsing \u7684\u8fc7\u7a0b\u4e2d\uff0cparser\u4e0d\u65ad\u5730\u4f7f\u7528production\u8fdb\u884c\u63a8\u5bfc\uff08expand\uff09\uff0c\u6700\u7ec8\u751f\u6210\u4e86\u4e00\u68f5parse tree\u3002 \u6ce8\u610f\uff0c\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u7684\u201cinductively-defined\u201d\u6240\u6307\u4e3a recursive definition \uff0c\u5373\u9012\u5f52\u5b9a\u4e49\u3002","title":"Proof theory"},{"location":"Mathematical-logic/#formal#proof","text":"\u6709\u4e86\u524d\u9762\u7684\u8fd9\u4e9b\u94fa\u57ab\uff0c\u73b0\u5728\u7406\u89e3 Formal proof \u5c31\u4e0d\u96be\u4e86\u3002 In logic and mathematics , a formal proof or derivation is a finite sequence of sentences (called well-formed formulas in the case of a formal language ), each of which is an axiom , an assumption, or follows from the preceding sentences in the sequence by a rule of inference . \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u7684\u201ceach of which\u201d\u662f\u4fee\u9970 \u201csentences\u201d \u7684\u5b9a\u8bed\u4ece\u53e5\u3002 It differs from a natural language argument in that it is rigorous, unambiguous and mechanically checkable. \u8fd9\u6bb5\u8bdd\u6240\u63cf\u8ff0\u7684\u662fformal\u7684\u4f18\u52bf\u6240\u5728\u3002 The theorem is a syntactic consequence of all the well-formed formulas preceding it in the proof. \u8bc1\u660e\u7684\u76ee\u7684\u662f\u5f97\u5230theorem\uff1f Checking formal proofs is usually simple, while the problem of finding proofs ( automated theorem proving ) is usually computationally intractable and/or only semi-decidable , depending upon the formal system in use. \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u7684\u201cfinding proof\u201d\u6240\u6307\u7684\u5e94\u8be5\u662f\u7ed9\u5b9atheorem \uff0c\u53d6\u5bfb\u627e\u5f97\u5230\u8fd9\u4e2atheorem\u7684proof\uff0c\u8fd9\u975e\u5e38\u7c7b\u4f3c\u4e8e parsing \u3002","title":"Formal proof"},{"location":"Mathematical-logic/#proof#vs#inference","text":"\u8bc1\u660e\u548c\u63a8\u7406\u7684\u5dee\u5f02\uff1f\u8bc1\u660e\u7684\u8fc7\u7a0b\u662f\u4e0d\u65ad\u5730\u8fdb\u884cinfer\uff0c\u5373\u4e0d\u65ad\u5730\u4f7f\u7528 Rule of inference \u3002","title":"\u601d\u8003\uff1aproof VS inference"},{"location":"Mathematical-logic/#formal#system","text":"A formal system is used for inferring theorems from axioms according to a set of rules. These rules, which are used for carrying out the inference of theorems from axioms, are the logical calculus of the formal system. A formal system is essentially an \" axiomatic system \". In 1921, David Hilbert proposed to use such system as the foundation for the knowledge in mathematics . A formal system may represent a well-defined system of abstract thought . The term formalism is sometimes a rough synonym for formal system , but is also refers to a given style of notation , for example, Paul Dirac 's bra\u2013ket notation . \u6709\u4e86\u524d\u9762\u7684\u7406\u8bba\u57fa\u7840\uff0c \u73b0\u5728\u6765\u770bformal system\u5e94\u8be5\u4e0d\u96be\u7406\u89e3\u5b83\u4e86\u3002\u5982\u679c\u5c06\u4e00\u4e2aformal system\u770b\u505a\u662f\u4e00\u4e2a\u673a\u5668\u7684\u8bdd\uff0c\u5b83\u9700\u8981\u6709\u5982\u4e0b\u914d\u7f6e\uff1a Deductive inference\uff08deductive apparatus\uff09 \u90a3\u8fd9\u4e2a\u673a\u5668\u53ef\u4ee5\u7528\u6765\u505a\u4ec0\u4e48\u5462\uff1f proof","title":"Formal system"},{"location":"Mathematical-logic/#formal#systemformal#grammar","text":"\u901a\u8fc7\u4e0a\u9762\u7684\u63cf\u8ff0\uff0c\u53ef\u4ee5\u5f97\u77e5\uff1a\u4e00\u4e2a\u8bed\u8a00\u7684formal grammar\u5176\u5b9e\u53ef\u4ee5\u770b\u505a\u662f\u4e00\u4e2aformal system\uff0cformal grammar generate sentence\u7684\u8fc7\u7a0b\u5176\u5b9e\u5c31\u662fformal system\u8fdb\u884cformal proof\u7684\u8fc7\u7a0b\uff1bparsing\u7684\u8fc7\u7a0b\u5176\u5b9e\u662ffind proof\u7684\u8fc7\u7a0b\u3002\u66f4\u591a\u5173\u4e8e\u6b64\u7684\u5185\u5bb9\uff0c\u5728Formal-language\u7ae0\u8282\u4e2d\u4f1a\u8fdb\u884c\u63cf\u8ff0\u3002","title":"\u4f7f\u7528formal system\u6765\u63cf\u8ff0formal grammar"},{"location":"Mathematical-logic/#formal#system_1","text":"Formal proof \u7684 Formal systems A formal system is used to derive one expression from one or more other expressions.","title":"\u63d0\u53caformal system\u7684\u6587\u7ae0"},{"location":"Mathematical-logic/#list#of#formal#systems","text":"Lambda calculus","title":"List of formal systems"},{"location":"Mathematical-logic/#mathematical#logic#and#formal#language","text":"\u7ef4\u57fa\u767e\u79d1\u5c06 formal language \u4e5f\u5f52\u5165\u5230\u4e86 Mathematical logic \u9886\u57df\u4e2d\u3002\u4f7f\u7528 Mathematical logic \u7684\u601d\u60f3\u6765\u770b\u5f85formal language\u4e2d\u7684\u4e00\u4e9b\u5217\u95ee\u9898\u662f\u66f4\u52a0\u5bb9\u6613\u7406\u89e3\u7684\u3002","title":"Mathematical logic and formal language"},{"location":"Mathematical-logic/Axiom-schema/","text":"Axiom Schema \"axiom schema\"\u7684\u4e2d\u6587\u610f\u601d\u662f\"\u516c\u7406\u6a21\u5f0f\"\u3002\u6211\u662f\u5728\u9605\u8bfbwikipedia Chomsky hierarchy \u4e2d\u53d1\u73b0\u5b83\u7684: A formal grammar provides an axiom schema for (or generates ) a formal language , which is a (usually infinite) set of finite-length sequences of symbols that may be constructed by applying production rules to another sequence of symbols (which initially contains just the start symbol). A rule may be applied by replacing an occurrence of the symbols on its left-hand side with those that appear on its right-hand side. A sequence of rule applications is called a derivation . Such a grammar defines the formal language: all words consisting solely of terminal symbols which can be reached by a derivation from the start symbol. https://www.britannica.com/topic/formal-logic What is an axiom schema? wikipedia Axiom schema In mathematical logic , an axiom schema (plural: axiom schemata or axiom schemas ) generalizes the notion of axiom . NOTE: \u63a8\u5e7f\u4e86axiom\u7684\u6982\u5ff5\u3002\u4ee5 formal grammar \u4e3a\u4f8b\uff0cformal grammar\u4e2d\u7684production\u5c31\u662faxiom\u3002 mathworld.wolfram Axiom Schema sciencedirect Axiom Schema","title":"Axiom-schema"},{"location":"Mathematical-logic/Axiom-schema/#axiom#schema","text":"\"axiom schema\"\u7684\u4e2d\u6587\u610f\u601d\u662f\"\u516c\u7406\u6a21\u5f0f\"\u3002\u6211\u662f\u5728\u9605\u8bfbwikipedia Chomsky hierarchy \u4e2d\u53d1\u73b0\u5b83\u7684: A formal grammar provides an axiom schema for (or generates ) a formal language , which is a (usually infinite) set of finite-length sequences of symbols that may be constructed by applying production rules to another sequence of symbols (which initially contains just the start symbol). A rule may be applied by replacing an occurrence of the symbols on its left-hand side with those that appear on its right-hand side. A sequence of rule applications is called a derivation . Such a grammar defines the formal language: all words consisting solely of terminal symbols which can be reached by a derivation from the start symbol. https://www.britannica.com/topic/formal-logic What is an axiom schema?","title":"Axiom Schema"},{"location":"Mathematical-logic/Axiom-schema/#wikipedia#axiom#schema","text":"In mathematical logic , an axiom schema (plural: axiom schemata or axiom schemas ) generalizes the notion of axiom . NOTE: \u63a8\u5e7f\u4e86axiom\u7684\u6982\u5ff5\u3002\u4ee5 formal grammar \u4e3a\u4f8b\uff0cformal grammar\u4e2d\u7684production\u5c31\u662faxiom\u3002","title":"wikipedia Axiom schema"},{"location":"Mathematical-logic/Axiom-schema/#mathworldwolfram#axiom#schema","text":"","title":"mathworld.wolfram Axiom Schema"},{"location":"Mathematical-logic/Axiom-schema/#sciencedirect#axiom#schema","text":"","title":"sciencedirect Axiom Schema"},{"location":"Mathematical-logic/Propositional-calculus/","text":"Propositional calculus \"Propositional calculus\"\u7684\u4e2d\u6587\u610f\u601d\u662f\"\u547d\u9898\u6f14\u7b97\"\uff0c\u6211\u662f\u5728\u9605\u8bfbwikipedia Calculus \u53d1\u73b0\u5b83\u7684\u3002 wikipedia Propositional calculus","title":"Propositional-calculus"},{"location":"Mathematical-logic/Propositional-calculus/#propositional#calculus","text":"\"Propositional calculus\"\u7684\u4e2d\u6587\u610f\u601d\u662f\"\u547d\u9898\u6f14\u7b97\"\uff0c\u6211\u662f\u5728\u9605\u8bfbwikipedia Calculus \u53d1\u73b0\u5b83\u7684\u3002","title":"Propositional calculus"},{"location":"Mathematical-logic/Propositional-calculus/#wikipedia#propositional#calculus","text":"","title":"wikipedia Propositional calculus"},{"location":"Regular-language/","text":"Regular language wikipedia Regular language wikipedia Regular grammar Automation \u5b83\u7684automation \u662f Finite-state machine \u3002 TIPS: In Chinese, Finite-state machine means \u6709\u7a77\u81ea\u52a8\u673a","title":"Introduction"},{"location":"Regular-language/#regular#language","text":"","title":"Regular language"},{"location":"Regular-language/#wikipedia#regular#language","text":"","title":"wikipedia Regular language"},{"location":"Regular-language/#wikipedia#regular#grammar","text":"","title":"wikipedia Regular grammar"},{"location":"Regular-language/#automation","text":"\u5b83\u7684automation \u662f Finite-state machine \u3002 TIPS: In Chinese, Finite-state machine means \u6709\u7a77\u81ea\u52a8\u673a","title":"Automation"},{"location":"Regular-language/Regular-expression/","text":"Regular expression wikipedia Regular expression","title":"Introduction"},{"location":"Regular-language/Regular-expression/#regular#expression","text":"","title":"Regular expression"},{"location":"Regular-language/Regular-expression/#wikipedia#regular#expression","text":"","title":"wikipedia Regular expression"},{"location":"Regular-language/Regular-expression/Regex-Engine/","text":"Regex engine https://www.regular-expressions.info/engine.html https://se.ifmo.ru/~ad/Documentation/Mastering_RegExp/mastregex2-CHP-4.html https://devopedia.org/regex-engines https://www.codeguru.com/cpp/cpp/cpp_mfc/parsing/article.php/c4093/Write-Your-Own-Regular-Expression-Parser.htm","title":"Introduction"},{"location":"Regular-language/Regular-expression/Regex-Engine/#regex#engine","text":"https://www.regular-expressions.info/engine.html https://se.ifmo.ru/~ad/Documentation/Mastering_RegExp/mastregex2-CHP-4.html https://devopedia.org/regex-engines https://www.codeguru.com/cpp/cpp/cpp_mfc/parsing/article.php/c4093/Write-Your-Own-Regular-Expression-Parser.htm","title":"Regex engine"},{"location":"Regular-language/Regular-expression/Regex-Engine/Powerset-construction/","text":"Powerset construction wikipedia Powerset construction In the theory of computation and automata theory , the powerset construction or subset construction is a standard method for converting a nondeterministic finite automaton (NFA) into a deterministic finite automaton (DFA) which recognizes the same formal language . It is important in theory because it establishes that NFAs, despite their additional flexibility, are unable to recognize any language that cannot be recognized by some DFA. It is also important in practice for converting easier-to-construct NFAs into more efficiently executable DFAs. However, if the NFA has n states, the resulting DFA may have up to 2^n 2^n states, an exponentially larger number, which sometimes makes the construction impractical for large NFAs. The construction, sometimes called the Rabin\u2013Scott powerset construction (or subset construction) to distinguish it from similar constructions for other types of automata, was first published by Michael O. Rabin and Dana Scott in 1959.[ 1] Intuition To simulate the operation of a DFA on a given input string, one needs to keep track of a single state at any time: the state that the automaton will reach after seeing a prefix of the input. In contrast, to simulate an NFA, one needs to keep track of a set of states : all of the states that the automaton could reach after seeing the same prefix of the input, according to the nondeterministic choices made by the automaton. If, after a certain prefix of the input, a set S of states can be reached, then after the next input symbol x the set of reachable states is a deterministic function of S and x . Therefore, the sets of reachable NFA states play the same role in the NFA simulation as single DFA states play in the DFA simulation, and in fact the sets of NFA states appearing in this simulation may be re-interpreted as being states of a DFA.[ 2] NOTE: The difference between DFA and NFA can help to understand why a single state in DFA versus a set of states in NFA, below is come from Finite-state machine : In a deterministic automaton, every state has exactly one transition for each possible input. In a non-deterministic automaton, an input can lead to one, more than one, or no transition for a given state. The powerset construction algorithm can transform any nondeterministic automaton into a (usually more complex) deterministic automaton with identical functionality.","title":"Introduction"},{"location":"Regular-language/Regular-expression/Regex-Engine/Powerset-construction/#powerset#construction","text":"","title":"Powerset construction"},{"location":"Regular-language/Regular-expression/Regex-Engine/Powerset-construction/#wikipedia#powerset#construction","text":"In the theory of computation and automata theory , the powerset construction or subset construction is a standard method for converting a nondeterministic finite automaton (NFA) into a deterministic finite automaton (DFA) which recognizes the same formal language . It is important in theory because it establishes that NFAs, despite their additional flexibility, are unable to recognize any language that cannot be recognized by some DFA. It is also important in practice for converting easier-to-construct NFAs into more efficiently executable DFAs. However, if the NFA has n states, the resulting DFA may have up to 2^n 2^n states, an exponentially larger number, which sometimes makes the construction impractical for large NFAs. The construction, sometimes called the Rabin\u2013Scott powerset construction (or subset construction) to distinguish it from similar constructions for other types of automata, was first published by Michael O. Rabin and Dana Scott in 1959.[ 1]","title":"wikipedia Powerset construction"},{"location":"Regular-language/Regular-expression/Regex-Engine/Powerset-construction/#intuition","text":"To simulate the operation of a DFA on a given input string, one needs to keep track of a single state at any time: the state that the automaton will reach after seeing a prefix of the input. In contrast, to simulate an NFA, one needs to keep track of a set of states : all of the states that the automaton could reach after seeing the same prefix of the input, according to the nondeterministic choices made by the automaton. If, after a certain prefix of the input, a set S of states can be reached, then after the next input symbol x the set of reachable states is a deterministic function of S and x . Therefore, the sets of reachable NFA states play the same role in the NFA simulation as single DFA states play in the DFA simulation, and in fact the sets of NFA states appearing in this simulation may be re-interpreted as being states of a DFA.[ 2] NOTE: The difference between DFA and NFA can help to understand why a single state in DFA versus a set of states in NFA, below is come from Finite-state machine : In a deterministic automaton, every state has exactly one transition for each possible input. In a non-deterministic automaton, an input can lead to one, more than one, or no transition for a given state. The powerset construction algorithm can transform any nondeterministic automaton into a (usually more complex) deterministic automaton with identical functionality.","title":"Intuition"},{"location":"Regular-language/Regular-expression/Regex-Engine/Thompson%27s-construction/","text":"Thompson's construction Thompson's construction","title":"Introduction"},{"location":"Regular-language/Regular-expression/Regex-Engine/Thompson%27s-construction/#thompsons#construction","text":"","title":"Thompson's construction"},{"location":"Symbolic-computation/","text":"\u5173\u4e8e\u672c\u7ae0 \u672c\u7ae0\u8ba8\u8bbasymbolic computation \u4ee5\u53ca\u76f8\u5173\u7684\u5185\u5bb9\u3002 \u4e3a\u4ec0\u4e48\u6211\u8981\u6f14\u8fdbsymbolic computation\uff1f \u4e00\u3001\u5b9e\u9645\u5de5\u4f5c\u4e2d: 1\u3001\u81ea\u5b9a\u4e49\u57fa\u5dee 2\u3001\u81ea\u5b9a\u4e49\u98ce\u63a7\u516c\u5f0f \u4e8c\u3001deep learning \u5185\u5bb9\u6982\u8ff0 Symbol\u4f7f\u6211\u4eec\u80fd\u591f\u65b9\u4fbf\u7684\u521b\u9020\u3001\u5b9e\u73b0DSL\uff1b Symbolic programming\u5c06symbol\u66b4\u9732\u7ed9programmer\uff0c\u6216\u8005\u8bf4\u5141\u8bb8programmer\u6784\u5efasymbol expression\uff0c\u5e76\u4e14\u5bf9symbolic expression\u8fdb\u884c\u64cd\u4f5c\u3002\u8fd9\u6837programmer\u5c31\u80fd\u591f\u4f7f\u7528DSL\u8fdb\u884c\u63cf\u8ff0\uff0c\u8fd9\u5927\u5927\u589e\u52a0\u4e86\u7075\u6d3b\u6027\uff0c\u4e00\u79cd\u5178\u578b\u7684\u4f8b\u5b50\u5c31\u662fmath language\u3002\u4ece\u800c\u5b9e\u73b0\u4e86symbolic computation\u3002 \u7ae0\u8282\u8bf4\u660e \u672c\u6587\u9996\u5148\u4ecb\u7ecd symbolic computation\uff0c\u53c2\u89c1 Symbolic-computation \u7ae0\u8282\u3002symbolic computation\u7684\u6838\u5fc3\u662fsymbol expression\uff0c\u5b83\u5728 Symbol-expression \u7ae0\u8282\u8fdb\u884c\u4ecb\u7ecd\u3002 Symbolic programming\u662f\u4e00\u79cd\u7f16\u7a0b\u601d\u60f3\uff0c\u5b83\u5728 Symbolic-programming \u7ae0\u8282\u4e2d\u8fdb\u884c\u4e86\u63cf\u8ff0\u3002","title":"Introduction"},{"location":"Symbolic-computation/#_1","text":"\u672c\u7ae0\u8ba8\u8bbasymbolic computation \u4ee5\u53ca\u76f8\u5173\u7684\u5185\u5bb9\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Symbolic-computation/#symbolic#computation","text":"\u4e00\u3001\u5b9e\u9645\u5de5\u4f5c\u4e2d: 1\u3001\u81ea\u5b9a\u4e49\u57fa\u5dee 2\u3001\u81ea\u5b9a\u4e49\u98ce\u63a7\u516c\u5f0f \u4e8c\u3001deep learning","title":"\u4e3a\u4ec0\u4e48\u6211\u8981\u6f14\u8fdbsymbolic computation\uff1f"},{"location":"Symbolic-computation/#_2","text":"Symbol\u4f7f\u6211\u4eec\u80fd\u591f\u65b9\u4fbf\u7684\u521b\u9020\u3001\u5b9e\u73b0DSL\uff1b Symbolic programming\u5c06symbol\u66b4\u9732\u7ed9programmer\uff0c\u6216\u8005\u8bf4\u5141\u8bb8programmer\u6784\u5efasymbol expression\uff0c\u5e76\u4e14\u5bf9symbolic expression\u8fdb\u884c\u64cd\u4f5c\u3002\u8fd9\u6837programmer\u5c31\u80fd\u591f\u4f7f\u7528DSL\u8fdb\u884c\u63cf\u8ff0\uff0c\u8fd9\u5927\u5927\u589e\u52a0\u4e86\u7075\u6d3b\u6027\uff0c\u4e00\u79cd\u5178\u578b\u7684\u4f8b\u5b50\u5c31\u662fmath language\u3002\u4ece\u800c\u5b9e\u73b0\u4e86symbolic computation\u3002","title":"\u5185\u5bb9\u6982\u8ff0"},{"location":"Symbolic-computation/#_3","text":"\u672c\u6587\u9996\u5148\u4ecb\u7ecd symbolic computation\uff0c\u53c2\u89c1 Symbolic-computation \u7ae0\u8282\u3002symbolic computation\u7684\u6838\u5fc3\u662fsymbol expression\uff0c\u5b83\u5728 Symbol-expression \u7ae0\u8282\u8fdb\u884c\u4ecb\u7ecd\u3002 Symbolic programming\u662f\u4e00\u79cd\u7f16\u7a0b\u601d\u60f3\uff0c\u5b83\u5728 Symbolic-programming \u7ae0\u8282\u4e2d\u8fdb\u884c\u4e86\u63cf\u8ff0\u3002","title":"\u7ae0\u8282\u8bf4\u660e"},{"location":"Symbolic-computation/Computer-algebra/","text":"\u5173\u4e8e\u672c\u7ae0 \u672c\u7ae0\u8ba8\u8bba\u201dcomputer algebra\u201c\u5373\u201d\u8ba1\u7b97\u4ee3\u6570\u201c\u3002 \u5728\u5b66\u4e60back propagation\u7684\u65f6\u5019\uff0c\u67e5\u9605\u4e86 \u5982\u4f55\u76f4\u89c2\u5730\u89e3\u91ca backpropagation \u7b97\u6cd5\uff1f - YE Y\u7684\u56de\u7b54 - \u77e5\u4e4e \uff0c\u5176\u4e2d\u63d0\u53ca\u4e86\u201c\u8ba1\u7b97\u4ee3\u6570\u201d\uff0c\u67e5\u8be2\u4e86\u4e00\u4e0b\uff0c\u5728\u8ba1\u7b97\u673a\u79d1\u5b66\u4e2d\u662f\u6709\u8fd9\u79cd\u5b66\u79d1\u7684\uff1aComputer algebra\uff0c\u4e0b\u9762\u662fwikipedia Computer algebra \u3002 wikipedia Computer algebra In mathematics and computer science , computer algebra , also called symbolic computation or algebraic computation , is a scientific area that refers to the study and development of algorithms and software for manipulating mathematical expressions and other mathematical objects . NOTE: \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5728\u4e00\u4e9b\u573a\u5408\u5e38\u5e38\u4f7f\u7528symbolic computation NOTE: \u5173\u4e8esymbol\uff0c\u53c2\u89c1 Relation-structure-computation\\Symbol \u7ae0\u8282 Computer algebra VS scientific computing Although computer algebra could be considered a subfield of scientific computing , they are generally considered as distinct fields because scientific computing is usually based on numerical computation with approximate floating point numbers , while symbolic computation emphasizes exact computation with expressions containing variables that have no given value and are manipulated as symbols . Computer algebra systems Software applications that perform symbolic calculations are called computer algebra systems . NOTE: TensorFlow\u5176\u5b9e\u53ef\u4ee5\u770b\u505a\u662f\u4e00\u4e2acomputer algebra system Computer science aspects NOTE: \u8fd9\u662f\u4f5c\u4e3asoftware engineer\u7684\u4eba\u9700\u8981\u5173\u6ce8\u7684 Data representation It is common, in computer algebra, to emphasize exact computation with exactly represented data. Such an exact representation implies that, even when the size of the output is small, the intermediate data generated during a computation may grow in an unpredictable way. This behavior is called expression swell \uff08\u81a8\u80c0\uff09. To obviate this problem, various methods are used in the representation of the data, as well as in the algorithms that manipulate them. NOTE: \u539f\u6587\u8fd9\u4e00\u8282\u6240\u8ba8\u8bba\u7684\u662f: \u5982\u4f55\u6765\u4f7f\u7528\u8ba1\u7b97\u673a\u8bed\u8a00\u6765\u8868\u793aNumbers\u3001Expressions\uff1f Numbers NOTE: \u672c\u8282\u6240\u8ba8\u8bba\u7684\u662f\u5982\u4f55\u6765\u8868\u793anumber\uff1f Expressions Representation of the expression (8-6)*(3+1) as a Lisp tree, from a 1985 Master's Thesis.[ 7] NOTE: expression\u80fd\u591f\u65b9\u4fbf\u7684\u4f7f\u7528tree\u6765\u8fdb\u884c\u8868\u793a\uff0c\u7136\u540e\u8f6c\u6362\u4e3a\u4e09\u5730\u5740\u7801\u3002 Except for numbers and variables , every mathematical expression may be viewed as the symbol of an operator followed by a sequence of operands. In computer algebra software, the expressions are usually represented in this way. This representation is very flexible, and many things that seem not to be mathematical expressions at first glance, may be represented and manipulated as such. For example, an equation is an expression with \u201c=\u201d as an operator, a matrix may be represented as an expression with \u201cmatrix\u201d as an operator and its rows as operands. Even programs may be considered and represented as expressions with operator \u201c procedure \u201d and, at least, two operands, the list of parameters and the body, which is itself an expression with \u201cbody\u201d as an operator and a sequence of instructions as operands. Conversely, any mathematical expression may be viewed as a program. For example, the expression a + b may be viewed as a program for the addition, with a and b as parameters. Executing this program consists in evaluating the expression for given values of a and b ; if they do not have any value\u2014that is they are indeterminates\u2014, the result of the evaluation is simply its input. This process of delayed evaluation is fundamental in computer algebra . For example, the operator \u201c=\u201d of the equations is also, in most computer algebra systems, the name of the program of the equality test: normally, the evaluation of an equation results in an equation, but, when an equality test is needed,\u2014either explicitly asked by the user through an \u201cevaluation to a Boolean\u201d command, or automatically started by the system in the case of a test inside a program\u2014then the evaluation to a boolean 0 or 1 is executed. As the size of the operands of an expression is unpredictable and may change during a working session, the sequence of the operands is usually represented as a sequence of either pointers (like in Macsyma ) or entries in a hash table (like in Maple ). Simplification NOTE: \u5bf9expression\u8fdb\u884csimplification\u662f\u975e\u5e38\u91cd\u8981\u7684\uff0c\u91cd\u8981\u80fd\u591f\u5927\u5927\u5730\u964d\u4f4e\u8fd0\u7b97\u7684\u590d\u6742\u6027\u3002 This simplification is normally done through rewriting rules . There are several classes of rewriting rules that have to be considered. The simplest consists in the rewriting rules that always reduce the size of the expression, like E \u2212 E \u2192 0 or sin(0) \u2192 0. They are systematically applied in computer algebra systems. Implementation of computer algebra: symbolic programming \u672c\u8282\u63cf\u8ff0\u5982\u4f55\u5b9e\u73b0computer algebra\uff0c\u76ee\u524d\u6700\u5e38\u91c7\u7528\u7684\u4e00\u79cd\u65b9\u5f0f\u662fsymbolic programming\uff0c\u5728\u5de5\u7a0bprogramming-language\u7684 Theory\\Programming-paradigm\\Symbolic-programming \u7ae0\u8282\u5bf9\u5b83\u8fdb\u884c\u4e86\u8be6\u7ec6\u4ecb\u7ecd\u3002 \u5728software engineering\u4e2d\uff0c\u6211\u4eec\u5e38\u5e38\u9700\u8981\u4ee5\u901a\u7528\u7684\u65b9\u5f0f\u6765\u63cf\u8ff0\u4e00\u4e2a\u6570\u5b66\u8ba1\u7b97\uff0c\u6bd4\u5982: 1) \u5982\u4f55\u63cf\u8ff0computation graph 2) \u5728\u91cf\u5316\u4ea4\u6613\u4e2d\uff0c\u81ea\u5b9a\u4e49**\u57fa\u5dee**\u8ba1\u7b97\u516c\u5f0f 3) ...... \u5728\u8fd9\u7c7b\u5e94\u7528\u4e2d\uff0c\u5f80\u5f80\u5b58\u5728\u7740\u4e24\u4e2a\u9636\u6bb5: 1) \u6784\u5efa\u9636\u6bb5 \u4f7f\u7528symbol\u6765\u6784\u5efamath expression\uff0c\u5f80\u5f80\u9700\u8981\u4f7f\u7528domain-specifier language\uff0c\u6bd4\u5982\u76f4\u63a5\u4f7f\u7528math language\u3002 2) Evaluation\u9636\u6bb5 \u7136\u540e\u5bf9\u8fd9\u4e9bsymbol\u8fdb\u884c\u8d4b\u503c\uff0c\u7136\u540e\u5bf9math expression\u8fdb\u884cevaluate\uff0c\u4ece\u800c\u5f97\u5230\u6700\u7ec8\u7684\u7ed3\u679c\u3002 Examples \u4e0b\u9762\u662f\u4e00\u4e9b\u5177\u4f53\u7684\u5b9e\u73b0: SymPy SymPy is a Python library for symbolic mathematics . It aims to become a full-featured computer algebra system (CAS) while keeping the code as simple as possible in order to be comprehensible and easily extensible. SymPy is written entirely in Python. ArashPartow exprtk Deep learning Deep learning\u4e2d\uff0c\u6211\u4eec\u9700\u8981\u6784\u5efacomputational graph\uff0ccomputational graph\u5c31\u662f\u5178\u578b\u7684symbolic mathematics\u3002\u76ee\u524d\u5927\u591a\u6570deep learning implementation\uff0c\u90fd\u652f\u6301symbolic programming\u3002 Expression template Expression template\u662fC++ TMP\u4e2d\u7684\u4e00\u79cd\u91cd\u8981trick\uff0c\u53c2\u89c1 C-family-language\\C++\\Idiom\\TMP\\Expression-Template \u3002 Wolfram Language \u53c2\u89c1wikipedia Wolfram Language : It emphasizes symbolic computation , functional programming , and rule-based programming [ 8] and can employ arbitrary structures and data.[ 8] It is the programming language of the mathematical symbolic computation program Mathematica .[ 9] Symbolic programming VS imperative programming in Symbolic mathematics \u5173\u4e8e\u8fd9\u4e2a\u4e3b\u9898\uff0c\u53c2\u89c1\u5de5\u7a0bmachine-learning\u7684 Programming\\Programming-paradigm\\Symbolic-and-imperative \u7ae0\u8282\u3002","title":"Introduction"},{"location":"Symbolic-computation/Computer-algebra/#_1","text":"\u672c\u7ae0\u8ba8\u8bba\u201dcomputer algebra\u201c\u5373\u201d\u8ba1\u7b97\u4ee3\u6570\u201c\u3002 \u5728\u5b66\u4e60back propagation\u7684\u65f6\u5019\uff0c\u67e5\u9605\u4e86 \u5982\u4f55\u76f4\u89c2\u5730\u89e3\u91ca backpropagation \u7b97\u6cd5\uff1f - YE Y\u7684\u56de\u7b54 - \u77e5\u4e4e \uff0c\u5176\u4e2d\u63d0\u53ca\u4e86\u201c\u8ba1\u7b97\u4ee3\u6570\u201d\uff0c\u67e5\u8be2\u4e86\u4e00\u4e0b\uff0c\u5728\u8ba1\u7b97\u673a\u79d1\u5b66\u4e2d\u662f\u6709\u8fd9\u79cd\u5b66\u79d1\u7684\uff1aComputer algebra\uff0c\u4e0b\u9762\u662fwikipedia Computer algebra \u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Symbolic-computation/Computer-algebra/#wikipedia#computer#algebra","text":"In mathematics and computer science , computer algebra , also called symbolic computation or algebraic computation , is a scientific area that refers to the study and development of algorithms and software for manipulating mathematical expressions and other mathematical objects . NOTE: \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5728\u4e00\u4e9b\u573a\u5408\u5e38\u5e38\u4f7f\u7528symbolic computation NOTE: \u5173\u4e8esymbol\uff0c\u53c2\u89c1 Relation-structure-computation\\Symbol \u7ae0\u8282","title":"wikipedia Computer algebra"},{"location":"Symbolic-computation/Computer-algebra/#computer#algebra#vs#scientific#computing","text":"Although computer algebra could be considered a subfield of scientific computing , they are generally considered as distinct fields because scientific computing is usually based on numerical computation with approximate floating point numbers , while symbolic computation emphasizes exact computation with expressions containing variables that have no given value and are manipulated as symbols .","title":"Computer algebra  VS scientific computing"},{"location":"Symbolic-computation/Computer-algebra/#computer#algebra#systems","text":"Software applications that perform symbolic calculations are called computer algebra systems . NOTE: TensorFlow\u5176\u5b9e\u53ef\u4ee5\u770b\u505a\u662f\u4e00\u4e2acomputer algebra system","title":"Computer algebra systems"},{"location":"Symbolic-computation/Computer-algebra/#computer#science#aspects","text":"NOTE: \u8fd9\u662f\u4f5c\u4e3asoftware engineer\u7684\u4eba\u9700\u8981\u5173\u6ce8\u7684","title":"Computer science aspects"},{"location":"Symbolic-computation/Computer-algebra/#data#representation","text":"It is common, in computer algebra, to emphasize exact computation with exactly represented data. Such an exact representation implies that, even when the size of the output is small, the intermediate data generated during a computation may grow in an unpredictable way. This behavior is called expression swell \uff08\u81a8\u80c0\uff09. To obviate this problem, various methods are used in the representation of the data, as well as in the algorithms that manipulate them. NOTE: \u539f\u6587\u8fd9\u4e00\u8282\u6240\u8ba8\u8bba\u7684\u662f: \u5982\u4f55\u6765\u4f7f\u7528\u8ba1\u7b97\u673a\u8bed\u8a00\u6765\u8868\u793aNumbers\u3001Expressions\uff1f","title":"Data representation"},{"location":"Symbolic-computation/Computer-algebra/#numbers","text":"NOTE: \u672c\u8282\u6240\u8ba8\u8bba\u7684\u662f\u5982\u4f55\u6765\u8868\u793anumber\uff1f","title":"Numbers"},{"location":"Symbolic-computation/Computer-algebra/#expressions","text":"Representation of the expression (8-6)*(3+1) as a Lisp tree, from a 1985 Master's Thesis.[ 7] NOTE: expression\u80fd\u591f\u65b9\u4fbf\u7684\u4f7f\u7528tree\u6765\u8fdb\u884c\u8868\u793a\uff0c\u7136\u540e\u8f6c\u6362\u4e3a\u4e09\u5730\u5740\u7801\u3002 Except for numbers and variables , every mathematical expression may be viewed as the symbol of an operator followed by a sequence of operands. In computer algebra software, the expressions are usually represented in this way. This representation is very flexible, and many things that seem not to be mathematical expressions at first glance, may be represented and manipulated as such. For example, an equation is an expression with \u201c=\u201d as an operator, a matrix may be represented as an expression with \u201cmatrix\u201d as an operator and its rows as operands. Even programs may be considered and represented as expressions with operator \u201c procedure \u201d and, at least, two operands, the list of parameters and the body, which is itself an expression with \u201cbody\u201d as an operator and a sequence of instructions as operands. Conversely, any mathematical expression may be viewed as a program. For example, the expression a + b may be viewed as a program for the addition, with a and b as parameters. Executing this program consists in evaluating the expression for given values of a and b ; if they do not have any value\u2014that is they are indeterminates\u2014, the result of the evaluation is simply its input. This process of delayed evaluation is fundamental in computer algebra . For example, the operator \u201c=\u201d of the equations is also, in most computer algebra systems, the name of the program of the equality test: normally, the evaluation of an equation results in an equation, but, when an equality test is needed,\u2014either explicitly asked by the user through an \u201cevaluation to a Boolean\u201d command, or automatically started by the system in the case of a test inside a program\u2014then the evaluation to a boolean 0 or 1 is executed. As the size of the operands of an expression is unpredictable and may change during a working session, the sequence of the operands is usually represented as a sequence of either pointers (like in Macsyma ) or entries in a hash table (like in Maple ).","title":"Expressions"},{"location":"Symbolic-computation/Computer-algebra/#simplification","text":"NOTE: \u5bf9expression\u8fdb\u884csimplification\u662f\u975e\u5e38\u91cd\u8981\u7684\uff0c\u91cd\u8981\u80fd\u591f\u5927\u5927\u5730\u964d\u4f4e\u8fd0\u7b97\u7684\u590d\u6742\u6027\u3002 This simplification is normally done through rewriting rules . There are several classes of rewriting rules that have to be considered. The simplest consists in the rewriting rules that always reduce the size of the expression, like E \u2212 E \u2192 0 or sin(0) \u2192 0. They are systematically applied in computer algebra systems.","title":"Simplification"},{"location":"Symbolic-computation/Computer-algebra/#implementation#of#computer#algebra#symbolic#programming","text":"\u672c\u8282\u63cf\u8ff0\u5982\u4f55\u5b9e\u73b0computer algebra\uff0c\u76ee\u524d\u6700\u5e38\u91c7\u7528\u7684\u4e00\u79cd\u65b9\u5f0f\u662fsymbolic programming\uff0c\u5728\u5de5\u7a0bprogramming-language\u7684 Theory\\Programming-paradigm\\Symbolic-programming \u7ae0\u8282\u5bf9\u5b83\u8fdb\u884c\u4e86\u8be6\u7ec6\u4ecb\u7ecd\u3002 \u5728software engineering\u4e2d\uff0c\u6211\u4eec\u5e38\u5e38\u9700\u8981\u4ee5\u901a\u7528\u7684\u65b9\u5f0f\u6765\u63cf\u8ff0\u4e00\u4e2a\u6570\u5b66\u8ba1\u7b97\uff0c\u6bd4\u5982: 1) \u5982\u4f55\u63cf\u8ff0computation graph 2) \u5728\u91cf\u5316\u4ea4\u6613\u4e2d\uff0c\u81ea\u5b9a\u4e49**\u57fa\u5dee**\u8ba1\u7b97\u516c\u5f0f 3) ...... \u5728\u8fd9\u7c7b\u5e94\u7528\u4e2d\uff0c\u5f80\u5f80\u5b58\u5728\u7740\u4e24\u4e2a\u9636\u6bb5: 1) \u6784\u5efa\u9636\u6bb5 \u4f7f\u7528symbol\u6765\u6784\u5efamath expression\uff0c\u5f80\u5f80\u9700\u8981\u4f7f\u7528domain-specifier language\uff0c\u6bd4\u5982\u76f4\u63a5\u4f7f\u7528math language\u3002 2) Evaluation\u9636\u6bb5 \u7136\u540e\u5bf9\u8fd9\u4e9bsymbol\u8fdb\u884c\u8d4b\u503c\uff0c\u7136\u540e\u5bf9math expression\u8fdb\u884cevaluate\uff0c\u4ece\u800c\u5f97\u5230\u6700\u7ec8\u7684\u7ed3\u679c\u3002","title":"Implementation of computer algebra: symbolic programming"},{"location":"Symbolic-computation/Computer-algebra/#examples","text":"\u4e0b\u9762\u662f\u4e00\u4e9b\u5177\u4f53\u7684\u5b9e\u73b0:","title":"Examples"},{"location":"Symbolic-computation/Computer-algebra/#sympy","text":"SymPy is a Python library for symbolic mathematics . It aims to become a full-featured computer algebra system (CAS) while keeping the code as simple as possible in order to be comprehensible and easily extensible. SymPy is written entirely in Python.","title":"SymPy"},{"location":"Symbolic-computation/Computer-algebra/#arashpartow#exprtk","text":"","title":"ArashPartow exprtk"},{"location":"Symbolic-computation/Computer-algebra/#deep#learning","text":"Deep learning\u4e2d\uff0c\u6211\u4eec\u9700\u8981\u6784\u5efacomputational graph\uff0ccomputational graph\u5c31\u662f\u5178\u578b\u7684symbolic mathematics\u3002\u76ee\u524d\u5927\u591a\u6570deep learning implementation\uff0c\u90fd\u652f\u6301symbolic programming\u3002","title":"Deep learning"},{"location":"Symbolic-computation/Computer-algebra/#expression#template","text":"Expression template\u662fC++ TMP\u4e2d\u7684\u4e00\u79cd\u91cd\u8981trick\uff0c\u53c2\u89c1 C-family-language\\C++\\Idiom\\TMP\\Expression-Template \u3002","title":"Expression template"},{"location":"Symbolic-computation/Computer-algebra/#wolfram#language","text":"\u53c2\u89c1wikipedia Wolfram Language : It emphasizes symbolic computation , functional programming , and rule-based programming [ 8] and can employ arbitrary structures and data.[ 8] It is the programming language of the mathematical symbolic computation program Mathematica .[ 9]","title":"Wolfram Language"},{"location":"Symbolic-computation/Computer-algebra/#symbolic#programming#vs#imperative#programming#in#symbolic#mathematics","text":"\u5173\u4e8e\u8fd9\u4e2a\u4e3b\u9898\uff0c\u53c2\u89c1\u5de5\u7a0bmachine-learning\u7684 Programming\\Programming-paradigm\\Symbolic-and-imperative \u7ae0\u8282\u3002","title":"Symbolic programming VS imperative programming in Symbolic mathematics"},{"location":"Symbolic-computation/Expression-oriented-language/","text":"Expression-oriented programming language wikipedia Expression-oriented programming language All functional programming languages are expression-oriented . NOTE: \u56e0\u4e3aexpression\u5176\u5b9e\u76f8\u5f53\u4e8e\u662f\u4e00\u4e2afunction\u3002 ALGOL 68 and Lisp are examples of expression-oriented languages. All functional programming languages are expression-oriented. Expression-oriented language and lambda-calculus lambda-calculus\u662f\u4e00\u4e2a\u975e\u5e38\u5f3a\u5927\u7684abstraction model\uff0c\u73b0\u4ee3\u5f88\u591aprogramming language\u7684\u5185\u5bb9\u90fd\u662f\u6e90\u81ea\u4e8e\u5b83\u3002\u672c\u7ae0\u63cf\u8ff0\u7684expression-oriented programming language\u5176\u5b9e\u548c\u5b83\u6709\u7740\u975e\u5e38\u6df1\u523b\u7684\u6e0a\u6e90\u3002","title":"Introduction"},{"location":"Symbolic-computation/Expression-oriented-language/#expression-oriented#programming#language","text":"","title":"Expression-oriented programming language"},{"location":"Symbolic-computation/Expression-oriented-language/#wikipedia#expression-oriented#programming#language","text":"All functional programming languages are expression-oriented . NOTE: \u56e0\u4e3aexpression\u5176\u5b9e\u76f8\u5f53\u4e8e\u662f\u4e00\u4e2afunction\u3002 ALGOL 68 and Lisp are examples of expression-oriented languages. All functional programming languages are expression-oriented.","title":"wikipedia Expression-oriented programming language"},{"location":"Symbolic-computation/Expression-oriented-language/#expression-oriented#language#and#lambda-calculus","text":"lambda-calculus\u662f\u4e00\u4e2a\u975e\u5e38\u5f3a\u5927\u7684abstraction model\uff0c\u73b0\u4ee3\u5f88\u591aprogramming language\u7684\u5185\u5bb9\u90fd\u662f\u6e90\u81ea\u4e8e\u5b83\u3002\u672c\u7ae0\u63cf\u8ff0\u7684expression-oriented programming language\u5176\u5b9e\u548c\u5b83\u6709\u7740\u975e\u5e38\u6df1\u523b\u7684\u6e0a\u6e90\u3002","title":"Expression-oriented language and lambda-calculus"},{"location":"Symbolic-computation/Expression-problem/","text":"Expression problem \u5728\u9605\u8bfb eli.thegreenplace A polyglot's guide to multiple dispatch \u65f6\uff0c\u5176\u4e2d\u63d0\u53ca\u4e86 expression problem: If we don't control the Shape base class at all, we're in real trouble. This is an instance of the expression problem . I'll have more to say about the expression problem in a future post, but for now the Wikipedia link will have to do. stackoverflow What is the 'expression problem'? A Watch this lecture . The idea is that your program is a combination of a datatype and operations over it. The problem asks for an implementation that allows to add new cases of the type and new operations without the need for recompilation of the old modules and keeping static type safety(no casts or runtime type checks). It's interesting to notice that in functional programming languages it's easy to add new operations, but hard to add cases to the datatype . While in an OO language it's the other way round. This is one of the big conceptual differences between the two programming paradigms. wikipedia Expression problem The expression problem is a term used in discussing strengths and weaknesses of various programming paradigms and programming languages . Philip Wadler coined the term[ 1] in response to a discussion with Rice University's Programming Languages Team (PLT) : The expression problem is a new name for an old problem.[ 2] [ 3] The goal is to define a datatype by cases, where one can add new cases to the datatype and new functions over the datatype, without recompiling existing code, and while retaining static type safety (e.g., no casts). Solutions There are various solutions to the expression problem. Each solution varies in the amount of code a user must write to implement them, and the language features they require. Multiple dispatch [ 11] Open classes [ 12] Coproducts of functors [ 13] Type classes [ 14] Tagless-final[ 15] / Object algebras[ 16] Polymorphic Variants[ 17]","title":"Introduction"},{"location":"Symbolic-computation/Expression-problem/#expression#problem","text":"\u5728\u9605\u8bfb eli.thegreenplace A polyglot's guide to multiple dispatch \u65f6\uff0c\u5176\u4e2d\u63d0\u53ca\u4e86 expression problem: If we don't control the Shape base class at all, we're in real trouble. This is an instance of the expression problem . I'll have more to say about the expression problem in a future post, but for now the Wikipedia link will have to do.","title":"Expression problem"},{"location":"Symbolic-computation/Expression-problem/#stackoverflow#what#is#the#expression#problem","text":"A Watch this lecture . The idea is that your program is a combination of a datatype and operations over it. The problem asks for an implementation that allows to add new cases of the type and new operations without the need for recompilation of the old modules and keeping static type safety(no casts or runtime type checks). It's interesting to notice that in functional programming languages it's easy to add new operations, but hard to add cases to the datatype . While in an OO language it's the other way round. This is one of the big conceptual differences between the two programming paradigms.","title":"stackoverflow What is the 'expression problem'?"},{"location":"Symbolic-computation/Expression-problem/#wikipedia#expression#problem","text":"The expression problem is a term used in discussing strengths and weaknesses of various programming paradigms and programming languages . Philip Wadler coined the term[ 1] in response to a discussion with Rice University's Programming Languages Team (PLT) : The expression problem is a new name for an old problem.[ 2] [ 3] The goal is to define a datatype by cases, where one can add new cases to the datatype and new functions over the datatype, without recompiling existing code, and while retaining static type safety (e.g., no casts).","title":"wikipedia Expression problem"},{"location":"Symbolic-computation/Expression-problem/#solutions","text":"There are various solutions to the expression problem. Each solution varies in the amount of code a user must write to implement them, and the language features they require. Multiple dispatch [ 11] Open classes [ 12] Coproducts of functors [ 13] Type classes [ 14] Tagless-final[ 15] / Object algebras[ 16] Polymorphic Variants[ 17]","title":"Solutions"},{"location":"Symbolic-computation/Expression-problem/Extended-visitor-pattern/","text":"\u5173\u4e8e\u672c\u7ae0 \u672c\u7ae0\u63cf\u8ff0 extended visitor pattern\uff0c\u8fd9\u662f\u5728\u9605\u8bfb eli.thegreenplace The Expression Problem and its solutions \u65f6\u6240\u53d1\u73b0\u7684\uff0c\u5728 ./The-Expression-Problem-and-its-solutions \u4e2d\u6536\u5f55\u4e86\u8fd9\u7bc7\u6587\u7ae0\u3002 \u9664\u6b64\u4e4b\u5916\uff0c\u4ee5\u4e0b\u6587\u7ae0\u4e2d\u4e5f\u63cf\u8ff0\u4e86 extended visitor pattern: rice.edu Understanding the Extended Visitor Pattern neu.edu Functional Visitors Revisited ed.ac.uk Independently Extensible Solutions to the Expression Problem stackoverflow Extend Visitor pattern without modifying the original source code?","title":"Introduction"},{"location":"Symbolic-computation/Expression-problem/Extended-visitor-pattern/#_1","text":"\u672c\u7ae0\u63cf\u8ff0 extended visitor pattern\uff0c\u8fd9\u662f\u5728\u9605\u8bfb eli.thegreenplace The Expression Problem and its solutions \u65f6\u6240\u53d1\u73b0\u7684\uff0c\u5728 ./The-Expression-Problem-and-its-solutions \u4e2d\u6536\u5f55\u4e86\u8fd9\u7bc7\u6587\u7ae0\u3002 \u9664\u6b64\u4e4b\u5916\uff0c\u4ee5\u4e0b\u6587\u7ae0\u4e2d\u4e5f\u63cf\u8ff0\u4e86 extended visitor pattern: rice.edu Understanding the Extended Visitor Pattern neu.edu Functional Visitors Revisited ed.ac.uk Independently Extensible Solutions to the Expression Problem stackoverflow Extend Visitor pattern without modifying the original source code?","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Symbolic-computation/Expression-problem/Extended-visitor-pattern/Synthesizing-Object-Oriented-and-Functional-Design-to-Promote-Re-Use/","text":"Synthesizing Object-Oriented and Functional Design to Promote Re-Use \u662f\u5728\u9605\u8bfb eli.thegreenplace The Expression Problem and its solutions \u65f6\uff0c\u5176\u4e2d\u4ecb\u7ecd\u4e86\u8fd9\u7bc7\u8bba\u6587\u3002 Synthesizing Object-Oriented and Functional Design to Promote Re-Use Shriram Krishnamurthi, Matthias Felleisen, Daniel P. Friedman European Conference on Object-Oriented Programming, 1998 Abstract Many problems require recursively specified types of data and a collection of tools that operate on those data. Over time, these problems evolve so that the programmer must extend the toolkit or extend the types and adjust the existing tools accordingly. Ideally, this should be done without modifying existing code. Unfortunately, the prevailing program design strategies do not support both forms of extensibility: functional programming accommodates the addition of tools, while object-oriented programming supports either adding new tools or extending the data set, but not both. In this paper, we present a composite design pattern that synthesizes the best of both approaches and in the process resolves the tension between the two design strategies. We also show how this protocol suggests a new set of linguistic facilities for languages that support class systems.","title":"Introduction"},{"location":"Symbolic-computation/Expression-problem/Extended-visitor-pattern/Synthesizing-Object-Oriented-and-Functional-Design-to-Promote-Re-Use/#synthesizing#object-oriented#and#functional#design#to#promote#re-use","text":"\u662f\u5728\u9605\u8bfb eli.thegreenplace The Expression Problem and its solutions \u65f6\uff0c\u5176\u4e2d\u4ecb\u7ecd\u4e86\u8fd9\u7bc7\u8bba\u6587\u3002","title":"Synthesizing Object-Oriented and Functional Design to Promote Re-Use"},{"location":"Symbolic-computation/Expression-problem/Extended-visitor-pattern/Synthesizing-Object-Oriented-and-Functional-Design-to-Promote-Re-Use/#synthesizing#object-oriented#and#functional#design#to#promote#re-use_1","text":"Shriram Krishnamurthi, Matthias Felleisen, Daniel P. Friedman European Conference on Object-Oriented Programming, 1998","title":"Synthesizing Object-Oriented and Functional Design to Promote Re-Use"},{"location":"Symbolic-computation/Expression-problem/Extended-visitor-pattern/Synthesizing-Object-Oriented-and-Functional-Design-to-Promote-Re-Use/#abstract","text":"Many problems require recursively specified types of data and a collection of tools that operate on those data. Over time, these problems evolve so that the programmer must extend the toolkit or extend the types and adjust the existing tools accordingly. Ideally, this should be done without modifying existing code. Unfortunately, the prevailing program design strategies do not support both forms of extensibility: functional programming accommodates the addition of tools, while object-oriented programming supports either adding new tools or extending the data set, but not both. In this paper, we present a composite design pattern that synthesizes the best of both approaches and in the process resolves the tension between the two design strategies. We also show how this protocol suggests a new set of linguistic facilities for languages that support class systems.","title":"Abstract"},{"location":"Symbolic-computation/Expression-problem/Extended-visitor-pattern/eli.thegreenplace-The-Expression-Problem-and-its-solutions/","text":"eli.thegreenplace The Expression Problem and its solutions The craft(\u6280\u5de7) of programming is almost universally concerned with different types of data and operations/algorithms that act on this data [ 1] . Therefore, it's hardly surprising that designing abstractions for data types and operations has been on the mind of software engineers and programming-language designers since... forever. Problem statement NOTE: \u95ee\u9898\u63cf\u8ff0: 1 \u6dfb\u52a0new type 2 \u6dfb\u52a0new operation 3 without changing existing code Here is a quick problem statement . Imagine that we have a set of data types and a set of operations that act on these types. Sometimes we need to add more operations and make sure they work properly on all types; sometimes we need to add more types and make sure all operations work properly on them. Sometimes, however, we need to add both - and herein lies the problem. Most of the mainstream programming languages don't provide good tools to add both new types and new operations to an existing system without having to change existing code . This is called the \" expression problem \". Studying the problem and its possible solutions gives great insight into the fundamental differences between object-oriented and functional programming and well as concepts like interfaces and multiple dispatch . A motivating example As is my wont, my example comes from the world of compilers and interpreters. Imagine we're designing a simple expression evaluator. Following the standard interpreter design pattern , we have a tree structure consisting of expressions, with some operations we can do on such trees. In C++ we'd have an interface every node in the expression tree would have to implement: class Expr #include <string> class Expr { public : virtual std :: string ToString () const = 0 ; virtual double Eval () const = 0 ; }; This interface shows that we currently have two operations we can do on expression trees - evaluate them and query for their string representations. A typical leaf node expression: class Constant class Constant : public Expr { public : Constant ( double value ) : value_ ( value ) { } std :: string ToString () const { std :: ostringstream ss ; ss << value_ ; return ss . str (); } double Eval () const { return value_ ; } private : double value_ ; }; And a typical composite expression: class BinaryPlus class BinaryPlus : public Expr { public : BinaryPlus ( const Expr & lhs , const Expr & rhs ) : lhs_ ( lhs ), rhs_ ( rhs ) { } std :: string ToString () const { return lhs_ . ToString () + \" + \" + rhs_ . ToString (); } double Eval () const { return lhs_ . Eval () + rhs_ . Eval (); } private : const Expr & lhs_ ; const Expr & rhs_ ; }; Until now, it's all fairly basic stuff. How extensible is this design? Let's see... if we want to add new expression types (\"variable reference\", \"function call\" etc.), that's pretty easy. We just define additional classes inheriting from Expr and implement the Expr interface ( ToString and Eval ). Adding new operations However, what happens if we want to add new operations that can be applied to expression trees ? Right now we have Eval and ToString , but we may want additional operations like \"type check\" or \"serialize\" or \"compile to machine code\" or whatever. It turns out that adding new operations isn't as easy as adding new types. We'd have to change the Expr interface, and consequently change every existing expression type to support the new method(s). If we don't control the original code or it's hard to change it for other reasons, we're in trouble. Expression problem in OOP In other words, we'd have to violate the venerable(\u73cd\u8d35\u7684) open-closed principle , one of the main principles of object-oriented design , defined as: software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification The problem we're hitting here is called the expression problem , and the example above shows how it applies to object-oriented programming. Interestingly, the expression problem bites(\u54ac\u4f24) functional programming languages as well. Let's see how. The expression problem in functional programming Update 2018-02-05: a new post discusses the problem and its solutions in Haskell in more depth. OOP VS FP Object-oriented approaches tend to collect functionality in objects (types). Functional languages cut the cake from a different angle, usually preferring types as thin data containers, collecting most functionality in functions (operations) that act upon them. Functional languages don't escape the expression problem - it just manifests there in a different way. NOTE: \u4e0a\u9762\u8fd9\u4e00\u6bb5\u63cf\u8ff0\u4e86OOP \u548c FP\u4e4b\u95f4\u7684\u5dee\u5f02 To demonstrate this, let's see how the expression evaluator / stringifier looks in Haskell. Haskell is a good poster child for functional programming since its pattern matching on types makes such code especially succinct: module Expressions where data Expr = Constant Double | BinaryPlus Expr Expr stringify :: Expr -> String stringify ( Constant c ) = show c stringify ( BinaryPlus lhs rhs ) = stringify lhs ++ \" + \" ++ stringify rhs evaluate :: Expr -> Double evaluate ( Constant c ) = c evaluate ( BinaryPlus lhs rhs ) = evaluate lhs + evaluate rhs Adding new operations Now let's say we want to add a new operation - type checking. We simply have to add a new function typecheck and define how it behaves for all known kinds of expressions. No need to modify existing code. Add a new type On the other hand, if we want to add a new type (like \"function call\"), we get into trouble. We now have to modify all existing functions to handle this new type. So we hit exactly the same problem, albeit(\u5c3d\u7ba1) from a different angle. The expression problem matrix A visual representation of the expression problem can be helpful to appreciate how it applies to OOP and FP in different ways, and how a potential solution would look. The following 2-D table (a \"matrix\") has types in its rows and operations in its columns. A matrix cell row, col is checked when the operation col is implemented for type row : In object-oriented languages, it's easy to add new types but difficult to add new operations: Whereas in functional languages, it's easy to add new operations but difficult to add new types: A historical perspective The expression problem isn't new, and has likely been with us since the early days; it pops its head as soon as programs reach some not-too-high level of complexity. It's fairly certain that the name expression problem comes from an email sent by Philip Wadler to a mailing list deailing with adding generics to Java (this was back in the 1990s). In that email, Wadler points to the paper \"Synthesizing Object-Oriented and Functional Design to Promote Re-Use\" by Krishnamurthi, Felleisen and Friedman as an earlier work describing the problem and proposed solutions. This is a great paper and I highly recommend reading it. Krishnamurthi et.al., in their references, point to papers from as early as 1975 describing variations of the problem in Algol. NOTE: \u8fd9\u7bc7\u8bba\u6587\u6536\u5f55\u5728\u4e86 Expression-oriented-programming\\Expression-problem\\Synthesizing-Object-Oriented-and-Functional-Design-to-Promote-Re-Use \u7ae0\u8282\u4e2d\u3002 Flipping(\u7ffb\u8f6c) the matrix with the visitor pattern It's possible to kinda(\u4e00\u70b9\u513f) solve (read on to understand why I say \"kinda\") the expression problem in object-oriented languages ; first, we have to look at how we can flip the problem on its side using the visitor pattern . The visitor pattern is very common for this kind of problems, and for a good reason. It lets us reformulate(\u518d\u5f62\u5f0f\u5316\u8868\u793a) our code in a way that makes it easier to change in some dimensions (though harder in others). For the C++ sample shown above, rewriting it using the visitor pattern means adding a new \"visitor\" interface: class ExprVisitor { public : virtual void VisitConstant ( const Constant & c ) = 0 ; virtual void VisitBinaryPlus ( const BinaryPlus & bp ) = 0 ; }; And changing the Expr interface to be: class Expr { public : virtual void Accept ( ExprVisitor * visitor ) const = 0 ; }; Now expression types defer(\u63a8\u8fdf) the actual computation to the visitor, as follows: class Constant : public Expr { public : Constant ( double value ) : value_ ( value ) { } void Accept ( ExprVisitor * visitor ) const { visitor -> VisitConstant ( * this ); } double GetValue () const { return value_ ; } private : double value_ ; }; // ... similarly, BinaryPlus would have // // void Accept(ExprVisitor* visitor) const { // visitor->VisitBinaryPlus(*this); // } // // ... etc. Evaluator visitor A sample visitor for evaluation would be [ 2] : class Evaluator : public ExprVisitor { public : double GetValueForExpr ( const Expr & e ) { return value_map_ [ & e ]; } void VisitConstant ( const Constant & c ) { value_map_ [ & c ] = c . GetValue (); } void VisitBinaryPlus ( const BinaryPlus & bp ) { bp . GetLhs (). Accept ( this ); bp . GetRhs (). Accept ( this ); value_map_ [ & bp ] = value_map_ [ & ( bp . GetLhs ())] + value_map_ [ & ( bp . GetRhs ())]; } private : std :: map < const Expr * , double > value_map_ ; }; Problem It should be obvious that for a given set of data types, adding new visitors is easy and doesn't require modifying any other code. On the other hand, adding new types is problematic since it means we have to update the ExprVisitor interface with a new abstract method, and consequently update all the visitors to implement it. So it seems that we've just turned the expression problem on its side: we're using an OOP language, but now it's hard to add types and easy to add ops, just like in the functional approach. I find it extremely interesting that we can do this. In my eyes this highlights the power of different abstractions and paradigms, and how they enable us to rethink a problem in a completely different light. So we haven't solved anything yet; we've just changed the nature of the problem we're facing. Worry not - this is just a stepping stone to an actual solution. Extending the visitor pattern The following is code excerpts from a C++ solution that follows the extended visitor pattern proposed by Krishnamurthi et. al. in their paper; I strongly suggest reading the paper (particularly section 3) if you want to understand this code on a deep level. A complete code sample in C++ that compiles and runs is available here . Adding new visitors (ops) with the visitor pattern is easy. Our challenge is to add a new type without upheaving too much existing code. Let's see how it's done. Evaluator visitor One small design change that we should make to the original visitor pattern is use virtual inheritance for Evaluator , for reasons that will soon become obvious: class Evaluator : virtual public ExprVisitor { // .. the rest is the same }; Add a new type Now we're going to add a new type - FunctionCall : // This is the new (\"extended\") expression we're adding. class FunctionCall : public Expr { public : FunctionCall ( const std :: string & name , const Expr & argument ) : name_ ( name ), argument_ ( argument ) { } void Accept ( ExprVisitor * visitor ) const { ExprVisitorWithFunctionCall * v = dynamic_cast < ExprVisitorWithFunctionCall *> ( visitor ); if ( v == nullptr ) { std :: cerr << \"Fatal: visitor is not ExprVisitorWithFunctionCall \\n \" ; exit ( 1 ); } v -> VisitFunctionCall ( * this ); } private : std :: string name_ ; const Expr & argument_ ; }; New evaluator visitor Since we don't want to modify the existing visitors, we create a new one, extending Evaluator for function calls. But first, we need to extend the ExprVisitor interface to support the new type: class ExprVisitorWithFunctionCall : virtual public ExprVisitor { public : virtual void VisitFunctionCall ( const FunctionCall & fc ) = 0 ; }; Finally, we write the new evaluator, which extends Evaluator and supports the new type: class EvaluatorWithFunctionCall : public ExprVisitorWithFunctionCall , public Evaluator { public : void VisitFunctionCall ( const FunctionCall & fc ) { std :: cout << \"Visiting FunctionCall!! \\n \" ; } }; NOTE: \u7ee7\u627f Evaluator \u7684\u76ee\u7684\u662f: inherits all functionality from Evaluator \u7ee7\u627f ExprVisitorWithFunctionCall \u7684\u76ee\u7684\u662f: implements the ExprVisitorWithFunctionCall interface Multiple inheritance , virtual inheritance , dynamic type checking ... that's pretty hard-core C++ we have to use here, but there's no choice. Unfortunately, multiple inheritance is the only way C++ lets us express the idea that a class implements some interface while at the same time deriving functionality from another class. What we want to have here is an evaluator ( EvaluatorWithFunctionCall ) that inherits all functionality from Evaluator , and also implements the ExprVisitorWithFunctionCall interface. In Java, we could say something like: class EvaluatorWithFunctionCall extends Evaluator implements ExprVisitor { // ... } But in C++ virtual multiple inheritance is the tool we have. The virtual part of the inheritance is essential here for the compiler to figure out that the ExprVisitor base underlying both Evaluator and ExprVisitorWithFunctionCall is the same and should only appear once in EvaluatorWithFunctionCall . Without virtual, the compiler would complain that EvaluatorWithFunctionCall doesn't implement the ExprVisitor interface. This is a solution, alright. We kinda added a new type FunctionCall and can now visit it without changing existing code (assuming the virtual inheritance was built into the design from the start to anticipate this approach). Here I am using this \"kinda\" word again... it's time to explain why. This approach has multiple flaws, in my opinion: 1 Note the dynamic_cast in FunctionCall::Accept . It's fairly ugly that we're forced to mix in dynamic checks into this code, which should supposedly rely on static typing and the compiler. But it's just a sign of a larger problem. 2 If we have an instance of an Evaluator , it will no longer work on the whole extended expression tree since it has no understanding of FunctionCall . It's easy to say that all new evaluators should rather be EvaluatorWithFunctionCall , but we don't always control this. What about code that was already written? What about Evaluator s created in third-party or library code which we have no control of? 3 The virtual inheritance is not the only provision we have to build into the design to support this pattern. Some visitors would need to create new, recursive visitors to process complex expressions. But we can't anticipate in advance which dynamic type of visitor needs to be created. Therefore, the visitor interface should also accept a \"visitor factory\" which extended visitors will supply. I know this sounds complicated, and I don't want to spend more time on this here - but the Krishnamurthi paper addresses this issue extensively in section 3.4 4 Finally, the solution is unwieldy for realistic applications. Adding one new type looks manageable; what about adding 15 new types, gradually over time? Imagine the horrible zoo of ExprVisitor extensions and dynamic checks this would lead to. Yeah, programming is hard. I could go on and on about the limitations of classical OOP and how they surface in this example [ 3] . Instead, I'll just present how the expression problem can be solved in a language that supports multiple dispatch and separates the defintion of methods from the bodies of types they act upon. Solving the expression problem in Clojure There are a number of ways the expression problem as displayed in this article can be solved in Clojure using the language's built-in features. Let's start with the simplest one - multi-methods. Is multiple dispatch necessary to cleanly solve the expression problem? Another Clojure solution - using protocols Small interfaces are extensibility-friendly","title":"Introduction"},{"location":"Symbolic-computation/Expression-problem/Extended-visitor-pattern/eli.thegreenplace-The-Expression-Problem-and-its-solutions/#elithegreenplace#the#expression#problem#and#its#solutions","text":"The craft(\u6280\u5de7) of programming is almost universally concerned with different types of data and operations/algorithms that act on this data [ 1] . Therefore, it's hardly surprising that designing abstractions for data types and operations has been on the mind of software engineers and programming-language designers since... forever.","title":"eli.thegreenplace The Expression Problem and its solutions"},{"location":"Symbolic-computation/Expression-problem/Extended-visitor-pattern/eli.thegreenplace-The-Expression-Problem-and-its-solutions/#problem#statement","text":"NOTE: \u95ee\u9898\u63cf\u8ff0: 1 \u6dfb\u52a0new type 2 \u6dfb\u52a0new operation 3 without changing existing code Here is a quick problem statement . Imagine that we have a set of data types and a set of operations that act on these types. Sometimes we need to add more operations and make sure they work properly on all types; sometimes we need to add more types and make sure all operations work properly on them. Sometimes, however, we need to add both - and herein lies the problem. Most of the mainstream programming languages don't provide good tools to add both new types and new operations to an existing system without having to change existing code . This is called the \" expression problem \". Studying the problem and its possible solutions gives great insight into the fundamental differences between object-oriented and functional programming and well as concepts like interfaces and multiple dispatch .","title":"Problem statement"},{"location":"Symbolic-computation/Expression-problem/Extended-visitor-pattern/eli.thegreenplace-The-Expression-Problem-and-its-solutions/#a#motivating#example","text":"As is my wont, my example comes from the world of compilers and interpreters. Imagine we're designing a simple expression evaluator. Following the standard interpreter design pattern , we have a tree structure consisting of expressions, with some operations we can do on such trees. In C++ we'd have an interface every node in the expression tree would have to implement:","title":"A motivating example"},{"location":"Symbolic-computation/Expression-problem/Extended-visitor-pattern/eli.thegreenplace-The-Expression-Problem-and-its-solutions/#class#expr","text":"#include <string> class Expr { public : virtual std :: string ToString () const = 0 ; virtual double Eval () const = 0 ; }; This interface shows that we currently have two operations we can do on expression trees - evaluate them and query for their string representations. A typical leaf node expression:","title":"class Expr"},{"location":"Symbolic-computation/Expression-problem/Extended-visitor-pattern/eli.thegreenplace-The-Expression-Problem-and-its-solutions/#class#constant","text":"class Constant : public Expr { public : Constant ( double value ) : value_ ( value ) { } std :: string ToString () const { std :: ostringstream ss ; ss << value_ ; return ss . str (); } double Eval () const { return value_ ; } private : double value_ ; }; And a typical composite expression:","title":"class Constant"},{"location":"Symbolic-computation/Expression-problem/Extended-visitor-pattern/eli.thegreenplace-The-Expression-Problem-and-its-solutions/#class#binaryplus","text":"class BinaryPlus : public Expr { public : BinaryPlus ( const Expr & lhs , const Expr & rhs ) : lhs_ ( lhs ), rhs_ ( rhs ) { } std :: string ToString () const { return lhs_ . ToString () + \" + \" + rhs_ . ToString (); } double Eval () const { return lhs_ . Eval () + rhs_ . Eval (); } private : const Expr & lhs_ ; const Expr & rhs_ ; }; Until now, it's all fairly basic stuff. How extensible is this design? Let's see... if we want to add new expression types (\"variable reference\", \"function call\" etc.), that's pretty easy. We just define additional classes inheriting from Expr and implement the Expr interface ( ToString and Eval ).","title":"class BinaryPlus"},{"location":"Symbolic-computation/Expression-problem/Extended-visitor-pattern/eli.thegreenplace-The-Expression-Problem-and-its-solutions/#adding#new#operations","text":"However, what happens if we want to add new operations that can be applied to expression trees ? Right now we have Eval and ToString , but we may want additional operations like \"type check\" or \"serialize\" or \"compile to machine code\" or whatever. It turns out that adding new operations isn't as easy as adding new types. We'd have to change the Expr interface, and consequently change every existing expression type to support the new method(s). If we don't control the original code or it's hard to change it for other reasons, we're in trouble.","title":"Adding new operations"},{"location":"Symbolic-computation/Expression-problem/Extended-visitor-pattern/eli.thegreenplace-The-Expression-Problem-and-its-solutions/#expression#problem#in#oop","text":"In other words, we'd have to violate the venerable(\u73cd\u8d35\u7684) open-closed principle , one of the main principles of object-oriented design , defined as: software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification The problem we're hitting here is called the expression problem , and the example above shows how it applies to object-oriented programming. Interestingly, the expression problem bites(\u54ac\u4f24) functional programming languages as well. Let's see how.","title":"Expression problem in OOP"},{"location":"Symbolic-computation/Expression-problem/Extended-visitor-pattern/eli.thegreenplace-The-Expression-Problem-and-its-solutions/#the#expression#problem#in#functional#programming","text":"Update 2018-02-05: a new post discusses the problem and its solutions in Haskell in more depth.","title":"The expression problem in functional programming"},{"location":"Symbolic-computation/Expression-problem/Extended-visitor-pattern/eli.thegreenplace-The-Expression-Problem-and-its-solutions/#oop#vs#fp","text":"Object-oriented approaches tend to collect functionality in objects (types). Functional languages cut the cake from a different angle, usually preferring types as thin data containers, collecting most functionality in functions (operations) that act upon them. Functional languages don't escape the expression problem - it just manifests there in a different way. NOTE: \u4e0a\u9762\u8fd9\u4e00\u6bb5\u63cf\u8ff0\u4e86OOP \u548c FP\u4e4b\u95f4\u7684\u5dee\u5f02 To demonstrate this, let's see how the expression evaluator / stringifier looks in Haskell. Haskell is a good poster child for functional programming since its pattern matching on types makes such code especially succinct: module Expressions where data Expr = Constant Double | BinaryPlus Expr Expr stringify :: Expr -> String stringify ( Constant c ) = show c stringify ( BinaryPlus lhs rhs ) = stringify lhs ++ \" + \" ++ stringify rhs evaluate :: Expr -> Double evaluate ( Constant c ) = c evaluate ( BinaryPlus lhs rhs ) = evaluate lhs + evaluate rhs","title":"OOP VS FP"},{"location":"Symbolic-computation/Expression-problem/Extended-visitor-pattern/eli.thegreenplace-The-Expression-Problem-and-its-solutions/#adding#new#operations_1","text":"Now let's say we want to add a new operation - type checking. We simply have to add a new function typecheck and define how it behaves for all known kinds of expressions. No need to modify existing code.","title":"Adding new operations"},{"location":"Symbolic-computation/Expression-problem/Extended-visitor-pattern/eli.thegreenplace-The-Expression-Problem-and-its-solutions/#add#a#new#type","text":"On the other hand, if we want to add a new type (like \"function call\"), we get into trouble. We now have to modify all existing functions to handle this new type. So we hit exactly the same problem, albeit(\u5c3d\u7ba1) from a different angle.","title":"Add a new type"},{"location":"Symbolic-computation/Expression-problem/Extended-visitor-pattern/eli.thegreenplace-The-Expression-Problem-and-its-solutions/#the#expression#problem#matrix","text":"A visual representation of the expression problem can be helpful to appreciate how it applies to OOP and FP in different ways, and how a potential solution would look. The following 2-D table (a \"matrix\") has types in its rows and operations in its columns. A matrix cell row, col is checked when the operation col is implemented for type row : In object-oriented languages, it's easy to add new types but difficult to add new operations: Whereas in functional languages, it's easy to add new operations but difficult to add new types:","title":"The expression problem matrix"},{"location":"Symbolic-computation/Expression-problem/Extended-visitor-pattern/eli.thegreenplace-The-Expression-Problem-and-its-solutions/#a#historical#perspective","text":"The expression problem isn't new, and has likely been with us since the early days; it pops its head as soon as programs reach some not-too-high level of complexity. It's fairly certain that the name expression problem comes from an email sent by Philip Wadler to a mailing list deailing with adding generics to Java (this was back in the 1990s). In that email, Wadler points to the paper \"Synthesizing Object-Oriented and Functional Design to Promote Re-Use\" by Krishnamurthi, Felleisen and Friedman as an earlier work describing the problem and proposed solutions. This is a great paper and I highly recommend reading it. Krishnamurthi et.al., in their references, point to papers from as early as 1975 describing variations of the problem in Algol. NOTE: \u8fd9\u7bc7\u8bba\u6587\u6536\u5f55\u5728\u4e86 Expression-oriented-programming\\Expression-problem\\Synthesizing-Object-Oriented-and-Functional-Design-to-Promote-Re-Use \u7ae0\u8282\u4e2d\u3002","title":"A historical perspective"},{"location":"Symbolic-computation/Expression-problem/Extended-visitor-pattern/eli.thegreenplace-The-Expression-Problem-and-its-solutions/#flipping#the#matrix#with#the#visitor#pattern","text":"It's possible to kinda(\u4e00\u70b9\u513f) solve (read on to understand why I say \"kinda\") the expression problem in object-oriented languages ; first, we have to look at how we can flip the problem on its side using the visitor pattern . The visitor pattern is very common for this kind of problems, and for a good reason. It lets us reformulate(\u518d\u5f62\u5f0f\u5316\u8868\u793a) our code in a way that makes it easier to change in some dimensions (though harder in others). For the C++ sample shown above, rewriting it using the visitor pattern means adding a new \"visitor\" interface: class ExprVisitor { public : virtual void VisitConstant ( const Constant & c ) = 0 ; virtual void VisitBinaryPlus ( const BinaryPlus & bp ) = 0 ; }; And changing the Expr interface to be: class Expr { public : virtual void Accept ( ExprVisitor * visitor ) const = 0 ; }; Now expression types defer(\u63a8\u8fdf) the actual computation to the visitor, as follows: class Constant : public Expr { public : Constant ( double value ) : value_ ( value ) { } void Accept ( ExprVisitor * visitor ) const { visitor -> VisitConstant ( * this ); } double GetValue () const { return value_ ; } private : double value_ ; }; // ... similarly, BinaryPlus would have // // void Accept(ExprVisitor* visitor) const { // visitor->VisitBinaryPlus(*this); // } // // ... etc.","title":"Flipping(\u7ffb\u8f6c) the matrix with the visitor pattern"},{"location":"Symbolic-computation/Expression-problem/Extended-visitor-pattern/eli.thegreenplace-The-Expression-Problem-and-its-solutions/#evaluator#visitor","text":"A sample visitor for evaluation would be [ 2] : class Evaluator : public ExprVisitor { public : double GetValueForExpr ( const Expr & e ) { return value_map_ [ & e ]; } void VisitConstant ( const Constant & c ) { value_map_ [ & c ] = c . GetValue (); } void VisitBinaryPlus ( const BinaryPlus & bp ) { bp . GetLhs (). Accept ( this ); bp . GetRhs (). Accept ( this ); value_map_ [ & bp ] = value_map_ [ & ( bp . GetLhs ())] + value_map_ [ & ( bp . GetRhs ())]; } private : std :: map < const Expr * , double > value_map_ ; };","title":"Evaluator visitor"},{"location":"Symbolic-computation/Expression-problem/Extended-visitor-pattern/eli.thegreenplace-The-Expression-Problem-and-its-solutions/#problem","text":"It should be obvious that for a given set of data types, adding new visitors is easy and doesn't require modifying any other code. On the other hand, adding new types is problematic since it means we have to update the ExprVisitor interface with a new abstract method, and consequently update all the visitors to implement it. So it seems that we've just turned the expression problem on its side: we're using an OOP language, but now it's hard to add types and easy to add ops, just like in the functional approach. I find it extremely interesting that we can do this. In my eyes this highlights the power of different abstractions and paradigms, and how they enable us to rethink a problem in a completely different light. So we haven't solved anything yet; we've just changed the nature of the problem we're facing. Worry not - this is just a stepping stone to an actual solution.","title":"Problem"},{"location":"Symbolic-computation/Expression-problem/Extended-visitor-pattern/eli.thegreenplace-The-Expression-Problem-and-its-solutions/#extending#the#visitor#pattern","text":"The following is code excerpts from a C++ solution that follows the extended visitor pattern proposed by Krishnamurthi et. al. in their paper; I strongly suggest reading the paper (particularly section 3) if you want to understand this code on a deep level. A complete code sample in C++ that compiles and runs is available here . Adding new visitors (ops) with the visitor pattern is easy. Our challenge is to add a new type without upheaving too much existing code. Let's see how it's done.","title":"Extending the visitor pattern"},{"location":"Symbolic-computation/Expression-problem/Extended-visitor-pattern/eli.thegreenplace-The-Expression-Problem-and-its-solutions/#evaluator#visitor_1","text":"One small design change that we should make to the original visitor pattern is use virtual inheritance for Evaluator , for reasons that will soon become obvious: class Evaluator : virtual public ExprVisitor { // .. the rest is the same };","title":"Evaluator visitor"},{"location":"Symbolic-computation/Expression-problem/Extended-visitor-pattern/eli.thegreenplace-The-Expression-Problem-and-its-solutions/#add#a#new#type_1","text":"Now we're going to add a new type - FunctionCall : // This is the new (\"extended\") expression we're adding. class FunctionCall : public Expr { public : FunctionCall ( const std :: string & name , const Expr & argument ) : name_ ( name ), argument_ ( argument ) { } void Accept ( ExprVisitor * visitor ) const { ExprVisitorWithFunctionCall * v = dynamic_cast < ExprVisitorWithFunctionCall *> ( visitor ); if ( v == nullptr ) { std :: cerr << \"Fatal: visitor is not ExprVisitorWithFunctionCall \\n \" ; exit ( 1 ); } v -> VisitFunctionCall ( * this ); } private : std :: string name_ ; const Expr & argument_ ; };","title":"Add a new type"},{"location":"Symbolic-computation/Expression-problem/Extended-visitor-pattern/eli.thegreenplace-The-Expression-Problem-and-its-solutions/#new#evaluator#visitor","text":"Since we don't want to modify the existing visitors, we create a new one, extending Evaluator for function calls. But first, we need to extend the ExprVisitor interface to support the new type: class ExprVisitorWithFunctionCall : virtual public ExprVisitor { public : virtual void VisitFunctionCall ( const FunctionCall & fc ) = 0 ; }; Finally, we write the new evaluator, which extends Evaluator and supports the new type: class EvaluatorWithFunctionCall : public ExprVisitorWithFunctionCall , public Evaluator { public : void VisitFunctionCall ( const FunctionCall & fc ) { std :: cout << \"Visiting FunctionCall!! \\n \" ; } }; NOTE: \u7ee7\u627f Evaluator \u7684\u76ee\u7684\u662f: inherits all functionality from Evaluator \u7ee7\u627f ExprVisitorWithFunctionCall \u7684\u76ee\u7684\u662f: implements the ExprVisitorWithFunctionCall interface Multiple inheritance , virtual inheritance , dynamic type checking ... that's pretty hard-core C++ we have to use here, but there's no choice. Unfortunately, multiple inheritance is the only way C++ lets us express the idea that a class implements some interface while at the same time deriving functionality from another class. What we want to have here is an evaluator ( EvaluatorWithFunctionCall ) that inherits all functionality from Evaluator , and also implements the ExprVisitorWithFunctionCall interface. In Java, we could say something like: class EvaluatorWithFunctionCall extends Evaluator implements ExprVisitor { // ... } But in C++ virtual multiple inheritance is the tool we have. The virtual part of the inheritance is essential here for the compiler to figure out that the ExprVisitor base underlying both Evaluator and ExprVisitorWithFunctionCall is the same and should only appear once in EvaluatorWithFunctionCall . Without virtual, the compiler would complain that EvaluatorWithFunctionCall doesn't implement the ExprVisitor interface. This is a solution, alright. We kinda added a new type FunctionCall and can now visit it without changing existing code (assuming the virtual inheritance was built into the design from the start to anticipate this approach). Here I am using this \"kinda\" word again... it's time to explain why. This approach has multiple flaws, in my opinion: 1 Note the dynamic_cast in FunctionCall::Accept . It's fairly ugly that we're forced to mix in dynamic checks into this code, which should supposedly rely on static typing and the compiler. But it's just a sign of a larger problem. 2 If we have an instance of an Evaluator , it will no longer work on the whole extended expression tree since it has no understanding of FunctionCall . It's easy to say that all new evaluators should rather be EvaluatorWithFunctionCall , but we don't always control this. What about code that was already written? What about Evaluator s created in third-party or library code which we have no control of? 3 The virtual inheritance is not the only provision we have to build into the design to support this pattern. Some visitors would need to create new, recursive visitors to process complex expressions. But we can't anticipate in advance which dynamic type of visitor needs to be created. Therefore, the visitor interface should also accept a \"visitor factory\" which extended visitors will supply. I know this sounds complicated, and I don't want to spend more time on this here - but the Krishnamurthi paper addresses this issue extensively in section 3.4 4 Finally, the solution is unwieldy for realistic applications. Adding one new type looks manageable; what about adding 15 new types, gradually over time? Imagine the horrible zoo of ExprVisitor extensions and dynamic checks this would lead to. Yeah, programming is hard. I could go on and on about the limitations of classical OOP and how they surface in this example [ 3] . Instead, I'll just present how the expression problem can be solved in a language that supports multiple dispatch and separates the defintion of methods from the bodies of types they act upon.","title":"New evaluator visitor"},{"location":"Symbolic-computation/Expression-problem/Extended-visitor-pattern/eli.thegreenplace-The-Expression-Problem-and-its-solutions/#solving#the#expression#problem#in#clojure","text":"There are a number of ways the expression problem as displayed in this article can be solved in Clojure using the language's built-in features. Let's start with the simplest one - multi-methods.","title":"Solving the expression problem in Clojure"},{"location":"Symbolic-computation/Expression-problem/Extended-visitor-pattern/eli.thegreenplace-The-Expression-Problem-and-its-solutions/#is#multiple#dispatch#necessary#to#cleanly#solve#the#expression#problem","text":"","title":"Is multiple dispatch necessary to cleanly solve the expression problem?"},{"location":"Symbolic-computation/Expression-problem/Extended-visitor-pattern/eli.thegreenplace-The-Expression-Problem-and-its-solutions/#another#clojure#solution#-#using#protocols","text":"","title":"Another Clojure solution - using protocols"},{"location":"Symbolic-computation/Expression-problem/Extended-visitor-pattern/eli.thegreenplace-The-Expression-Problem-and-its-solutions/#small#interfaces#are#extensibility-friendly","text":"","title":"Small interfaces are extensibility-friendly"},{"location":"Symbolic-computation/Expression-problem/Object-Algebra/","text":"Solutions to the Expression Problem Using Object Algebras wikipedia Expression problem#Problem Solution using Object Algebra cs.hku Solutions to the Expression Problem Using Object Algebras This page documents solutions to the Expression Problem using object algebras . These solutions are meant to illustrate the use of object algebras in various programming languages. Object algebras and a solution to the Expression Problem in Java were presented in the paper: Extensibility for the Masses: Practical Extensibility with Object Algebras Bruno C. d. S. Oliveira and William R. Cook The source code for the paper can be found here . Reading the paper is recommended for understanding the code in the solutions as this web page only contains very limited information. If you have a solution for the expression problem in your favourite language, and that language is not listed here, please consider sending it to us. We will publish it here together with the information about the author responsible for it. Background: The Expression Problem Requirements for a solution Solutions using Object Algebras","title":"Introduction"},{"location":"Symbolic-computation/Expression-problem/Object-Algebra/#solutions#to#the#expression#problem#using#object#algebras","text":"","title":"Solutions to the Expression Problem Using Object Algebras"},{"location":"Symbolic-computation/Expression-problem/Object-Algebra/#wikipedia#expression#problemproblem#solution#using#object#algebra","text":"","title":"wikipedia Expression problem#Problem Solution using Object Algebra"},{"location":"Symbolic-computation/Expression-problem/Object-Algebra/#cshku#solutions#to#the#expression#problem#using#object#algebras","text":"This page documents solutions to the Expression Problem using object algebras . These solutions are meant to illustrate the use of object algebras in various programming languages. Object algebras and a solution to the Expression Problem in Java were presented in the paper: Extensibility for the Masses: Practical Extensibility with Object Algebras Bruno C. d. S. Oliveira and William R. Cook The source code for the paper can be found here . Reading the paper is recommended for understanding the code in the solutions as this web page only contains very limited information. If you have a solution for the expression problem in your favourite language, and that language is not listed here, please consider sending it to us. We will publish it here together with the information about the author responsible for it.","title":"cs.hku Solutions to the Expression Problem Using Object Algebras"},{"location":"Symbolic-computation/Expression-problem/Object-Algebra/#background#the#expression#problem","text":"","title":"Background: The Expression Problem"},{"location":"Symbolic-computation/Expression-problem/Object-Algebra/#requirements#for#a#solution","text":"","title":"Requirements for a solution"},{"location":"Symbolic-computation/Expression-problem/Object-Algebra/#solutions#using#object#algebras","text":"","title":"Solutions using Object Algebras"},{"location":"Symbolic-computation/Symbol-expression/","text":"Symbol expression \u5728computer science\u3001mathematics\u4e2d \uff0csymbol expression\u662f\u4e00\u79cd\u975e\u5e38\u6709\u6548\u7684\u3001\u5e7f\u6cdb\u91c7\u7528\u7684\u63cf\u8ff0\u65b9\u5f0f/\u8bed\u8a00\uff0c\u672c\u7ae0\u5c06\u5bf9\u5b83\u8fdb\u884c\u4e13\u95e8\u63cf\u8ff0\u3002 wanweibaike S-expression In computer programming , S-expressions (or symbolic expressions , abbreviated as sexprs ) are a notation for nested list ( tree -structured) data, invented for and popularized by the programming language Lisp , which uses them for source code as well as data. NOTE: \u4e00\u3001\"expression tree and \u62ec\u53f7-Nested parentheses\" \u4e8c\u3001\u5173\u4e8eS-expression\u7684\u4e00\u4e9b\u975e\u5e38\u597d\u7684\u4f8b\u5b50\uff0c\u53c2\u89c1: a\u3001cs.unm 11 S-expressions, the Syntax of Lisp Symbol expression in computer science 1\u3001\u5728computer science\u4e2d\uff0c\u4f7f\u7528symbol expression\u6765\u63cf\u8ff0abstract structure(\u8fd9\u5176\u5b9e\u662f\u4e00\u6b21\u62bd\u8c61\u8fc7\u7a0b)\uff0c\u7136\u540e\u4f9d\u636e\u6b64structure\u6765\u751f\u6210computation\u3002\u6bd4\u5982formal language\u3001computational graph\u3002\u7406\u89e3\u8bed\u4e49\u3002 2\u3001\u672c\u6587\u662f\u5728computer algebra\u3001formal language\u4e4b\u4e0a\u7684\uff0c\u4ee5\u4e00\u4e2a\u66f4\u9ad8\u7684\u89d2\u5ea6\u6765\u63cf\u8ff0\u5b83\u4eec\uff0c\u6216\u8005\u8bf4\uff0c\u5b83\u4eec\u90fd\u53ef\u4ee5\u770b\u505a\u662fsymbol\u7684\u4e00\u79cdapplication \u3002 Symbol expression and tree 1\u3001\u5728computer science\u4e2d\uff0csymbol expression \u90fd\u53ef\u4ee5\u4f7f\u7528tree\u3001graph\u6765\u8fdb\u884c\u63cf\u8ff0\u3001\u5b9e\u73b0\u3002 2\u3001expression tree Expression \u5728\u4e0b\u9762\u7ae0\u8282\u4e2d\u6d89\u53ca\u5230\u4e86expression: 1) Theory\\Programming-language-construct\\Basic-Language-construct 2) C-family-language\\C-and-C++\\Expression 3) \u5de5\u7a0bcompiler-principle\u7684 Chapter-2-A-Simple-Syntax-Directed-Translator\\2.2-Syntax-Definition \u8282 4) \u5de5\u7a0blanguage\u7684 Language\\Language-in-discipline \u7ae0\u8282","title":"Introduction"},{"location":"Symbolic-computation/Symbol-expression/#symbol#expression","text":"\u5728computer science\u3001mathematics\u4e2d \uff0csymbol expression\u662f\u4e00\u79cd\u975e\u5e38\u6709\u6548\u7684\u3001\u5e7f\u6cdb\u91c7\u7528\u7684\u63cf\u8ff0\u65b9\u5f0f/\u8bed\u8a00\uff0c\u672c\u7ae0\u5c06\u5bf9\u5b83\u8fdb\u884c\u4e13\u95e8\u63cf\u8ff0\u3002","title":"Symbol expression"},{"location":"Symbolic-computation/Symbol-expression/#wanweibaike#s-expression","text":"In computer programming , S-expressions (or symbolic expressions , abbreviated as sexprs ) are a notation for nested list ( tree -structured) data, invented for and popularized by the programming language Lisp , which uses them for source code as well as data. NOTE: \u4e00\u3001\"expression tree and \u62ec\u53f7-Nested parentheses\" \u4e8c\u3001\u5173\u4e8eS-expression\u7684\u4e00\u4e9b\u975e\u5e38\u597d\u7684\u4f8b\u5b50\uff0c\u53c2\u89c1: a\u3001cs.unm 11 S-expressions, the Syntax of Lisp","title":"wanweibaike S-expression"},{"location":"Symbolic-computation/Symbol-expression/#symbol#expression#in#computer#science","text":"1\u3001\u5728computer science\u4e2d\uff0c\u4f7f\u7528symbol expression\u6765\u63cf\u8ff0abstract structure(\u8fd9\u5176\u5b9e\u662f\u4e00\u6b21\u62bd\u8c61\u8fc7\u7a0b)\uff0c\u7136\u540e\u4f9d\u636e\u6b64structure\u6765\u751f\u6210computation\u3002\u6bd4\u5982formal language\u3001computational graph\u3002\u7406\u89e3\u8bed\u4e49\u3002 2\u3001\u672c\u6587\u662f\u5728computer algebra\u3001formal language\u4e4b\u4e0a\u7684\uff0c\u4ee5\u4e00\u4e2a\u66f4\u9ad8\u7684\u89d2\u5ea6\u6765\u63cf\u8ff0\u5b83\u4eec\uff0c\u6216\u8005\u8bf4\uff0c\u5b83\u4eec\u90fd\u53ef\u4ee5\u770b\u505a\u662fsymbol\u7684\u4e00\u79cdapplication \u3002","title":"Symbol expression in computer science"},{"location":"Symbolic-computation/Symbol-expression/#symbol#expression#and#tree","text":"1\u3001\u5728computer science\u4e2d\uff0csymbol expression \u90fd\u53ef\u4ee5\u4f7f\u7528tree\u3001graph\u6765\u8fdb\u884c\u63cf\u8ff0\u3001\u5b9e\u73b0\u3002 2\u3001expression tree","title":"Symbol expression and tree"},{"location":"Symbolic-computation/Symbol-expression/#expression","text":"\u5728\u4e0b\u9762\u7ae0\u8282\u4e2d\u6d89\u53ca\u5230\u4e86expression: 1) Theory\\Programming-language-construct\\Basic-Language-construct 2) C-family-language\\C-and-C++\\Expression 3) \u5de5\u7a0bcompiler-principle\u7684 Chapter-2-A-Simple-Syntax-Directed-Translator\\2.2-Syntax-Definition \u8282 4) \u5de5\u7a0blanguage\u7684 Language\\Language-in-discipline \u7ae0\u8282","title":"Expression"},{"location":"Symbolic-computation/Symbolic-computation/","text":"Symbolic computation stackoverflow What is symbolic computation? According to wiki : In mathematics and computer science, computer algebra, also called symbolic computation or algebraic computation is a scientific area that refers to the study and development of algorithms and software for manipulating mathematical expressions and other mathematical objects Does symbolic computation focus on symbol manipulation and computation? Lisp program is written in the form of an AST with atoms as leaves. Lisp is said to be language for symbolic computing. Does it mean that in symbolic computation, it is: all about symbols (symbols are atoms or non-atom expressions in Lisp) every symbol is assigned a semantic symbolic computation is a paradigm that orients programmers to focus on working with symbols and semantics (a semantic can be an atom or expression that does something) and the relationships between symbols, as opposed to think that data structure and code are two separated entities. program design is language design, based on symbol composition/manipulation and semantic assignment. According to this question , the opposite of symbolic computation is numeric computation. What's the primary difference between these two? When I work with Octave (I'm studying it), I have to work with numbers a lot and have to guess the meaning of those magic numbers many times. Is this a numerical computation focus? risc Studying Symbolic Computation \u53c2\u89c1 course-risc-Studying-Symbolic-Computation \u7ae0\u8282\u3002","title":"Introduction"},{"location":"Symbolic-computation/Symbolic-computation/#symbolic#computation","text":"","title":"Symbolic computation"},{"location":"Symbolic-computation/Symbolic-computation/#stackoverflow#what#is#symbolic#computation","text":"According to wiki : In mathematics and computer science, computer algebra, also called symbolic computation or algebraic computation is a scientific area that refers to the study and development of algorithms and software for manipulating mathematical expressions and other mathematical objects Does symbolic computation focus on symbol manipulation and computation? Lisp program is written in the form of an AST with atoms as leaves. Lisp is said to be language for symbolic computing. Does it mean that in symbolic computation, it is: all about symbols (symbols are atoms or non-atom expressions in Lisp) every symbol is assigned a semantic symbolic computation is a paradigm that orients programmers to focus on working with symbols and semantics (a semantic can be an atom or expression that does something) and the relationships between symbols, as opposed to think that data structure and code are two separated entities. program design is language design, based on symbol composition/manipulation and semantic assignment. According to this question , the opposite of symbolic computation is numeric computation. What's the primary difference between these two? When I work with Octave (I'm studying it), I have to work with numbers a lot and have to guess the meaning of those magic numbers many times. Is this a numerical computation focus?","title":"stackoverflow What is symbolic computation?"},{"location":"Symbolic-computation/Symbolic-computation/#risc#studying#symbolic#computation","text":"\u53c2\u89c1 course-risc-Studying-Symbolic-Computation \u7ae0\u8282\u3002","title":"risc Studying Symbolic Computation"},{"location":"Symbolic-computation/Symbolic-computation/risc-Studying-Symbolic-Computation/","text":"risc Studying Symbolic Computation NOTE: \u4ecb\u7ecd\u5730\u975e\u5e38\u597d\uff0c\u603b\u7ed3\u7684\u975e\u5e38\u597d\u3002 Symbolic computation is the sub-area of mathematics and computer science which solves problems on symbolic objects representable on a computer. Typical examples of such objects are algebraic expressions, logical propositions, and programs themselves. The problem solutions are integrated in many advanced software systems for computer algebra, computer aided design and manufacturing, computer supported reasoning, knowledge management, and formal system specification and verification. Besides playing a fundamental role within mathematics itself, symbolic computation is thus a key technology in many scientific and technical areas today. More than any other area, symbolic computation depends on the integration of the theoretical foundations (mathematics, logics, algorithms), the implementation in software systems, and the practical applications. It is a main objective of the symbolic computation curriculum (\u8bfe\u7a0b) at RISC to unite these three aspects. Graduates of this program are not only experts in symbolic computation but, due to their work in highly abstract models with the goal to develop effective software solutions, also professionals in developing innovative computer-based solutions for challenging problems arising in theoretical investigations and real-world applications. Therefore they are highly qualified to find their place in research and development , in academia and industry . Within the realm(\u9886\u57df) of symbolic computation, research at RISC mainly falls into three general categories: Computer Algebra We design and implement algorithms that operate on algebraic expressions; typical application areas are e.g. (algebraic) geometry and (algorithmic) combinatorics. Computational Logic We work on the specification, management, and derivation of knowledge expressed in the language of symbolic logic (resulting in software systems for supporting mathematical proving) and on the theory of computation. Mathematical Software We develop various symbolic computation software such as it occurs in computer algebra systems and theorem provers and study the logical foundations of software for the purpose of formal system specification and verification. These categories (which present different views to the same field with strong overlappings and interrelationships) are also reflected in the RISC curriculum. See this list of applications for sample outcomes of this research. Symbolic Computation (An Editorial) , Bruno Buchberger , Journal of Symbolic Computation (1985) 1, pp. 1\u20136. NOTE: \u5df2\u7ecf\u4e0b\u8f7d\u5230\u4e86\u672c\u5730","title":"Introduction"},{"location":"Symbolic-computation/Symbolic-computation/risc-Studying-Symbolic-Computation/#risc#studying#symbolic#computation","text":"NOTE: \u4ecb\u7ecd\u5730\u975e\u5e38\u597d\uff0c\u603b\u7ed3\u7684\u975e\u5e38\u597d\u3002 Symbolic computation is the sub-area of mathematics and computer science which solves problems on symbolic objects representable on a computer. Typical examples of such objects are algebraic expressions, logical propositions, and programs themselves. The problem solutions are integrated in many advanced software systems for computer algebra, computer aided design and manufacturing, computer supported reasoning, knowledge management, and formal system specification and verification. Besides playing a fundamental role within mathematics itself, symbolic computation is thus a key technology in many scientific and technical areas today. More than any other area, symbolic computation depends on the integration of the theoretical foundations (mathematics, logics, algorithms), the implementation in software systems, and the practical applications. It is a main objective of the symbolic computation curriculum (\u8bfe\u7a0b) at RISC to unite these three aspects. Graduates of this program are not only experts in symbolic computation but, due to their work in highly abstract models with the goal to develop effective software solutions, also professionals in developing innovative computer-based solutions for challenging problems arising in theoretical investigations and real-world applications. Therefore they are highly qualified to find their place in research and development , in academia and industry . Within the realm(\u9886\u57df) of symbolic computation, research at RISC mainly falls into three general categories: Computer Algebra We design and implement algorithms that operate on algebraic expressions; typical application areas are e.g. (algebraic) geometry and (algorithmic) combinatorics. Computational Logic We work on the specification, management, and derivation of knowledge expressed in the language of symbolic logic (resulting in software systems for supporting mathematical proving) and on the theory of computation. Mathematical Software We develop various symbolic computation software such as it occurs in computer algebra systems and theorem provers and study the logical foundations of software for the purpose of formal system specification and verification. These categories (which present different views to the same field with strong overlappings and interrelationships) are also reflected in the RISC curriculum. See this list of applications for sample outcomes of this research.","title":"risc Studying Symbolic Computation"},{"location":"Symbolic-computation/Symbolic-computation/risc-Studying-Symbolic-Computation/#symbolic#computation#an#editorial#bruno#buchberger#journal#of#symbolic#computation#1985#1#pp#16","text":"NOTE: \u5df2\u7ecf\u4e0b\u8f7d\u5230\u4e86\u672c\u5730","title":"Symbolic Computation (An Editorial), Bruno Buchberger, Journal of Symbolic Computation (1985) 1, pp. 1\u20136."},{"location":"Symbolic-computation/Symbolic-programming/","text":"Symbolic programming \u5728\u5b66\u4e60deep learning\u7684\u65f6\u5019\uff0c\u5176\u4e2d\u63cf\u8ff0\u4e86symbolic programing\uff0c\u56e0\u6b64\uff0c\u542f\u53d1\u4e86\u6211\u9700\u8981\u5bf9symbolic programming\u8fdb\u884c\u603b\u7ed3\u3002 wolfram\u662f\u91c7\u7528symbolic programming paradigm\u7684\u4e00\u79cdprogramming language\uff0c\u6240\u4ee5\uff0c\u6211\u4eec\u7ed3\u5408wolfram Symbolic Programming: Computationally Active Language \u6765\u7406\u89e3symbolic programming\u3002 wolfram Symbolic Programming: Computationally Active Language NOTE: \u8fd9\u7bc7\u6587\u7ae0\u7684\u4f5c\u8005\u4ece\u4e00\u4e2a\u975e\u5e38\u9ad8\u3001\u62bd\u8c61\u7684\u5c42\u6b21\u5bf9symbolic programming\u8fdb\u884c\u4e86\u63cf\u8ff0\u3002wolfram\u662f\u4e00\u79cdprogramming language\uff0c\u5b83\u662f\u652f\u6301symbolic programming\u7684\u3002 In this blog and elsewhere, you\u2019ll often see the statement that some advanced Mathematica feature is just another application of symbolic programming . It\u2019s the kind of idea that seems too powerful to explain in a single blog post, yet simple enough that I am tempted to try. So, here goes. \u7ffb\u8bd1: \u5728\u672c\u535a\u5ba2\u548c\u5176\u4ed6\u5730\u65b9\uff0c\u60a8\u5c06\u7ecf\u5e38\u770b\u5230\u8fd9\u6837\u7684\u8bf4\u6cd5:\u67d0\u4e9b\u9ad8\u7ea7Mathematica\u7279\u6027\u53ea\u662fsymbolic programming\u7684\u53e6\u4e00\u4e2a\u5e94\u7528\u3002\u8fd9\u79cd\u60f3\u6cd5\u4f3c\u4e4e\u8fc7\u4e8e\u5f3a\u5927\u4ee5\u81f3\u4e8e\u65e0\u6cd5\u5728\u4e00\u7bc7\u535a\u5ba2\u6587\u7ae0\u4e2d\u89e3\u91ca\u6e05\u695a\uff0c\u4f46\u5374\u8db3\u591f\u7b80\u5355\uff0c\u8ba9\u6211\u5fcd\u4e0d\u4f4f\u53bb\u5c1d\u8bd5\u4e00\u4e0b\u3002 Symbolic programming is based on the concept of recasting(\u91cd\u94f8) core features of human language into a computationally active form . \u7ffb\u8bd1: \u7b26\u53f7\u7f16\u7a0b\u662f\u57fa\u4e8e\u5982\u4e0b\u6982\u5ff5: \u5c06\u4eba\u7c7b\u8bed\u8a00\u7684\u6838\u5fc3\u7279\u6027\u91cd\u94f8\u4e3a\u8ba1\u7b97\u6d3b\u52a8\u7684\u5f62\u5f0f\u3002\u5728\u540e\u9762\u5c06\u5b83\u79f0\u4e3a\"human-language-oriented programming language\"\u5373\"\u9762\u5411\u4eba\u7c7b\u8bed\u8a00\u7684\u7f16\u7a0b\u8bed\u8a00\"\u3002 NOTE: \u90a3\u4e0a\u8ff0**computationally active form**\u662f\u4ec0\u4e48form\u5462\uff1f\u5728\"Computation: The Transformation of Meaning\"\u7ae0\u8282\u4e2d\u4f1a\u5bf9\u6b64\u8fdb\u884c\u8bf4\u660e\u3002 What does it mean to have a human-language-oriented programming language? \u7ffb\u8bd1: \u62e5\u6709\u4e00\u79cd\u9762\u5411\u4eba\u7c7b\u8bed\u8a00\u7684\u7f16\u7a0b\u8bed\u8a00\u610f\u5473\u7740\u4ec0\u4e48? Our cognitive model of computation is typically a three-stage process: 1) describing the computation; 2) executing that description; and 3) outputting the results. The \u201clanguage\u201d part of most programming languages begins and ends with stage one. Linguistic structures are erected(\u5efa\u7acb) to describe the program. But the execution of the program is typically oriented around an entirely different system of types and objects; and likewise, the program\u2019s output structure tends to resemble nothing particularly language-like. Symbolic programming uses linguistic structures as the foundation of all aspects of computation . From a computation\u2019s description, to how the computation executes, to how humans interface with the results, the exact same basic tree structure is used throughout. This is a powerful unification (\u7edf\u4e00), making possible many useful computations that in other systems range from cumbersome to practically impossible. We\u2019ll see examples along the way, but let me first describe what these linguistic structures actually are. \u7ffb\u8bd1: \u8fd9\u662f\u4e00\u4e2a\u5f3a\u5927\u7684\u7edf\u4e00\uff0c\u4f7f\u5f97\u8bb8\u591a\u6709\u7528\u7684\u8ba1\u7b97\u6210\u4e3a\u53ef\u80fd\uff0c\u800c\u8fd9\u4e9b\u8ba1\u7b97\u5728\u5176\u4ed6\u7cfb\u7edf\u4e2d\u4ece\u7e41\u7410\u5230\u51e0\u4e4e\u4e0d\u53ef\u80fd\u3002 \u6211\u4eec\u4f1a\u770b\u5230\u4e00\u4e9b\u4f8b\u5b50\uff0c\u4f46\u8ba9\u6211\u5148\u63cf\u8ff0\u4e00\u4e0b\u8fd9\u4e9b\u8bed\u8a00\u7ed3\u6784\u5230\u5e95\u662f\u4ec0\u4e48\u3002 \u4e0b\u9762\u7684\u5c81\u4e0a\u9762\u4e09\u6bb5\u8bdd\u7684\u5185\u5bb9\u7684\u7406\u89e3\u3001\u5206\u6790: \u7b2c\u4e00\u6bb5\u8bdd\u548c\u7b2c\u4e8c\u6bb5\u8bdd\u5bf9\u6bd4\u4e86other programming language\u548cprogramming language using symbolic programming: \u4f5c\u8005\u8ba4\u4e3a\u5b83\u4eec\u4e4b\u95f4\u4e3b\u8981\u5dee\u5f02\u662f: Symbolic programming \u7684 model of computation \u90fd\u662f\u57fa\u4e8e\u5b83\u7684 linguistic structures \uff0c\u5b83\u91c7\u7528\u7684\u662f**unification**(\u7edf\u4e00)\u7684\u65b9\u5f0f\uff1b Symbolic programming \u7684 model of computation \u5176\u5b9e\u4e5f\u975e\u5e38\u5f3a\u5927\uff0c\u4e5f\u80fd\u591f\u5b9e\u73b0\u975e\u5e38\u591a\u7684computation\uff0c\u5728\u7b2c\u4e09\u6bb5\u8bdd\u4e2d\uff0c\u5bf9\u6b64\u8fdb\u884c\u4e86\u63cf\u8ff0\u3002 other programming language\u5219\u4e0d\u662f\u91c7\u7528\u7684**unification**(\u7edf\u4e00)\u7684\u65b9\u5f0f\uff0c\u5b83\u4eec\u7684execution of the program\u4e0d\u662f\u57fa\u4e8e\u5b83\u4eec\u7684**Linguistic structures**\u3002\u7ed3\u5408C\u6765\u7406\u89e3\u4e0a\u9762\u8fd9\u6bb5\u8bdd: C program\u662f\u9700\u8981\u7b26\u5408\u4e00\u5b9a\u7684**linguistic structure**\u7684\uff0cC program\u9700\u8981\u7ecf\u8fc7compiler\u7684\u7ffb\u8bd1\uff0c\u8f6c\u6362\u4e3ainstruction\u7684\u65b9\u5f0f\u6765\u7531CPU\u6267\u884c\uff0c\u663e\u7136C program\u7684\u6267\u884c\u4e0eC program\u7684linguistic structure\u662f\u4e0d\u4e00\u81f4\u7684\u3002 \u5728 stackoverflow Mathematica: what is symbolic programming? # A \u4e2d\u5bf9**Symbolic programming** \u7684 model of computation \u4e5f\u6709\u7740\u76f8\u5173\u7684\u89e3\u91ca: I would characterize a symbolic programming environment as one in which the expressions used to represent program text also happen to be the primary data structure. As a result, it becomes very easy to build abstractions upon abstractions since data can easily be transformed into code and vice versa. \u5f53\u4eca\uff0cprogramming language\u7684 linguistic structure \u90fd\u662f\u91c7\u7528\u7684tree structure\u3002 Symbols: The Atoms of Language \u7ffb\u8bd1: \u7b26\u53f7:\u8bed\u8a00\u7684\u539f\u5b50 Symbols are the basic atoms of language and also of symbolic programming . The point of symbols is to have distinct pieces of notation\u2014be they words or mathematical functions or musical notes\u2014which are then assigned an interpretation within the overall system. \u7ffb\u8bd1: \u7b26\u53f7\u662f\u8bed\u8a00\u7684\u57fa\u672c\u539f\u5b50\uff0c\u4e5f\u662f\u7b26\u53f7\u7f16\u7a0b\u7684\u57fa\u672c\u539f\u5b50\u3002\u7b26\u53f7\u7684\u610f\u4e49\u5728\u5b83\u80fd\u591f\u6709\u4e0d\u540c\u7684notation\u2014\u2014\u65e0\u8bba\u662f\u5355\u8bcd\u3001\u6570\u5b66\u51fd\u6570\u8fd8\u662f\u97f3\u7b26\u2014\u2014\u7136\u540e\u5728\u6574\u4e2a\u7cfb\u7edf\u4e2d\u88ab\u5206\u914d\u89e3\u91ca\u3002 \u76f4\u767d\u7684\u610f\u601d\u662f: symbol\u5176\u5b9e\u662f\u4e00\u79cd\u6307\u4ee3\uff0c\u5b83\u80fd\u591f\u6307\u4ee3\u7684\u4e8b\u7269\u7684\u8303\u56f4\u662f\u975e\u5e38\u5e7f\u6cdb\u7684\uff0c\u6bd4\u5982\u8fd9\u6bb5\u8bdd\u4e2d\u6240\u5217\u4e3e\u7684: word\u3001mathematical function\uff0c\u81f3\u4e8esymbol\u6240\u6307\u4ee3\u7684\u5185\u5bb9\uff0c\u9700\u8981\u540e\u7eed\u8fdb\u884c\u8d4b\u503c\uff0c\u8fd9\u5c31\u662f\u6700\u540e\u4e00\u6bb5\u8bdd\u7684\u542b\u4e49\u3002\u5728deep learning\u4e2d\uff0c\u4e00\u822c\u5c06symbol\u79f0\u4e3aplaceholder\uff0c\u6bd4\u5982: 1) mxnet Deep Learning Programming Paradigm : We define the abstract function in terms of placeholder values 2) TensorFlow \u540e\u9762\u4f1a\u5bf9symbol\u7684\u542b\u4e49\u3001\u4f5c\u7528\u8fdb\u884c\u66f4\u52a0\u5168\u9762\u7684\u63cf\u8ff0\u3002 symbol VS variable NOTE: \u4e24\u8005\u7684\u6838\u5fc3\u5dee\u522b\u5728\u4e8e: variable\u9700\u8981\u63d0\u524d\u5b9a\u4e49\u624d\u80fd\u591f\u4f7f\u7528\uff0c\u800csymbol\u4e0d\u9700\u8981\u5b9a\u4e49\u5c31\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528\u3002 In programming, the defining feature of symbols is that they can stand for themselves. This is in contrast to variables , which must stand for some other value or be considered an error. For instance, JavaScript cannot perform the operation x + x unless x has a value: while Mathematica has no trouble: By existing simply as distinct entities, symbols serve as lightweight carriers of meaning. They are inert\uff08\u60f0\u6027\u7684\u3001lazy\uff09, but can acquire meaning through combination with other symbols. For example the symbol for Pi is generically just another symbol, but when it appears \u201cwithin\u201d the symbol N , it takes on its special numerical meaning: Because Mathematica manipulates things abstractly, it is able to do more-precise computation than some other systems. As the above example makes clear, symbols are only the building blocks: the real action is with the arrangements of symbols. NOTE: arrangements of symbols\u5176\u5b9e\u5c31\u662f\u524d\u9762\u4e00\u76f4\u5f3a\u8c03\u7684structure\uff0c\u5c31\u662f\u4e0b\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u63cf\u8ff0\u7684Symbolic Expression\u3002 Symbolic Expressions: Combining Symbols into Meaning NOTE: \u672c\u8282\u6807\u9898\u4e2d\uff0c\u6240\u8c13\u7684\"meaning\"\uff0c\u5176\u5b9e\u662fsemantic\u3002 An English phrase is built of subphrases. A mathematical formula is built of subformulas. A musical score is built of bars, which contain notes. A web page layout is built from sublayouts. When humans want to communicate nontrivial structures, they use hierarchical nesting. NOTE: \u5173\u4e8enesting\u5173\u7cfb\uff0c\u53c2\u89c1\u5de5\u7a0bdiscrete\u7684 Relation-structure-computation\\Model\\Nesting-relation-model \u7ae0\u8282 Across different languages and domains, these structures, or trees, take many syntactic forms. However, they can always be reduced to very simple data structures known as symbolic expressions . Symbolic expressions simply capture the concept of arranging symbols into trees . Here are a few trees built from the symbol \u201ce\u201d: Like the symbols themselves, trees of symbols may simply exist, without a need to correspond to something else: Symbolic expressions are the fabric from which we construct meaning. Different tree structures correspond to different meanings. NOTE: \u8fd9\u6bb5\u8bdd\u5176\u5b9e\u662f\u5bf9\u672c\u8282\u6807\u9898\u7684\u89e3\u91ca\uff0c\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u7684\u610f\u601d\u662f: \u5728symbolic programming\u4e2d\uff0c\u6211\u4eec\u4f1a\u4f7f\u7528 symbolic expression \uff0c\u901a\u8fc7 symbolic expression \uff0c\u6211\u4eec\u5b9e\u73b0\u4e86 \"construct meaning\"\u3002\u4e0d\u540c\u7684 symbolic expression \u6709\u7740\u4e0d\u540c\u7684 tree structure\uff0c\u4ece\u800c\u8868\u8fbe\u4e0d\u540c\u7684 meaning\u3002 A tree with symbols like Plus and Power may represent an arithmetic expression, while the symbol SetterBar can be combined with a subtree indicating the current selection and a list of possible alternatives: Everything in Mathematica is ultimately represented using this uniform simple structure . At the formal level, it ensures a degree of structural compatibility across all parts of the far-flung(\u5e7f\u6cdb\u7684) system. It also provides a system for introducing your own lightweight yet sophisticated structures. Pure functions , for example, are the original killer apps for lightweight structures of this vein. In Mathematica, they can be represented with Function , but let\u2019s roll our own using other generic primitives: MyPureFunction [ var_ , expr_ ][ arg_ ] := expr /. var -> arg Let\u2019s describe a function that adds 1 to its argument, and attach it to the symbol f . Notice the structure stays inert(\u60f0\u6027), and therefore can be passed around as data: When brought into contact with an argument , the definition fires. In symbolic programming , it is commonplace\uff08\u53f8\u7a7a\u89c1\u60ef\u7684\uff09 for a programmer to create abstractions that in another language would have required a modification of the core specification. This is the beauty of language: that creating new concepts does not require inventing new atomic \u201ctypes\u201d of things\u2014only new arrangements of structure. NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u7684\u542b\u4e49\u662f: \u5728\u5176\u5b83\u7684programming language\u4e2d\uff0c\u521b\u5efa\u65b0\u7684abstraction\u9700\u8981modification of the core specification\uff0c\u4f46\u662f\u5728**symbolic programming**\u4e2d\u5e76\u4e0d\u9700\u8981\uff0c\u5b83\u53ea\u9700\u8981new arrangement of structure\u3002 Computation: The Transformation of Meaning The most important and unique aspect of symbolic programming is that these tree structures can be made computationally active . They don\u2019t just describe things\u2014they actually execute. The basic idea is that because meaning is encoded by structure , computation \u2014the transformation of one meaning into another\u2014corresponds to the transformation of one structure into another. For instance, position 1 in the SetterBar expression represents the current selection. By modifying the tree at that position, we modify the meaning of the expression as a whole: A computation begins and ends with unique, domain-specific structures. The process of computation, however, is executed using extremely general methods that are exactly the same across domains: So, computation proceeds by very generic tree transformations . Rather conveniently, trees are also how we specify the computations themselves. NOTE: computation\u3001representation\u90fd\u662f\u57fa\u4e8etree\u7684\uff0c\u8fd9\u5c31\u662f\u5728\u672c\u6587\u524d\u9762\u6240\u63d0\u51fa\u7684\u6838\u5fc3\u601d\u60f3\u3002 This reduces the process of computation into a linguistic puzzle: using trees to describe how other trees should transform and intersect. Not only does this allow computational primitives to have an immediate and clear meaning, it also allows the process of language design to proceed organically as regularities in these tree structures are discovered and abstracted. Representing and Interacting with Meaning Symbolic programming\u2019s comprehensive emphasis on meaning allows a unique perspective on input, output and the whole interaction cycle between human and machine computation. The basic idea is that symbolic expressions are the canonical, abstract containers of meaning. Given a symbolic expression, its meaning can then be embodied in a number of useful ways. For example, the expression Plus[2,2] is rendered as 2+2 . And Graphics[Rectangle[]] renders as: And it works similarly for all sorts of domain-specific mathematics notation, documents and even sound and music primitives. On their own, these are useful representations. But the fact that they are still really the same underlying expression leads to a powerful consequence: human computation and programmatic computation become structurally equivalent. If I interactively create a Disk using a drawing palette: its underlying data structure is the same as it would be if I had typed in the code, or if it had been generated by a program: Graphics[Disk[{0.49, 0.49}, {0.35, 0.35}],ImageSize -> {36.335, Automatic},PlotRange -> {{0, 1}, {0, 1}}] Completely different representations\u2014in this case text and graphics\u2014are immediately and transparently compatible, because in the end they are all just expressions . Here we have some \u201czero-overhead\u201d code to color just the disks of a graphic : The equivalence between these representations, and between human and programmatically generated structures, opens the door to exceptionally powerful ways of interacting with computation. It is the basis of Mathematica\u2019s dynamic interactivity framework. The implications, however, go much further than that. Symbolic programming is the first abstraction that can uniformly span all three stages of computation, from specification to execution to output, and as a result it can leverage each aspect against the others. Programs can be created by traditional programming, by the programs themselves or by interaction with what is considered output. The process of computation can be equivalently executed by the user or by the machine. Output is simply exposing a window into a piece of a (possibly running) program. It\u2019s pretty impressive that so many useful consequences can flow from the simple idea of symbolic programming : fitting computation to language, rather than the other way around. Symbolic programming and formal grammar Symbolic programming \u548c formal grammar\u90fd\u662f\u57fa\u4e8enesting\u5173\u7cfb\u6784\u5efa\u7684\u3002 \u672c\u8d28\u4e0a\u5b83\u4eec\u90fd\u662fexpression tree\u3002 Symbolic programming and functional programming \u5b83\u4eec\u5176\u5b9e\u90fd\u662f\u57fa\u4e8elambda-calculus\u7684\u3002 Application: Computer algebra Symbolic programming\u7684\u4e00\u4e2a\u91cd\u8981application\u5c31\u662fmathematics\uff0c\u672c\u8282\u5bf9\u6b64\u8fdb\u884c\u68b3\u7406\u3002 \u5173\u4e8eComputer algebra\uff0c\u53c2\u89c1\u5de5\u7a0bdiscrete\u7684 Relation-structure-computation\\Computation\\Computer-algebra \u7ae0\u8282\uff0c\u6216\u8005wikipedia Computer algebra \u3002 TODO 1) utexas CS 378: Symbolic Programming \u5df2\u7ecf\u5c06**Lecture Note**\u4e0b\u8f7d\u5230\u672c\u5730\u4e86\u3002 2) ybrikman Six programming paradigms that will change how you think about coding #Symbolic programming 3) stackoverflow Mathematica: what is symbolic programming? 4) wikipedia Symbolic programming and wikipedia Symbolic language (programming)","title":"Introduction"},{"location":"Symbolic-computation/Symbolic-programming/#symbolic#programming","text":"\u5728\u5b66\u4e60deep learning\u7684\u65f6\u5019\uff0c\u5176\u4e2d\u63cf\u8ff0\u4e86symbolic programing\uff0c\u56e0\u6b64\uff0c\u542f\u53d1\u4e86\u6211\u9700\u8981\u5bf9symbolic programming\u8fdb\u884c\u603b\u7ed3\u3002 wolfram\u662f\u91c7\u7528symbolic programming paradigm\u7684\u4e00\u79cdprogramming language\uff0c\u6240\u4ee5\uff0c\u6211\u4eec\u7ed3\u5408wolfram Symbolic Programming: Computationally Active Language \u6765\u7406\u89e3symbolic programming\u3002","title":"Symbolic programming"},{"location":"Symbolic-computation/Symbolic-programming/#wolfram#symbolic#programming#computationally#active#language","text":"NOTE: \u8fd9\u7bc7\u6587\u7ae0\u7684\u4f5c\u8005\u4ece\u4e00\u4e2a\u975e\u5e38\u9ad8\u3001\u62bd\u8c61\u7684\u5c42\u6b21\u5bf9symbolic programming\u8fdb\u884c\u4e86\u63cf\u8ff0\u3002wolfram\u662f\u4e00\u79cdprogramming language\uff0c\u5b83\u662f\u652f\u6301symbolic programming\u7684\u3002 In this blog and elsewhere, you\u2019ll often see the statement that some advanced Mathematica feature is just another application of symbolic programming . It\u2019s the kind of idea that seems too powerful to explain in a single blog post, yet simple enough that I am tempted to try. So, here goes. \u7ffb\u8bd1: \u5728\u672c\u535a\u5ba2\u548c\u5176\u4ed6\u5730\u65b9\uff0c\u60a8\u5c06\u7ecf\u5e38\u770b\u5230\u8fd9\u6837\u7684\u8bf4\u6cd5:\u67d0\u4e9b\u9ad8\u7ea7Mathematica\u7279\u6027\u53ea\u662fsymbolic programming\u7684\u53e6\u4e00\u4e2a\u5e94\u7528\u3002\u8fd9\u79cd\u60f3\u6cd5\u4f3c\u4e4e\u8fc7\u4e8e\u5f3a\u5927\u4ee5\u81f3\u4e8e\u65e0\u6cd5\u5728\u4e00\u7bc7\u535a\u5ba2\u6587\u7ae0\u4e2d\u89e3\u91ca\u6e05\u695a\uff0c\u4f46\u5374\u8db3\u591f\u7b80\u5355\uff0c\u8ba9\u6211\u5fcd\u4e0d\u4f4f\u53bb\u5c1d\u8bd5\u4e00\u4e0b\u3002 Symbolic programming is based on the concept of recasting(\u91cd\u94f8) core features of human language into a computationally active form . \u7ffb\u8bd1: \u7b26\u53f7\u7f16\u7a0b\u662f\u57fa\u4e8e\u5982\u4e0b\u6982\u5ff5: \u5c06\u4eba\u7c7b\u8bed\u8a00\u7684\u6838\u5fc3\u7279\u6027\u91cd\u94f8\u4e3a\u8ba1\u7b97\u6d3b\u52a8\u7684\u5f62\u5f0f\u3002\u5728\u540e\u9762\u5c06\u5b83\u79f0\u4e3a\"human-language-oriented programming language\"\u5373\"\u9762\u5411\u4eba\u7c7b\u8bed\u8a00\u7684\u7f16\u7a0b\u8bed\u8a00\"\u3002 NOTE: \u90a3\u4e0a\u8ff0**computationally active form**\u662f\u4ec0\u4e48form\u5462\uff1f\u5728\"Computation: The Transformation of Meaning\"\u7ae0\u8282\u4e2d\u4f1a\u5bf9\u6b64\u8fdb\u884c\u8bf4\u660e\u3002 What does it mean to have a human-language-oriented programming language? \u7ffb\u8bd1: \u62e5\u6709\u4e00\u79cd\u9762\u5411\u4eba\u7c7b\u8bed\u8a00\u7684\u7f16\u7a0b\u8bed\u8a00\u610f\u5473\u7740\u4ec0\u4e48? Our cognitive model of computation is typically a three-stage process: 1) describing the computation; 2) executing that description; and 3) outputting the results. The \u201clanguage\u201d part of most programming languages begins and ends with stage one. Linguistic structures are erected(\u5efa\u7acb) to describe the program. But the execution of the program is typically oriented around an entirely different system of types and objects; and likewise, the program\u2019s output structure tends to resemble nothing particularly language-like. Symbolic programming uses linguistic structures as the foundation of all aspects of computation . From a computation\u2019s description, to how the computation executes, to how humans interface with the results, the exact same basic tree structure is used throughout. This is a powerful unification (\u7edf\u4e00), making possible many useful computations that in other systems range from cumbersome to practically impossible. We\u2019ll see examples along the way, but let me first describe what these linguistic structures actually are. \u7ffb\u8bd1: \u8fd9\u662f\u4e00\u4e2a\u5f3a\u5927\u7684\u7edf\u4e00\uff0c\u4f7f\u5f97\u8bb8\u591a\u6709\u7528\u7684\u8ba1\u7b97\u6210\u4e3a\u53ef\u80fd\uff0c\u800c\u8fd9\u4e9b\u8ba1\u7b97\u5728\u5176\u4ed6\u7cfb\u7edf\u4e2d\u4ece\u7e41\u7410\u5230\u51e0\u4e4e\u4e0d\u53ef\u80fd\u3002 \u6211\u4eec\u4f1a\u770b\u5230\u4e00\u4e9b\u4f8b\u5b50\uff0c\u4f46\u8ba9\u6211\u5148\u63cf\u8ff0\u4e00\u4e0b\u8fd9\u4e9b\u8bed\u8a00\u7ed3\u6784\u5230\u5e95\u662f\u4ec0\u4e48\u3002 \u4e0b\u9762\u7684\u5c81\u4e0a\u9762\u4e09\u6bb5\u8bdd\u7684\u5185\u5bb9\u7684\u7406\u89e3\u3001\u5206\u6790: \u7b2c\u4e00\u6bb5\u8bdd\u548c\u7b2c\u4e8c\u6bb5\u8bdd\u5bf9\u6bd4\u4e86other programming language\u548cprogramming language using symbolic programming: \u4f5c\u8005\u8ba4\u4e3a\u5b83\u4eec\u4e4b\u95f4\u4e3b\u8981\u5dee\u5f02\u662f: Symbolic programming \u7684 model of computation \u90fd\u662f\u57fa\u4e8e\u5b83\u7684 linguistic structures \uff0c\u5b83\u91c7\u7528\u7684\u662f**unification**(\u7edf\u4e00)\u7684\u65b9\u5f0f\uff1b Symbolic programming \u7684 model of computation \u5176\u5b9e\u4e5f\u975e\u5e38\u5f3a\u5927\uff0c\u4e5f\u80fd\u591f\u5b9e\u73b0\u975e\u5e38\u591a\u7684computation\uff0c\u5728\u7b2c\u4e09\u6bb5\u8bdd\u4e2d\uff0c\u5bf9\u6b64\u8fdb\u884c\u4e86\u63cf\u8ff0\u3002 other programming language\u5219\u4e0d\u662f\u91c7\u7528\u7684**unification**(\u7edf\u4e00)\u7684\u65b9\u5f0f\uff0c\u5b83\u4eec\u7684execution of the program\u4e0d\u662f\u57fa\u4e8e\u5b83\u4eec\u7684**Linguistic structures**\u3002\u7ed3\u5408C\u6765\u7406\u89e3\u4e0a\u9762\u8fd9\u6bb5\u8bdd: C program\u662f\u9700\u8981\u7b26\u5408\u4e00\u5b9a\u7684**linguistic structure**\u7684\uff0cC program\u9700\u8981\u7ecf\u8fc7compiler\u7684\u7ffb\u8bd1\uff0c\u8f6c\u6362\u4e3ainstruction\u7684\u65b9\u5f0f\u6765\u7531CPU\u6267\u884c\uff0c\u663e\u7136C program\u7684\u6267\u884c\u4e0eC program\u7684linguistic structure\u662f\u4e0d\u4e00\u81f4\u7684\u3002 \u5728 stackoverflow Mathematica: what is symbolic programming? # A \u4e2d\u5bf9**Symbolic programming** \u7684 model of computation \u4e5f\u6709\u7740\u76f8\u5173\u7684\u89e3\u91ca: I would characterize a symbolic programming environment as one in which the expressions used to represent program text also happen to be the primary data structure. As a result, it becomes very easy to build abstractions upon abstractions since data can easily be transformed into code and vice versa. \u5f53\u4eca\uff0cprogramming language\u7684 linguistic structure \u90fd\u662f\u91c7\u7528\u7684tree structure\u3002","title":"wolfram Symbolic Programming: Computationally Active Language"},{"location":"Symbolic-computation/Symbolic-programming/#symbols#the#atoms#of#language","text":"\u7ffb\u8bd1: \u7b26\u53f7:\u8bed\u8a00\u7684\u539f\u5b50 Symbols are the basic atoms of language and also of symbolic programming . The point of symbols is to have distinct pieces of notation\u2014be they words or mathematical functions or musical notes\u2014which are then assigned an interpretation within the overall system. \u7ffb\u8bd1: \u7b26\u53f7\u662f\u8bed\u8a00\u7684\u57fa\u672c\u539f\u5b50\uff0c\u4e5f\u662f\u7b26\u53f7\u7f16\u7a0b\u7684\u57fa\u672c\u539f\u5b50\u3002\u7b26\u53f7\u7684\u610f\u4e49\u5728\u5b83\u80fd\u591f\u6709\u4e0d\u540c\u7684notation\u2014\u2014\u65e0\u8bba\u662f\u5355\u8bcd\u3001\u6570\u5b66\u51fd\u6570\u8fd8\u662f\u97f3\u7b26\u2014\u2014\u7136\u540e\u5728\u6574\u4e2a\u7cfb\u7edf\u4e2d\u88ab\u5206\u914d\u89e3\u91ca\u3002 \u76f4\u767d\u7684\u610f\u601d\u662f: symbol\u5176\u5b9e\u662f\u4e00\u79cd\u6307\u4ee3\uff0c\u5b83\u80fd\u591f\u6307\u4ee3\u7684\u4e8b\u7269\u7684\u8303\u56f4\u662f\u975e\u5e38\u5e7f\u6cdb\u7684\uff0c\u6bd4\u5982\u8fd9\u6bb5\u8bdd\u4e2d\u6240\u5217\u4e3e\u7684: word\u3001mathematical function\uff0c\u81f3\u4e8esymbol\u6240\u6307\u4ee3\u7684\u5185\u5bb9\uff0c\u9700\u8981\u540e\u7eed\u8fdb\u884c\u8d4b\u503c\uff0c\u8fd9\u5c31\u662f\u6700\u540e\u4e00\u6bb5\u8bdd\u7684\u542b\u4e49\u3002\u5728deep learning\u4e2d\uff0c\u4e00\u822c\u5c06symbol\u79f0\u4e3aplaceholder\uff0c\u6bd4\u5982: 1) mxnet Deep Learning Programming Paradigm : We define the abstract function in terms of placeholder values 2) TensorFlow \u540e\u9762\u4f1a\u5bf9symbol\u7684\u542b\u4e49\u3001\u4f5c\u7528\u8fdb\u884c\u66f4\u52a0\u5168\u9762\u7684\u63cf\u8ff0\u3002","title":"Symbols: The Atoms of Language"},{"location":"Symbolic-computation/Symbolic-programming/#symbol#vs#variable","text":"NOTE: \u4e24\u8005\u7684\u6838\u5fc3\u5dee\u522b\u5728\u4e8e: variable\u9700\u8981\u63d0\u524d\u5b9a\u4e49\u624d\u80fd\u591f\u4f7f\u7528\uff0c\u800csymbol\u4e0d\u9700\u8981\u5b9a\u4e49\u5c31\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528\u3002 In programming, the defining feature of symbols is that they can stand for themselves. This is in contrast to variables , which must stand for some other value or be considered an error. For instance, JavaScript cannot perform the operation x + x unless x has a value: while Mathematica has no trouble: By existing simply as distinct entities, symbols serve as lightweight carriers of meaning. They are inert\uff08\u60f0\u6027\u7684\u3001lazy\uff09, but can acquire meaning through combination with other symbols. For example the symbol for Pi is generically just another symbol, but when it appears \u201cwithin\u201d the symbol N , it takes on its special numerical meaning: Because Mathematica manipulates things abstractly, it is able to do more-precise computation than some other systems. As the above example makes clear, symbols are only the building blocks: the real action is with the arrangements of symbols. NOTE: arrangements of symbols\u5176\u5b9e\u5c31\u662f\u524d\u9762\u4e00\u76f4\u5f3a\u8c03\u7684structure\uff0c\u5c31\u662f\u4e0b\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u63cf\u8ff0\u7684Symbolic Expression\u3002","title":"symbol VS variable"},{"location":"Symbolic-computation/Symbolic-programming/#symbolic#expressions#combining#symbols#into#meaning","text":"NOTE: \u672c\u8282\u6807\u9898\u4e2d\uff0c\u6240\u8c13\u7684\"meaning\"\uff0c\u5176\u5b9e\u662fsemantic\u3002 An English phrase is built of subphrases. A mathematical formula is built of subformulas. A musical score is built of bars, which contain notes. A web page layout is built from sublayouts. When humans want to communicate nontrivial structures, they use hierarchical nesting. NOTE: \u5173\u4e8enesting\u5173\u7cfb\uff0c\u53c2\u89c1\u5de5\u7a0bdiscrete\u7684 Relation-structure-computation\\Model\\Nesting-relation-model \u7ae0\u8282 Across different languages and domains, these structures, or trees, take many syntactic forms. However, they can always be reduced to very simple data structures known as symbolic expressions . Symbolic expressions simply capture the concept of arranging symbols into trees . Here are a few trees built from the symbol \u201ce\u201d: Like the symbols themselves, trees of symbols may simply exist, without a need to correspond to something else: Symbolic expressions are the fabric from which we construct meaning. Different tree structures correspond to different meanings. NOTE: \u8fd9\u6bb5\u8bdd\u5176\u5b9e\u662f\u5bf9\u672c\u8282\u6807\u9898\u7684\u89e3\u91ca\uff0c\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u7684\u610f\u601d\u662f: \u5728symbolic programming\u4e2d\uff0c\u6211\u4eec\u4f1a\u4f7f\u7528 symbolic expression \uff0c\u901a\u8fc7 symbolic expression \uff0c\u6211\u4eec\u5b9e\u73b0\u4e86 \"construct meaning\"\u3002\u4e0d\u540c\u7684 symbolic expression \u6709\u7740\u4e0d\u540c\u7684 tree structure\uff0c\u4ece\u800c\u8868\u8fbe\u4e0d\u540c\u7684 meaning\u3002 A tree with symbols like Plus and Power may represent an arithmetic expression, while the symbol SetterBar can be combined with a subtree indicating the current selection and a list of possible alternatives: Everything in Mathematica is ultimately represented using this uniform simple structure . At the formal level, it ensures a degree of structural compatibility across all parts of the far-flung(\u5e7f\u6cdb\u7684) system. It also provides a system for introducing your own lightweight yet sophisticated structures. Pure functions , for example, are the original killer apps for lightweight structures of this vein. In Mathematica, they can be represented with Function , but let\u2019s roll our own using other generic primitives: MyPureFunction [ var_ , expr_ ][ arg_ ] := expr /. var -> arg Let\u2019s describe a function that adds 1 to its argument, and attach it to the symbol f . Notice the structure stays inert(\u60f0\u6027), and therefore can be passed around as data: When brought into contact with an argument , the definition fires. In symbolic programming , it is commonplace\uff08\u53f8\u7a7a\u89c1\u60ef\u7684\uff09 for a programmer to create abstractions that in another language would have required a modification of the core specification. This is the beauty of language: that creating new concepts does not require inventing new atomic \u201ctypes\u201d of things\u2014only new arrangements of structure. NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u7684\u542b\u4e49\u662f: \u5728\u5176\u5b83\u7684programming language\u4e2d\uff0c\u521b\u5efa\u65b0\u7684abstraction\u9700\u8981modification of the core specification\uff0c\u4f46\u662f\u5728**symbolic programming**\u4e2d\u5e76\u4e0d\u9700\u8981\uff0c\u5b83\u53ea\u9700\u8981new arrangement of structure\u3002","title":"Symbolic Expressions: Combining Symbols into Meaning"},{"location":"Symbolic-computation/Symbolic-programming/#computation#the#transformation#of#meaning","text":"The most important and unique aspect of symbolic programming is that these tree structures can be made computationally active . They don\u2019t just describe things\u2014they actually execute. The basic idea is that because meaning is encoded by structure , computation \u2014the transformation of one meaning into another\u2014corresponds to the transformation of one structure into another. For instance, position 1 in the SetterBar expression represents the current selection. By modifying the tree at that position, we modify the meaning of the expression as a whole: A computation begins and ends with unique, domain-specific structures. The process of computation, however, is executed using extremely general methods that are exactly the same across domains: So, computation proceeds by very generic tree transformations . Rather conveniently, trees are also how we specify the computations themselves. NOTE: computation\u3001representation\u90fd\u662f\u57fa\u4e8etree\u7684\uff0c\u8fd9\u5c31\u662f\u5728\u672c\u6587\u524d\u9762\u6240\u63d0\u51fa\u7684\u6838\u5fc3\u601d\u60f3\u3002 This reduces the process of computation into a linguistic puzzle: using trees to describe how other trees should transform and intersect. Not only does this allow computational primitives to have an immediate and clear meaning, it also allows the process of language design to proceed organically as regularities in these tree structures are discovered and abstracted.","title":"Computation: The Transformation of Meaning"},{"location":"Symbolic-computation/Symbolic-programming/#representing#and#interacting#with#meaning","text":"Symbolic programming\u2019s comprehensive emphasis on meaning allows a unique perspective on input, output and the whole interaction cycle between human and machine computation. The basic idea is that symbolic expressions are the canonical, abstract containers of meaning. Given a symbolic expression, its meaning can then be embodied in a number of useful ways. For example, the expression Plus[2,2] is rendered as 2+2 . And Graphics[Rectangle[]] renders as: And it works similarly for all sorts of domain-specific mathematics notation, documents and even sound and music primitives. On their own, these are useful representations. But the fact that they are still really the same underlying expression leads to a powerful consequence: human computation and programmatic computation become structurally equivalent. If I interactively create a Disk using a drawing palette: its underlying data structure is the same as it would be if I had typed in the code, or if it had been generated by a program: Graphics[Disk[{0.49, 0.49}, {0.35, 0.35}],ImageSize -> {36.335, Automatic},PlotRange -> {{0, 1}, {0, 1}}] Completely different representations\u2014in this case text and graphics\u2014are immediately and transparently compatible, because in the end they are all just expressions . Here we have some \u201czero-overhead\u201d code to color just the disks of a graphic : The equivalence between these representations, and between human and programmatically generated structures, opens the door to exceptionally powerful ways of interacting with computation. It is the basis of Mathematica\u2019s dynamic interactivity framework. The implications, however, go much further than that. Symbolic programming is the first abstraction that can uniformly span all three stages of computation, from specification to execution to output, and as a result it can leverage each aspect against the others. Programs can be created by traditional programming, by the programs themselves or by interaction with what is considered output. The process of computation can be equivalently executed by the user or by the machine. Output is simply exposing a window into a piece of a (possibly running) program. It\u2019s pretty impressive that so many useful consequences can flow from the simple idea of symbolic programming : fitting computation to language, rather than the other way around.","title":"Representing and Interacting with Meaning"},{"location":"Symbolic-computation/Symbolic-programming/#symbolic#programming#and#formal#grammar","text":"Symbolic programming \u548c formal grammar\u90fd\u662f\u57fa\u4e8enesting\u5173\u7cfb\u6784\u5efa\u7684\u3002 \u672c\u8d28\u4e0a\u5b83\u4eec\u90fd\u662fexpression tree\u3002","title":"Symbolic programming and formal grammar"},{"location":"Symbolic-computation/Symbolic-programming/#symbolic#programming#and#functional#programming","text":"\u5b83\u4eec\u5176\u5b9e\u90fd\u662f\u57fa\u4e8elambda-calculus\u7684\u3002","title":"Symbolic programming and functional programming"},{"location":"Symbolic-computation/Symbolic-programming/#application#computer#algebra","text":"Symbolic programming\u7684\u4e00\u4e2a\u91cd\u8981application\u5c31\u662fmathematics\uff0c\u672c\u8282\u5bf9\u6b64\u8fdb\u884c\u68b3\u7406\u3002 \u5173\u4e8eComputer algebra\uff0c\u53c2\u89c1\u5de5\u7a0bdiscrete\u7684 Relation-structure-computation\\Computation\\Computer-algebra \u7ae0\u8282\uff0c\u6216\u8005wikipedia Computer algebra \u3002","title":"Application: Computer algebra"},{"location":"Symbolic-computation/Symbolic-programming/#todo","text":"1) utexas CS 378: Symbolic Programming \u5df2\u7ecf\u5c06**Lecture Note**\u4e0b\u8f7d\u5230\u672c\u5730\u4e86\u3002 2) ybrikman Six programming paradigms that will change how you think about coding #Symbolic programming 3) stackoverflow Mathematica: what is symbolic programming? 4) wikipedia Symbolic programming and wikipedia Symbolic language (programming)","title":"TODO"},{"location":"Symbolic-computation/Symbolic-programming/utexas-CS-378-Symbolic-Programming/","text":"utexas CS 378, Symbolic Programming Symbolic Programming Symbols are words that refer to, or denote, other things: their referents : Variable names in programming languages Variables in equations English words Symbolic Programming manipulates stuctures of symbols, typically represented as trees: solve equations translate a program to another language specialize a generic program convert units of measurement translate English into a database query compose program components Functional Programming A functional program is one with no side effects: changing a global variable updating a database printing If we call sin(x) , it will just return a value, but will have no side effects. Functional programming does everything by composition of functions: guacamole : season ( mash ( slice ( peel ( wash ( avocado ))))) Functions are composed so that the output of one function is the input of the next function(pipelined). Functional programming works well with distributed cloud computing: the function can be replicated on many servers and executed in parallel on massive amounts of data.","title":"Introduction"},{"location":"Symbolic-computation/Symbolic-programming/utexas-CS-378-Symbolic-Programming/#utexas#cs#378#symbolic#programming","text":"","title":"utexas CS 378, Symbolic Programming"},{"location":"Symbolic-computation/Symbolic-programming/utexas-CS-378-Symbolic-Programming/#symbolic#programming","text":"Symbols are words that refer to, or denote, other things: their referents : Variable names in programming languages Variables in equations English words Symbolic Programming manipulates stuctures of symbols, typically represented as trees: solve equations translate a program to another language specialize a generic program convert units of measurement translate English into a database query compose program components","title":"Symbolic Programming"},{"location":"Symbolic-computation/Symbolic-programming/utexas-CS-378-Symbolic-Programming/#functional#programming","text":"A functional program is one with no side effects: changing a global variable updating a database printing If we call sin(x) , it will just return a value, but will have no side effects. Functional programming does everything by composition of functions: guacamole : season ( mash ( slice ( peel ( wash ( avocado ))))) Functions are composed so that the output of one function is the input of the next function(pipelined). Functional programming works well with distributed cloud computing: the function can be replicated on many servers and executed in parallel on massive amounts of data.","title":"Functional Programming"},{"location":"Symbolic-computation/What-is-symbol/","text":"Symbol expression What is symbol? \"symbol\"\u5373\"\u7b26\u53f7\"\u3002 wikipedia Symbol (formal) symbol\u662f\u4e00\u79cdabstraction\u3001\u6307\u4ee3 Symbol\u662f\u4e00\u79cd\u62bd\u8c61\u3001\u6307\u4ee3\uff0c\u5b83\u65e0\u5904\u4e0d\u5728: 1) \u51fd\u6570\u7684\u5165\u53c2\u53ef\u4ee5\u770b\u505a\u662fsymbol\uff0c\u5b83\u53ef\u4ee5\u6307\u4ee3\u591a\u79cd\u7c7b\u578b\u7684\u5165\u53c2 2) polymorphism\u5176\u5b9e\u662f\u4f9d\u8d56\u4e8esymbol\u7684 \u5b83\u4f7f\u7528\u4e00\u4e2asymbol\u8fdb\u884c\u6307\u4ee3: single interface to entities of different types use of a single symbol to represent multiple different types \u5173\u4e8e\u6b64\u53c2\u89c1wikipedia Polymorphism \u3002 2) formal grammar\u4e2d\uff0c\u5c31\u662f \u4f7f\u7528symbol expression\u6765\u63cf\u8ff0language\u7684abstract structure \u4ecewikipedia Formal grammar \u4e2d\uff0c\u53ef\u4ee5\u770b\u5230\uff0c\u5176\u4e2d\u5927\u91cf\u7684\u4f7f\u7528symbol\u3002 3) Computer algebra\u5c31\u662f\u4f7f\u7528symbol expression\u6765\u63cf\u8ff0algebra\u7684abstract structure wikipedia Computer algebra Formal semantic \u53c2\u89c1\u5de5\u7a0b compiler-principle \u7684 Formal-semantic \u7ae0\u8282\u3002 \u6d89\u53casymbol\u7684\u7ae0\u8282 \u5de5\u7a0b programming-language \u7684 Theory\\Programming-paradigm\\Polymorphism \u7ae0\u8282 \u5de5\u7a0b programming-language \u7684 Theory\\Programming-paradigm\\Polymorphism\\Parametric-polymorphism \u7ae0\u8282\u3002","title":"Introduction"},{"location":"Symbolic-computation/What-is-symbol/#symbol#expression","text":"","title":"Symbol expression"},{"location":"Symbolic-computation/What-is-symbol/#what#is#symbol","text":"\"symbol\"\u5373\"\u7b26\u53f7\"\u3002","title":"What is symbol?"},{"location":"Symbolic-computation/What-is-symbol/#wikipedia#symbol#formal","text":"","title":"wikipedia Symbol (formal)"},{"location":"Symbolic-computation/What-is-symbol/#symbolabstraction","text":"Symbol\u662f\u4e00\u79cd\u62bd\u8c61\u3001\u6307\u4ee3\uff0c\u5b83\u65e0\u5904\u4e0d\u5728: 1) \u51fd\u6570\u7684\u5165\u53c2\u53ef\u4ee5\u770b\u505a\u662fsymbol\uff0c\u5b83\u53ef\u4ee5\u6307\u4ee3\u591a\u79cd\u7c7b\u578b\u7684\u5165\u53c2 2) polymorphism\u5176\u5b9e\u662f\u4f9d\u8d56\u4e8esymbol\u7684 \u5b83\u4f7f\u7528\u4e00\u4e2asymbol\u8fdb\u884c\u6307\u4ee3: single interface to entities of different types use of a single symbol to represent multiple different types \u5173\u4e8e\u6b64\u53c2\u89c1wikipedia Polymorphism \u3002 2) formal grammar\u4e2d\uff0c\u5c31\u662f \u4f7f\u7528symbol expression\u6765\u63cf\u8ff0language\u7684abstract structure \u4ecewikipedia Formal grammar \u4e2d\uff0c\u53ef\u4ee5\u770b\u5230\uff0c\u5176\u4e2d\u5927\u91cf\u7684\u4f7f\u7528symbol\u3002 3) Computer algebra\u5c31\u662f\u4f7f\u7528symbol expression\u6765\u63cf\u8ff0algebra\u7684abstract structure wikipedia Computer algebra","title":"symbol\u662f\u4e00\u79cdabstraction\u3001\u6307\u4ee3"},{"location":"Symbolic-computation/What-is-symbol/#formal#semantic","text":"\u53c2\u89c1\u5de5\u7a0b compiler-principle \u7684 Formal-semantic \u7ae0\u8282\u3002","title":"Formal semantic"},{"location":"Symbolic-computation/What-is-symbol/#symbol","text":"\u5de5\u7a0b programming-language \u7684 Theory\\Programming-paradigm\\Polymorphism \u7ae0\u8282 \u5de5\u7a0b programming-language \u7684 Theory\\Programming-paradigm\\Polymorphism\\Parametric-polymorphism \u7ae0\u8282\u3002","title":"\u6d89\u53casymbol\u7684\u7ae0\u8282"}]}